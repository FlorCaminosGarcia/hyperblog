/*!
 * NevWare21 - ts-async, 0.2.6
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
define(['exports'], (function (exports) { 'use strict';

    const UNDEF_VALUE = undefined;
    const NULL_VALUE = null;
    const EMPTY = "";
    const FUNCTION = "function";
    const NUMBER = "number";
    const OBJECT = "object";
    const PROTOTYPE = "prototype";
    const __PROTO__ = "__proto__";
    const UNDEFINED = "undefined";
    const CONSTRUCTOR = "constructor";
    const SYMBOL = "Symbol";
    const POLYFILL_TAG = "_polyfill";
    const INDEX_OF = "indexOf";
    const LENGTH = "length";
    const VALUE = "value";
    const NAME = "name";
    const SLICE = "slice";
    const ObjClass = Object;
    const ObjProto = ObjClass[PROTOTYPE];
    const StrCls = String;
    const ArrCls = Array;
    const ArrProto = ArrCls[PROTOTYPE];

    function safeGet(cb, defValue) {
        let result = defValue;
        try {
            result = cb();
        }
        catch (e) {
        }
        return result;
    }

    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    function _createObjIs(theName) {
        const theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    function objToString(value) {
        return ObjProto.toString.call(value);
    }
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    const isFunction = _createIs(FUNCTION);
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    const isArray = ArrCls.isArray;
    const isNumber = _createIs(NUMBER);
    const isError = _createObjIs("Error");
    function isPromiseLike(value) {
        return !!value && isFunction(value.then);
    }

    const objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

    function objHasOwnProperty(obj, prop) {
        return obj && ObjProto.hasOwnProperty.call(obj, prop);
    }

    const objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }

    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (const prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }

    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        let theMap = {};
        objForEachKey(values, (key, value) => {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }

    function throwTypeError(message) {
        throw new TypeError(message);
    }

    const _objFreeze = ObjClass["freeze"];
    const _doNothing = (value) => value;
    const _getProto = (value) => value[__PROTO__] || NULL_VALUE;
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, (key, value) => {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    const objFreeze = _objFreeze || _doNothing;
    const objGetPrototypeOf = ObjClass["getPrototypeOf"] || _getProto;

    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }

    const _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });

    const asString = StrCls;

    const GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    let _globalCfg;
    function _getGlobalValue() {
        let result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    function _getGlobalConfig() {
        if (!_globalCfg) {
            let gbl = _getGlobalValue() || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }

    function dumpObj(object, format) {
        let propertyValueDump = EMPTY;
        if (isError(object)) {
            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
        }
        else {
            try {
                propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
            }
            catch (e) {
                propertyValueDump = " - " + dumpObj(e, format);
            }
        }
        return objToString(object) + ": " + propertyValueDump;
    }

    function _unwrapFunction(funcName, target, polyFunc) {
        return function (thisArg) {
            let theFunc = (thisArg && thisArg[funcName]) || (target && target[funcName]);
            if (theFunc || polyFunc) {
                let theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrProto[SLICE].call(theArgs, 1) : theArgs);
            }
            throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
        };
    }
    function _unwrapProp(propName) {
        return function (thisArg) {
            return thisArg[propName];
        };
    }

    let _wellKnownSymbolCache = {};
    function polyNewSymbol(description) {
        let theSymbol = {
            description: asString(description),
            toString: () => SYMBOL + "(" + description + ")"
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    function polyGetKnownSymbol(name) {
        let result;
        let knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }

    const propMap = {
        e: "enumerable",
        c: "configurable",
        v: VALUE,
        w: "writable",
        g: "get",
        s: "set"
    };
    function _createProp(value) {
        let prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = () => value.l.v;
            let desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = (newValue) => {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, (key, value) => {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    const objDefineProp = ObjClass["defineProperty"];
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }

    let _globalLazyTestHooks;
    let _fetchLazyTestHooks = function () {
        _globalLazyTestHooks = _getGlobalConfig();
        _fetchLazyTestHooks = NULL_VALUE;
    };
    function getLazy(cb) {
        let lazyValue = {};
        _fetchLazyTestHooks && _fetchLazyTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                let result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                    if (lazyValue.b) {
                        delete lazyValue.b;
                    }
                }
                if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                    lazyValue.b = _globalLazyTestHooks.lzy;
                }
                return result;
            }
        });
        return lazyValue;
    }

    function safeGetLazy(cb, defValue) {
        return getLazy(() => safeGet(cb, defValue));
    }

    const WINDOW = "window";
    let _cachedGlobal;
    let _cachedWindow;
    let _cachedDocument;
    let _isNode;
    function lazySafeGetInst(name) {
        return safeGetLazy(() => getInst(name) || UNDEF_VALUE, UNDEF_VALUE);
    }
    function getGlobal(useCached) {
        (!_cachedGlobal || useCached === false || (_globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
        return _cachedGlobal.v;
    }
    function getInst(name, useCached) {
        const gbl = getGlobal(useCached);
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW && _cachedWindow) {
            return _cachedWindow.v;
        }
        return NULL_VALUE;
    }
    function getDocument() {
        (!_cachedDocument || (_globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
        return _cachedDocument.v;
    }
    function getWindow() {
        (!_cachedWindow || (_globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
        return _cachedWindow.v;
    }
    function isNode() {
        !_isNode && (_isNode = safeGetLazy(() => !!(process && (process.versions || {}).node), false));
        return _isNode.v;
    }

    let _symbol;
    let _symbolFor;
    let _symbolKeyFor;
    function _getSymbolValue(name) {
        return safeGetLazy(function () {
            return (_symbol.v ? _symbol[name] : UNDEF_VALUE);
        }, UNDEF_VALUE);
    }
    function hasSymbol() {
        return !!getSymbol();
    }
    function getSymbol() {
        let resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
        resetCache && (_symbol = lazySafeGetInst(SYMBOL));
        (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
        (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
        return _symbol.v;
    }
    function getKnownSymbol(name, noPoly) {
        let knownName = _wellKnownSymbolMap[name];
        (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }

    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            const len = theArray[LENGTH] >>> 0;
            for (let idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }

    const arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto);

    const arrSlice = _unwrapFunction(SLICE, ArrProto);

    const _objCreate = ObjClass["create"];
    const objCreate = _objCreate || polyObjCreate;
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        let type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throw new TypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }

    let _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        let fn = ObjClass["setPrototypeOf"] ||
            function (d, b) {
                !_isProtoArray && (_isProtoArray = getLazy(() => ({ [__PROTO__]: [] } instanceof Array)));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, (key, value) => d[key] = value);
            };
        return fn(obj, proto);
    }

    const _createCustomError = (name, d, b) => {
        _safeDefineName(d, name);
        d = objSetPrototypeOf(d, b);
        function __() {
            this.constructor = d;
            _safeDefineName(this, name);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    };
    const _safeSetName = (baseClass, name) => {
        try {
            name && (baseClass[NAME] = name);
        }
        catch (e) {
        }
    };
    const _safeDefineName = (target, name) => {
        try {
            objDefine(target, NAME, { v: name, c: true, e: false });
        }
        catch (e) {
        }
    };
    function createCustomError(name, constructCb, errorBase) {
        let theBaseClass = errorBase || Error;
        let orgName = theBaseClass[PROTOTYPE][NAME];
        let captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            let _this = this;
            try {
                _safeSetName(theBaseClass, name);
                let _self = theBaseClass.apply(_this, arguments) || _this;
                if (_self !== _this) {
                    let orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, arguments);
                return _self;
            }
            finally {
                _safeSetName(theBaseClass, orgName);
            }
        }, theBaseClass);
    }

    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    function polyUtcNow() {
        return new Date().getTime();
    }

    const getLength = _unwrapProp(LENGTH);

    let _perf;
    function getPerformance() {
        (!_perf || (_globalLazyTestHooks.lzy && !_perf.b)) && (_perf = lazySafeGetInst("performance"));
        return _perf.v;
    }
    function perfNow() {
        let perf = getPerformance();
        if (perf && perf.now) {
            return perf.now();
        }
        return utcNow();
    }
    function elapsedTime(startTime) {
        return perfNow() - startTime;
    }

    const REF = "ref";
    const UNREF = "un" + REF;
    const HAS_REF = "hasRef";
    const ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        let ref = true;
        let timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        let theTimerHandler;
        const _unref = () => {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        };
        const _ref = () => {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        const _hasRef = () => {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        const _refresh = () => {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        };
        const _cancel = () => {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        };
        const _setEnabled = (value) => {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        };
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh,
            [HAS_REF]: _hasRef,
            [REF]: _ref,
            [UNREF]: _unref,
            [ENABLED]: false
        };
        objDefineProp(theTimerHandler, ENABLED, {
            get: () => !!timerId,
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: () => {
                timerId = NULL_VALUE;
            }
        };
    }

    function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
        let isArr = isArray(overrideFn);
        let len = isArr ? overrideFn.length : 0;
        let setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        let clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        let timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            timerFn.apply(self, arguments);
        };
        let handler = _createTimerHandler(startTimer, (timerId) => {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                clearFn.call(self, timerId);
            }
            return setFn.apply(self, theArgs);
        }, function (timerId) {
            clearFn.call(self, timerId);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
    }

    let _hasIdleCallback;
    let _defaultIdleTimeout$1 = 100;
    let _maxExecutionTime = 50;
    function hasIdleCallback() {
        !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(() => isDefined(requestIdleCallback), false));
        return !!(_hasIdleCallback.v ? requestIdleCallback : false);
    }
    function scheduleIdleCallback(callback, options) {
        function _createDeadline(timedOut) {
            let startTime = perfNow();
            return {
                didTimeout: timedOut,
                timeRemaining: () => {
                    return _maxExecutionTime - elapsedTime(startTime);
                }
            };
        }
        if (hasIdleCallback()) {
            let handler = _createTimerHandler(true, (idleId) => {
                idleId && cancelIdleCallback(idleId);
                return requestIdleCallback((deadline) => {
                    handler.dn();
                    callback(deadline || _createDeadline(false));
                }, options);
            }, (idleId) => {
                cancelIdleCallback(idleId);
            });
            return handler.h;
        }
        let timeout = (options || {}).timeout;
        if (isUndefined(timeout)) {
            timeout = _defaultIdleTimeout$1;
        }
        return scheduleTimeout(() => {
            callback(_createDeadline(true));
        }, timeout);
    }

    function doAwaitResponse(value, cb) {
        return doAwait(value, (value) => {
            cb && cb({
                value: value,
                rejected: false
            });
        }, (reason) => {
            cb && cb({
                rejected: true,
                reason: reason
            });
        });
    }
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
        let result = value;
        if (isPromiseLike(value)) {
            if (resolveFn || rejectFn) {
                result = value.then(resolveFn, rejectFn);
            }
        }
        else {
            resolveFn && resolveFn(value);
        }
        if (finallyFn) {
            result = doFinally(result, finallyFn);
        }
        return result;
    }
    function doFinally(value, finallyFn) {
        let result = value;
        if (finallyFn) {
            if (isPromiseLike(value)) {
                if (value.finally) {
                    result = value.finally(finallyFn);
                }
                else {
                    result = value.then(function (value) {
                        finallyFn();
                        return value;
                    }, function (reason) {
                        finallyFn();
                        throw reason;
                    });
                }
            }
            else {
                finallyFn();
            }
        }
        return result;
    }

    let _debugState;
    let _debugResult;
    let _debugHandled;
    let _promiseDebugEnabled = false;
    function _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {
        _debugState = _debugState || { toString: () => "[[PromiseState]]" };
        _debugResult = _debugResult || { toString: () => "[[PromiseResult]]" };
        _debugHandled = _debugHandled || { toString: () => "[[PromiseIsHandled]]" };
        objDefineProp(thePromise, _debugState, { get: stateFn });
        objDefineProp(thePromise, _debugResult, { get: resultFn });
        objDefineProp(thePromise, _debugHandled, { get: handledFn });
    }
    function setPromiseDebugState(enabled, logger) {
        _promiseDebugEnabled = enabled;
    }

    const STRING_STATES = [
        "pending", "resolving", "resolved", "rejected"
    ];

    const DISPATCH_EVENT = "dispatchEvent";
    let _hasInitEvent;
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
        let doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = safeGetLazy(() => {
            let evt;
            if (doc && doc.createEvent) {
                evt = doc.createEvent("Event");
            }
            return (!!evt && evt.initEvent);
        }, null));
        let theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
            theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
            target[DISPATCH_EVENT](theEvt);
        }
        else {
            let handler = target["on" + evtName];
            if (handler) {
                handler(theEvt);
            }
            else {
                let theConsole = getInst("console");
                theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
            }
        }
    }

    const STR_PROMISE = "Promise";

    const NODE_UNHANDLED_REJECTION = "unhandledRejection";
    const UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
    let _currentPromiseId = [];
    let _uniquePromiseId = 0;
    let _unhandledRejectionTimeout = 10;
    let _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
        if (isFunction(value)) {
            return value.toString();
        }
        return dumpObj(value);
    }
    function _createPromise(newPromise, processor, executor) {
        let additionalArgs = arrSlice(arguments, 3);
        let _state = 0;
        let _hasResolved = false;
        let _settledValue;
        let _queue = [];
        let _id = _uniquePromiseId++;
        let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
        let _handled = false;
        let _unHandledRejectionHandler = null;
        let _thePromise;
        !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
        const _then = (onResolved, onRejected) => {
            try {
                _currentPromiseId.push(_id);
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                let thenPromise = newPromise(function (resolve, reject) {
                    _queue.push(function () {
                        try {
                            let handler = _state === 2 ? onResolved : onRejected;
                            let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                            if (isPromiseLike(value)) {
                                value.then(resolve, reject);
                            }
                            else if (handler) {
                                resolve(value);
                            }
                            else if (_state === 3) {
                                reject(value);
                            }
                            else {
                                resolve(value);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    if (_hasResolved) {
                        _processQueue();
                    }
                }, additionalArgs);
                return thenPromise;
            }
            finally {
                _currentPromiseId.pop();
            }
        };
        const _catch = (onRejected) => {
            return _then(undefined, onRejected);
        };
        const _finally = (onFinally) => {
            let thenFinally = onFinally;
            let catchFinally = onFinally;
            if (isFunction(onFinally)) {
                thenFinally = function (value) {
                    onFinally && onFinally();
                    return value;
                };
                catchFinally = function (reason) {
                    onFinally && onFinally();
                    throw reason;
                };
            }
            return _then(thenFinally, catchFinally);
        };
        const _strState = () => {
            return STRING_STATES[_state];
        };
        const _processQueue = () => {
            if (_queue.length > 0) {
                let pending = _queue.slice();
                _queue = [];
                _handled = true;
                processor(pending);
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
            }
        };
        const _createSettleIfFn = (newState, allowState) => {
            return (theValue) => {
                if (_state === allowState) {
                    if (newState === 2 && isPromiseLike(theValue)) {
                        _state = 1;
                        theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                        return;
                    }
                    _state = newState;
                    _hasResolved = true;
                    _settledValue = theValue;
                    _processQueue();
                    if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                        _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                    }
                }
            };
        };
        const _notifyUnhandledRejection = () => {
            if (!_handled) {
                if (isNode()) {
                    process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                }
                else {
                    let gbl = getWindow() || getGlobal();
                    emitEvent(gbl, UNHANDLED_REJECTION, (theEvt) => {
                        objDefine(theEvt, "promise", { g: () => _thePromise });
                        theEvt.reason = _settledValue;
                        return theEvt;
                    }, !!_hasPromiseRejectionEvent.v);
                }
            }
        };
        _thePromise = {
            then: _then,
            "catch": _catch,
            finally: _finally
        };
        objDefineProp(_thePromise, "state", {
            get: _strState
        });
        if (_promiseDebugEnabled) {
            _addDebugState$1(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);
        }
        if (hasSymbol()) {
            _thePromise[getKnownSymbol(11)] = "IPromise";
        }
        const _toString = () => {
            return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
        };
        _thePromise.toString = _toString;
        (function _initialize() {
            if (!isFunction(executor)) {
                throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
            }
            const _rejectFn = _createSettleIfFn(3, 0);
            try {
                executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
            }
            catch (e) {
                _rejectFn(e);
            }
        })();
        return _thePromise;
    }
    function _createAllPromise(newPromise) {
        return function (input) {
            let additionalArgs = arrSlice(arguments, 1);
            return newPromise((resolve, reject) => {
                try {
                    let values = [];
                    let pending = 1;
                    arrForEach(input, (item, idx) => {
                        if (item) {
                            pending++;
                            doAwait(item, (value) => {
                                values[idx] = value;
                                if (--pending === 0) {
                                    resolve(values);
                                }
                            }, reject);
                        }
                    });
                    pending--;
                    if (pending === 0) {
                        resolve(values);
                    }
                }
                catch (e) {
                    reject(e);
                }
            }, additionalArgs);
        };
    }
    function _createResolvedPromise(newPromise) {
        return function (value) {
            let additionalArgs = arrSlice(arguments, 1);
            if (isPromiseLike(value)) {
                return value;
            }
            return newPromise((resolve) => {
                resolve(value);
            }, additionalArgs);
        };
    }
    function _createRejectedPromise(newPromise) {
        return function (reason) {
            let additionalArgs = arrSlice(arguments, 1);
            return newPromise((_resolve, reject) => {
                reject(reason);
            }, additionalArgs);
        };
    }

    const _processPendingItems = (pending) => {
        arrForEach(pending, (fn) => {
            try {
                fn();
            }
            catch (e) {
            }
        });
    };
    function syncItemProcessor() {
        return _processPendingItems;
    }
    function timeoutItemProcessor(timeout) {
        let callbackTimeout = isNumber(timeout) ? timeout : 0;
        return (pending) => {
            scheduleTimeout(() => {
                _processPendingItems(pending);
            }, callbackTimeout);
        };
    }
    function idleItemProcessor(timeout) {
        let options;
        if (timeout >= 0) {
            options = {
                timeout: +timeout
            };
        }
        return (pending) => {
            scheduleIdleCallback((deadline) => {
                _processPendingItems(pending);
            }, options);
        };
    }

    function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    const createAsyncAllPromise = _createAllPromise(createAsyncPromise);
    const createAsyncResolvedPromise = _createResolvedPromise(createAsyncPromise);
    const createAsyncRejectedPromise = _createRejectedPromise(createAsyncPromise);

    let _isPromiseSupported;
    function createNativePromise(executor, timeout) {
        !_isPromiseSupported && (_isPromiseSupported = lazySafeGetInst(STR_PROMISE));
        const PrmCls = _isPromiseSupported.v;
        if (!PrmCls) {
            return createAsyncPromise(executor);
        }
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
        }
        let _state = 0;
        function _strState() {
            return STRING_STATES[_state];
        }
        let thePromise = new PrmCls((resolve, reject) => {
            function _resolve(value) {
                _state = 2;
                resolve(value);
            }
            function _reject(reason) {
                _state = 3;
                reject(reason);
            }
            executor(_resolve, _reject);
        });
        objDefineProp(thePromise, "state", {
            get: _strState
        });
        return thePromise;
    }
    const createNativeAllPromise = _createAllPromise(createNativePromise);
    const createNativeResolvedPromise = _createResolvedPromise(createNativePromise);
    const createNativeRejectedPromise = _createRejectedPromise(createNativePromise);

    function createSyncPromise(executor) {
        return _createPromise(createSyncPromise, syncItemProcessor(), executor);
    }
    const createSyncAllPromise = _createAllPromise(createSyncPromise);
    const createSyncResolvedPromise = _createResolvedPromise(createSyncPromise);
    const createSyncRejectedPromise = _createRejectedPromise(createSyncPromise);

    let _defaultIdleTimeout;
    function setDetaultIdleTimeout(idleDeadline) {
        _defaultIdleTimeout = idleDeadline;
    }
    function createIdlePromise(executor, timeout) {
        let theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;
        return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);
    }
    const createIdleAllPromise = _createAllPromise(createIdlePromise);
    const createIdleResolvedPromise = _createResolvedPromise(createIdlePromise);
    const createIdleRejectedPromise = _createRejectedPromise(createIdlePromise);

    let _promiseCreator;
    function setCreatePromiseImpl(creator) {
        _promiseCreator = creator ? getLazy(() => creator) : null;
    }
    function createPromise(executor, timeout) {
        !_promiseCreator && (_promiseCreator = getLazy(() => createNativePromise));
        return _promiseCreator.v.call(this, executor, timeout);
    }
    const createAllPromise = _createAllPromise(createPromise);
    const createResolvedPromise = _createResolvedPromise(createPromise);
    const createRejectedPromise = _createRejectedPromise(createPromise);

    const REJECT = "reject";
    const REJECTED_ERROR = "Rejected";
    let _schedulerId = 0;
    let _debugName;
    let _debugIntState;
    let _customErrors = {};
    const _rejectDone = () => {
    };
    var _createError = (type, evt, message) => {
        !_customErrors[type] && (_customErrors[type] = createCustomError(type));
        let now = utcNow();
        return new (_customErrors[type])(`Task [${evt.id}] ${message || ""}- ${(evt.st ? "Running" : "Waiting")}: ${_calcTime(now, evt.st || evt.cr)}`);
    };
    function _calcTime(now, start) {
        return ((now - start) || "0") + " ms";
    }
    function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
        let now = utcNow();
        let expired = now - staleTimeoutPeriod;
        arrForEach(taskQueue, (evt) => {
            if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
                evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
            }
        });
    }
    function _removeTask(queue, taskDetail) {
        let idx = arrIndexOf(queue, taskDetail);
        if (idx !== -1) {
            queue.splice(idx, 1);
        }
    }
    function _addDebugState(theScheduler, nameFn, stateFn) {
        _debugName = _debugName || { toString: () => "[[SchedulerName]]" };
        _debugIntState = _debugIntState || { toString: () => "[[SchedulerState]]" };
        objDefineProp(theScheduler, _debugName, { get: nameFn });
        objDefineProp(theScheduler, _debugIntState, { get: stateFn });
    }
    function createTaskScheduler(newPromise, name) {
        let _theTask;
        let _running = [];
        let _waiting = [];
        let _staleTimeoutPeriod = 600000;
        let _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
        let _taskCount = 0;
        let _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
        let _blockedTimer;
        newPromise = newPromise || createPromise;
        const _startBlockedTimer = () => {
            let hasTasks = (getLength(_running) + getLength(_waiting)) > 0;
            if (_staleTimeoutPeriod > 0) {
                if (!_blockedTimer) {
                    _blockedTimer = scheduleTimeout(() => {
                        _abortStaleTasks(_running, _staleTimeoutPeriod);
                        _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                        _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));
                    }, _staleTimeoutCheckPeriod);
                    _blockedTimer.unref();
                }
                _blockedTimer && (_blockedTimer.enabled = hasTasks);
            }
        };
        const _queueTask = (startAction, taskName, timeout) => {
            let taskId = _schedulerName + "." + _taskCount++;
            if (taskName) {
                taskId += "-(" + taskName + ")";
            }
            let newTask = {
                id: taskId,
                cr: utcNow(),
                to: timeout,
                [REJECT]: (reason) => {
                    newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                    newTask[REJECT] = _rejectDone;
                }
            };
            if (!_theTask) {
                newTask.p = newPromise(_runTask(newTask, startAction));
            }
            else {
                newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
            }
            _theTask = newTask;
            return newTask.p;
        };
        const _runTask = (taskDetail, startAction) => {
            taskDetail.st = utcNow();
            _running.push(taskDetail);
            _startBlockedTimer();
            return (onTaskResolve, onTaskReject) => {
                const _promiseReject = (reason) => {
                    taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                    taskDetail[REJECT] = _rejectDone;
                    _doCleanup(taskDetail);
                    onTaskResolve = null;
                    onTaskReject && onTaskReject(reason);
                    onTaskReject = null;
                };
                let taskId = taskDetail.id;
                if (taskDetail.rj) {
                    _promiseReject(taskDetail.rj);
                }
                else {
                    taskDetail[REJECT] = _promiseReject;
                    try {
                        let startResult = startAction(taskId);
                        if (taskDetail.to && isPromiseLike(startResult)) {
                            taskDetail.t = scheduleTimeout(() => {
                                _promiseReject(_createError("Timeout", taskDetail));
                            }, taskDetail.to);
                        }
                        doAwait(startResult, (theResult) => {
                            _doCleanup(taskDetail);
                            onTaskReject = null;
                            onTaskResolve && onTaskResolve(theResult);
                            onTaskResolve = null;
                        }, _promiseReject);
                    }
                    catch (e) {
                        _promiseReject(e);
                    }
                }
            };
        };
        const _waitForPreviousTask = (taskDetail, prevTask, startAction) => {
            _waiting.push(taskDetail);
            _startBlockedTimer();
            return newPromise((onWaitResolve, onWaitReject) => {
                taskDetail.id;
                prevTask.id;
                doAwaitResponse(prevTask.p, () => {
                    _removeTask(_waiting, taskDetail);
                    _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
                });
            });
        };
        const _doCleanup = (taskDetail) => {
            _removeTask(_running, taskDetail);
            taskDetail.t && taskDetail.t.cancel();
            taskDetail.t = null;
            if (_theTask && _theTask === taskDetail) {
                _theTask = null;
                if (getLength(_running) + getLength(_waiting) === 0) {
                    _blockedTimer && _blockedTimer.cancel();
                    _blockedTimer = null;
                }
            }
        };
        let theScheduler = {
            idle: true,
            queue: _queueTask,
            setStaleTimeout: (staleTimeout, staleCheckPeriod) => {
                _blockedTimer && _blockedTimer.cancel();
                _blockedTimer = null;
                _staleTimeoutPeriod = staleTimeout;
                _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
                _startBlockedTimer();
            }
        };
        objDefine(theScheduler, "idle", {
            g: () => {
                return getLength(_running) + getLength(_waiting) === 0;
            }
        });
        _addDebugState(theScheduler, () => _schedulerName, () => {
            return {
                l: _theTask,
                r: _running,
                w: _waiting
            };
        });
        return theScheduler;
    }

    exports.createAllPromise = createAllPromise;
    exports.createAsyncAllPromise = createAsyncAllPromise;
    exports.createAsyncPromise = createAsyncPromise;
    exports.createAsyncRejectedPromise = createAsyncRejectedPromise;
    exports.createAsyncResolvedPromise = createAsyncResolvedPromise;
    exports.createIdleAllPromise = createIdleAllPromise;
    exports.createIdlePromise = createIdlePromise;
    exports.createIdleRejectedPromise = createIdleRejectedPromise;
    exports.createIdleResolvedPromise = createIdleResolvedPromise;
    exports.createNativeAllPromise = createNativeAllPromise;
    exports.createNativePromise = createNativePromise;
    exports.createNativeRejectedPromise = createNativeRejectedPromise;
    exports.createNativeResolvedPromise = createNativeResolvedPromise;
    exports.createPromise = createPromise;
    exports.createRejectedPromise = createRejectedPromise;
    exports.createResolvedPromise = createResolvedPromise;
    exports.createSyncAllPromise = createSyncAllPromise;
    exports.createSyncPromise = createSyncPromise;
    exports.createSyncRejectedPromise = createSyncRejectedPromise;
    exports.createSyncResolvedPromise = createSyncResolvedPromise;
    exports.createTaskScheduler = createTaskScheduler;
    exports.doAwait = doAwait;
    exports.doAwaitResponse = doAwaitResponse;
    exports.doFinally = doFinally;
    exports.setCreatePromiseImpl = setCreatePromiseImpl;
    exports.setDetaultIdleTimeout = setDetaultIdleTimeout;
    exports.setPromiseDebugState = setPromiseDebugState;

}));
//# sourceMappingURL=ts-async.js.map
