/*!
 * NevWare21 - ts-async Polyfills, 0.2.6
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
(function () {
    'use strict';

    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var NUMBER = "number";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var UNDEFINED = "undefined";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var LENGTH = "length";
    var VALUE = "value";
    var SLICE = "slice";
    var ObjClass = Object;
    var ObjProto = ObjClass[PROTOTYPE];
    var StrCls = String;
    var ArrCls = Array;
    var ArrProto = ArrCls[PROTOTYPE];

    function safeGet(cb, defValue) {
        var result = defValue;
        try {
            result = cb();
        }
        catch (e) {
        }
        return result;
    }

    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    function objToString(value) {
        return ObjProto.toString.call(value);
    }
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    var isFunction = _createIs(FUNCTION);
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ArrCls.isArray;
    var isNumber = _createIs(NUMBER);
    var isError = _createObjIs("Error");
    function isPromiseLike(value) {
        return !!value && isFunction(value.then);
    }

    var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

    function objHasOwnProperty(obj, prop) {
        return obj && ObjProto.hasOwnProperty.call(obj, prop);
    }

    var objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }

    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }

    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }

    function throwTypeError(message) {
        throw new TypeError(message);
    }

    var _objFreeze = ObjClass["freeze"];
    var _doNothing = function (value) { return value; };
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = _objFreeze || _doNothing;

    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }

    var _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });

    var asString = StrCls;

    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = _getGlobalValue() || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }

    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        if (isError(object)) {
            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
        }
        else {
            try {
                propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
            }
            catch (e) {
                propertyValueDump = " - " + dumpObj(e, format);
            }
        }
        return objToString(object) + ": " + propertyValueDump;
    }

    function _unwrapFunction(funcName, target, polyFunc) {
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || (target && target[funcName]);
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrProto[SLICE].call(theArgs, 1) : theArgs);
            }
            throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
        };
    }

    var _wellKnownSymbolCache = {};
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    function polyGetKnownSymbol(name) {
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }

    var propMap = {
        e: "enumerable",
        c: "configurable",
        v: VALUE,
        w: "writable",
        g: "get",
        s: "set"
    };
    function _createProp(value) {
        var prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = function () { return value.l.v; };
            var desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = function (newValue) {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, function (key, value) {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    var objDefineProp = ObjClass["defineProperty"];
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }

    var _globalLazyTestHooks;
    var _fetchLazyTestHooks = function () {
        _globalLazyTestHooks = _getGlobalConfig();
        _fetchLazyTestHooks = NULL_VALUE;
    };
    function getLazy(cb) {
        var lazyValue = {};
        _fetchLazyTestHooks && _fetchLazyTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                var result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                    if (lazyValue.b) {
                        delete lazyValue.b;
                    }
                }
                if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                    lazyValue.b = _globalLazyTestHooks.lzy;
                }
                return result;
            }
        });
        return lazyValue;
    }

    function safeGetLazy(cb, defValue) {
        return getLazy(function () { return safeGet(cb, defValue); });
    }

    var WINDOW = "window";
    var _cachedGlobal;
    var _cachedWindow;
    var _cachedDocument;
    var _isNode;
    function lazySafeGetInst(name) {
        return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE);
    }
    function getGlobal(useCached) {
        (!_cachedGlobal || useCached === false || (_globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
        return _cachedGlobal.v;
    }
    function getInst(name, useCached) {
        var gbl = getGlobal(useCached);
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW && _cachedWindow) {
            return _cachedWindow.v;
        }
        return NULL_VALUE;
    }
    function getDocument() {
        (!_cachedDocument || (_globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
        return _cachedDocument.v;
    }
    function getWindow() {
        (!_cachedWindow || (_globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
        return _cachedWindow.v;
    }
    function isNode() {
        !_isNode && (_isNode = safeGetLazy(function () { return !!(process && (process.versions || {}).node); }, false));
        return _isNode.v;
    }

    var _symbol;
    var _symbolFor;
    var _symbolKeyFor;
    function _getSymbolValue(name) {
        return safeGetLazy(function () {
            return (_symbol.v ? _symbol[name] : UNDEF_VALUE);
        }, UNDEF_VALUE);
    }
    function hasSymbol() {
        return !!getSymbol();
    }
    function getSymbol() {
        var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
        resetCache && (_symbol = lazySafeGetInst(SYMBOL));
        (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
        (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
        return _symbol.v;
    }
    function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }

    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }

    var arrSlice = _unwrapFunction(SLICE, ArrProto);

    var REF = "ref";
    var UNREF = "un" + REF;
    var HAS_REF = "hasRef";
    var ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        var _a;
        var ref = true;
        var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        var theTimerHandler;
        var _unref = function () {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        };
        var _ref = function () {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        var _hasRef = function () {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        var _refresh = function () {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        };
        var _cancel = function () {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        };
        var _setEnabled = function (value) {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        };
        theTimerHandler = (_a = {
                cancel: _cancel,
                refresh: _refresh
            },
            _a[HAS_REF] = _hasRef,
            _a[REF] = _ref,
            _a[UNREF] = _unref,
            _a[ENABLED] = false,
            _a);
        objDefineProp(theTimerHandler, ENABLED, {
            get: function () { return !!timerId; },
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: function () {
                timerId = NULL_VALUE;
            }
        };
    }

    function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
        var isArr = isArray(overrideFn);
        var len = isArr ? overrideFn.length : 0;
        var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        var timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            timerFn.apply(self, arguments);
        };
        var handler = _createTimerHandler(startTimer, function (timerId) {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                clearFn.call(self, timerId);
            }
            return setFn.apply(self, theArgs);
        }, function (timerId) {
            clearFn.call(self, timerId);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
    }

    function doAwait(value, resolveFn, rejectFn, finallyFn) {
        var result = value;
        if (isPromiseLike(value)) {
            if (resolveFn || rejectFn) {
                result = value.then(resolveFn, rejectFn);
            }
        }
        else {
            resolveFn && resolveFn(value);
        }
        if (finallyFn) {
            result = doFinally(result, finallyFn);
        }
        return result;
    }
    function doFinally(value, finallyFn) {
        var result = value;
        if (finallyFn) {
            if (isPromiseLike(value)) {
                if (value.finally) {
                    result = value.finally(finallyFn);
                }
                else {
                    result = value.then(function (value) {
                        finallyFn();
                        return value;
                    }, function (reason) {
                        finallyFn();
                        throw reason;
                    });
                }
            }
            else {
                finallyFn();
            }
        }
        return result;
    }

    var STRING_STATES = [
        "pending", "resolving", "resolved", "rejected"
    ];

    var DISPATCH_EVENT = "dispatchEvent";
    var _hasInitEvent;
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
        var doc = getDocument();
        !_hasInitEvent && (_hasInitEvent = safeGetLazy(function () {
            var evt;
            if (doc && doc.createEvent) {
                evt = doc.createEvent("Event");
            }
            return (!!evt && evt.initEvent);
        }, null));
        var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
        populateEvent && populateEvent(theEvt);
        if (_hasInitEvent.v) {
            theEvt.initEvent(evtName, false, true);
        }
        if (theEvt && target[DISPATCH_EVENT]) {
            target[DISPATCH_EVENT](theEvt);
        }
        else {
            var handler = target["on" + evtName];
            if (handler) {
                handler(theEvt);
            }
            else {
                var theConsole = getInst("console");
                theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
            }
        }
    }

    var STR_PROMISE = "Promise";

    var NODE_UNHANDLED_REJECTION = "unhandledRejection";
    var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
    var _currentPromiseId = [];
    var _uniquePromiseId = 0;
    var _unhandledRejectionTimeout = 10;
    var _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
        if (isFunction(value)) {
            return value.toString();
        }
        return dumpObj(value);
    }
    function _createPromise(newPromise, processor, executor) {
        var additionalArgs = arrSlice(arguments, 3);
        var _state = 0 ;
        var _hasResolved = false;
        var _settledValue;
        var _queue = [];
        var _id = _uniquePromiseId++;
        var _handled = false;
        var _unHandledRejectionHandler = null;
        var _thePromise;
        !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
        var _then = function (onResolved, onRejected) {
            try {
                _currentPromiseId.push(_id);
                _handled = true;
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
                var thenPromise = newPromise(function (resolve, reject) {
                    _queue.push(function () {
                        try {
                            var handler = _state === 2  ? onResolved : onRejected;
                            var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                            if (isPromiseLike(value)) {
                                value.then(resolve, reject);
                            }
                            else if (handler) {
                                resolve(value);
                            }
                            else if (_state === 3 ) {
                                reject(value);
                            }
                            else {
                                resolve(value);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    if (_hasResolved) {
                        _processQueue();
                    }
                }, additionalArgs);
                return thenPromise;
            }
            finally {
                _currentPromiseId.pop();
            }
        };
        var _catch = function (onRejected) {
            return _then(undefined, onRejected);
        };
        var _finally = function (onFinally) {
            var thenFinally = onFinally;
            var catchFinally = onFinally;
            if (isFunction(onFinally)) {
                thenFinally = function (value) {
                    onFinally && onFinally();
                    return value;
                };
                catchFinally = function (reason) {
                    onFinally && onFinally();
                    throw reason;
                };
            }
            return _then(thenFinally, catchFinally);
        };
        var _strState = function () {
            return STRING_STATES[_state];
        };
        var _processQueue = function () {
            if (_queue.length > 0) {
                var pending = _queue.slice();
                _queue = [];
                _handled = true;
                processor(pending);
                _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
                _unHandledRejectionHandler = null;
            }
        };
        var _createSettleIfFn = function (newState, allowState) {
            return function (theValue) {
                if (_state === allowState) {
                    if (newState === 2  && isPromiseLike(theValue)) {
                        _state = 1 ;
                        theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                        return;
                    }
                    _state = newState;
                    _hasResolved = true;
                    _settledValue = theValue;
                    _processQueue();
                    if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                        _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                    }
                }
            };
        };
        var _notifyUnhandledRejection = function () {
            if (!_handled) {
                if (isNode()) {
                    process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
                }
                else {
                    var gbl = getWindow() || getGlobal();
                    emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                        objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                        theEvt.reason = _settledValue;
                        return theEvt;
                    }, !!_hasPromiseRejectionEvent.v);
                }
            }
        };
        _thePromise = {
            then: _then,
            "catch": _catch,
            finally: _finally
        };
        objDefineProp(_thePromise, "state", {
            get: _strState
        });
        if (hasSymbol()) {
            _thePromise[getKnownSymbol(11 )] = "IPromise";
        }
        var _toString = function () {
            return "IPromise" + ("") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
        };
        _thePromise.toString = _toString;
        (function _initialize() {
            if (!isFunction(executor)) {
                throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
            }
            var _rejectFn = _createSettleIfFn(3 , 0 );
            try {
                executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
            }
            catch (e) {
                _rejectFn(e);
            }
        })();
        return _thePromise;
    }
    function _createAllPromise(newPromise) {
        return function (input) {
            var additionalArgs = arrSlice(arguments, 1);
            return newPromise(function (resolve, reject) {
                try {
                    var values_1 = [];
                    var pending_1 = 1;
                    arrForEach(input, function (item, idx) {
                        if (item) {
                            pending_1++;
                            doAwait(item, function (value) {
                                values_1[idx] = value;
                                if (--pending_1 === 0) {
                                    resolve(values_1);
                                }
                            }, reject);
                        }
                    });
                    pending_1--;
                    if (pending_1 === 0) {
                        resolve(values_1);
                    }
                }
                catch (e) {
                    reject(e);
                }
            }, additionalArgs);
        };
    }
    function _createResolvedPromise(newPromise) {
        return function (value) {
            var additionalArgs = arrSlice(arguments, 1);
            if (isPromiseLike(value)) {
                return value;
            }
            return newPromise(function (resolve) {
                resolve(value);
            }, additionalArgs);
        };
    }
    function _createRejectedPromise(newPromise) {
        return function (reason) {
            var additionalArgs = arrSlice(arguments, 1);
            return newPromise(function (_resolve, reject) {
                reject(reason);
            }, additionalArgs);
        };
    }

    var _processPendingItems = function (pending) {
        arrForEach(pending, function (fn) {
            try {
                fn();
            }
            catch (e) {
            }
        });
    };
    function timeoutItemProcessor(timeout) {
        var callbackTimeout = isNumber(timeout) ? timeout : 0;
        return function (pending) {
            scheduleTimeout(function () {
                _processPendingItems(pending);
            }, callbackTimeout);
        };
    }

    function createAsyncPromise(executor, timeout) {
        return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    var createAsyncAllPromise = _createAllPromise(createAsyncPromise);
    var createAsyncResolvedPromise = _createResolvedPromise(createAsyncPromise);
    var createAsyncRejectedPromise = _createRejectedPromise(createAsyncPromise);

    var toStringTagSymbol = getKnownSymbol(11 );
    var PolyPromise = (function () {
        function PolyPromiseImpl(executor) {
            this._$ = createAsyncPromise(executor);
            if (toStringTagSymbol) {
                this[toStringTagSymbol] = "Promise";
            }
            objDefineProp(this, "state", {
                get: function () {
                    return this._$.state;
                }
            });
        }
        PolyPromiseImpl.all = createAsyncAllPromise;
        PolyPromiseImpl.reject = createAsyncRejectedPromise;
        PolyPromiseImpl.resolve = createAsyncResolvedPromise;
        var theProto = PolyPromiseImpl.prototype;
        theProto.then = function (onResolved, onRejected) {
            return this._$.then(onResolved, onRejected);
        };
        theProto.catch = function (onRejected) {
            return this._$.catch(onRejected);
        };
        theProto.finally = function (onfinally) {
            return this._$.finally(onfinally);
        };
        return PolyPromiseImpl;
    }());

    (function () {
        var promisePolyfills = {
            "all": createAsyncAllPromise,
            "resolved": createAsyncResolvedPromise,
            "rejected": createAsyncRejectedPromise
        };
        if (!Promise) {
            Promise = PolyPromise;
        }
        else {
            var PromiseClass_1 = Promise;
            if (PromiseClass_1) {
                objForEachKey(promisePolyfills, function (key, value) {
                    if (!PromiseClass_1[key]) {
                        PromiseClass_1[key] = value;
                    }
                });
            }
        }
    })();

})();
//# sourceMappingURL=ts-polyfills-async.js.map
