/*!
 * NevWare21 - ts-async, 0.2.6
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
'use strict';

var UNDEF_VALUE = undefined;
var NULL_VALUE = null;
var EMPTY = "";
var FUNCTION = "function";
var NUMBER = "number";
var OBJECT = "object";
var PROTOTYPE = "prototype";
var __PROTO__ = "__proto__";
var UNDEFINED = "undefined";
var CONSTRUCTOR = "constructor";
var SYMBOL = "Symbol";
var POLYFILL_TAG = "_polyfill";
var INDEX_OF = "indexOf";
var LENGTH = "length";
var VALUE = "value";
var NAME = "name";
var SLICE = "slice";
var ObjClass = Object;
var ObjProto = ObjClass[PROTOTYPE];
var StrCls = String;
var ArrCls = Array;
var ArrProto = ArrCls[PROTOTYPE];

function safeGet(cb, defValue) {
    var result = defValue;
    try {
        result = cb();
    }
    catch (e) {
    }
    return result;
}

function _createIs(theType) {
    return function (value) {
        return typeof value === theType;
    };
}
function _createObjIs(theName) {
    var theType = "[object " + theName + "]";
    return function (value) {
        return !!(value && objToString(value) === theType);
    };
}
function objToString(value) {
    return ObjProto.toString.call(value);
}
function isUndefined(value) {
    return typeof value === UNDEFINED || value === UNDEFINED;
}
function isNullOrUndefined(value) {
    return value === NULL_VALUE || isUndefined(value);
}
function isDefined(arg) {
    return !!arg || arg !== UNDEF_VALUE;
}
var isFunction = _createIs(FUNCTION);
function isObject(value) {
    if (!value && isNullOrUndefined(value)) {
        return false;
    }
    return !!value && typeof value === OBJECT;
}
var isArray = ArrCls.isArray;
var isNumber = _createIs(NUMBER);
var isError = _createObjIs("Error");
function isPromiseLike(value) {
    return !!value && isFunction(value.then);
}

var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

function objHasOwnProperty(obj, prop) {
    return obj && ObjProto.hasOwnProperty.call(obj, prop);
}

var objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
function polyObjHasOwn(obj, prop) {
    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
}

function objForEachKey(theObject, callbackfn, thisArg) {
    if (theObject && isObject(theObject)) {
        for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
                if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                    break;
                }
            }
        }
    }
}

function _createKeyValueMap(values, keyType, valueType, completeFn) {
    var theMap = {};
    objForEachKey(values, function (key, value) {
        theMap[key] = keyType ? value : key;
        theMap[value] = valueType ? value : key;
    });
    return completeFn(theMap);
}

function throwTypeError(message) {
    throw new TypeError(message);
}

var _objFreeze = ObjClass["freeze"];
var _doNothing = function (value) { return value; };
var _getProto = function (value) { return value[__PROTO__] || NULL_VALUE; };
function objDeepFreeze(value) {
    if (_objFreeze) {
        objForEachKey(value, function (key, value) {
            if (isArray(value) || isObject(value)) {
                _objFreeze(value);
            }
        });
    }
    return objFreeze(value);
}
var objFreeze = _objFreeze || _doNothing;
var objGetPrototypeOf = ObjClass["getPrototypeOf"] || _getProto;

function createEnumKeyMap(values) {
    return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
}

var _wellKnownSymbolMap = createEnumKeyMap({
    asyncIterator: 0 ,
    hasInstance: 1 ,
    isConcatSpreadable: 2 ,
    iterator: 3 ,
    match: 4 ,
    matchAll: 5 ,
    replace: 6 ,
    search: 7 ,
    species: 8 ,
    split: 9 ,
    toPrimitive: 10 ,
    toStringTag: 11 ,
    unscopables: 12
});

var asString = StrCls;

var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
var _globalCfg;
function _getGlobalValue() {
    var result;
    if (typeof globalThis !== UNDEFINED) {
        result = globalThis;
    }
    if (!result && typeof self !== UNDEFINED) {
        result = self;
    }
    if (!result && typeof window !== UNDEFINED) {
        result = window;
    }
    if (!result && typeof global !== UNDEFINED) {
        result = global;
    }
    return result;
}
function _getGlobalConfig() {
    if (!_globalCfg) {
        var gbl = _getGlobalValue() || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
    }
    return _globalCfg;
}

function dumpObj(object, format) {
    var propertyValueDump = EMPTY;
    if (isError(object)) {
        propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
    }
    else {
        try {
            propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
        }
        catch (e) {
            propertyValueDump = " - " + dumpObj(e, format);
        }
    }
    return objToString(object) + ": " + propertyValueDump;
}

function _unwrapFunction(funcName, target, polyFunc) {
    return function (thisArg) {
        var theFunc = (thisArg && thisArg[funcName]) || (target && target[funcName]);
        if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrProto[SLICE].call(theArgs, 1) : theArgs);
        }
        throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
    };
}
function _unwrapProp(propName) {
    return function (thisArg) {
        return thisArg[propName];
    };
}

var _wellKnownSymbolCache = {};
function polyNewSymbol(description) {
    var theSymbol = {
        description: asString(description),
        toString: function () { return SYMBOL + "(" + description + ")"; }
    };
    theSymbol[POLYFILL_TAG] = true;
    return theSymbol;
}
function polyGetKnownSymbol(name) {
    var result;
    var knownName = _wellKnownSymbolMap[name];
    if (knownName) {
        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
    }
    return result;
}

var propMap = {
    e: "enumerable",
    c: "configurable",
    v: VALUE,
    w: "writable",
    g: "get",
    s: "set"
};
function _createProp(value) {
    var prop = {};
    prop[propMap["c"]] = true;
    prop[propMap["e"]] = true;
    if (value.l) {
        prop.get = function () { return value.l.v; };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        if (desc && desc.set) {
            prop.set = function (newValue) {
                value.l.v = newValue;
            };
        }
    }
    objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
    });
    return prop;
}
var objDefineProp = ObjClass["defineProperty"];
function objDefine(target, key, propDesc) {
    return objDefineProp(target, key, _createProp(propDesc));
}

var _globalLazyTestHooks;
var _fetchLazyTestHooks = function () {
    _globalLazyTestHooks = _getGlobalConfig();
    _fetchLazyTestHooks = NULL_VALUE;
};
function getLazy(cb) {
    var lazyValue = {};
    _fetchLazyTestHooks && _fetchLazyTestHooks();
    lazyValue.b = _globalLazyTestHooks.lzy;
    objDefineProp(lazyValue, "v", {
        configurable: true,
        get: function () {
            var result = cb();
            if (!_globalLazyTestHooks.lzy) {
                objDefineProp(lazyValue, "v", {
                    value: result
                });
                if (lazyValue.b) {
                    delete lazyValue.b;
                }
            }
            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                lazyValue.b = _globalLazyTestHooks.lzy;
            }
            return result;
        }
    });
    return lazyValue;
}

function safeGetLazy(cb, defValue) {
    return getLazy(function () { return safeGet(cb, defValue); });
}

var WINDOW = "window";
var _cachedGlobal;
var _cachedWindow;
var _cachedDocument;
var _isNode;
function lazySafeGetInst(name) {
    return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE);
}
function getGlobal(useCached) {
    (!_cachedGlobal || useCached === false || (_globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
    return _cachedGlobal.v;
}
function getInst(name, useCached) {
    var gbl = getGlobal(useCached);
    if (gbl && gbl[name]) {
        return gbl[name];
    }
    if (name === WINDOW && _cachedWindow) {
        return _cachedWindow.v;
    }
    return NULL_VALUE;
}
function getDocument() {
    (!_cachedDocument || (_globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
    return _cachedDocument.v;
}
function getWindow() {
    (!_cachedWindow || (_globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
    return _cachedWindow.v;
}
function isNode() {
    !_isNode && (_isNode = safeGetLazy(function () { return !!(process && (process.versions || {}).node); }, false));
    return _isNode.v;
}

var _symbol;
var _symbolFor;
var _symbolKeyFor;
function _getSymbolValue(name) {
    return safeGetLazy(function () {
        return (_symbol.v ? _symbol[name] : UNDEF_VALUE);
    }, UNDEF_VALUE);
}
function hasSymbol() {
    return !!getSymbol();
}
function getSymbol() {
    var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
    resetCache && (_symbol = lazySafeGetInst(SYMBOL));
    (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
    (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
    return _symbol.v;
}
function getKnownSymbol(name, noPoly) {
    var knownName = _wellKnownSymbolMap[name];
    (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
    return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
}

function arrForEach(theArray, callbackfn, thisArg) {
    if (theArray) {
        var len = theArray[LENGTH] >>> 0;
        for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
                if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                    break;
                }
            }
        }
    }
}

var arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto);

var arrSlice = _unwrapFunction(SLICE, ArrProto);

var _objCreate = ObjClass["create"];
var objCreate = _objCreate || polyObjCreate;
function polyObjCreate(obj) {
    if (!obj) {
        return {};
    }
    var type = typeof obj;
    if (type !== OBJECT && type !== FUNCTION) {
        throw new TypeError("Prototype must be an Object or function: " + dumpObj(obj));
    }
    function tempFunc() { }
    tempFunc[PROTOTYPE] = obj;
    return new tempFunc();
}

var _isProtoArray;
function objSetPrototypeOf(obj, proto) {
    var fn = ObjClass["setPrototypeOf"] ||
        function (d, b) {
            !_isProtoArray && (_isProtoArray = getLazy(function () {
                var _a;
                return ((_a = {}, _a[__PROTO__] = [], _a) instanceof Array);
            }));
            _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
        };
    return fn(obj, proto);
}

var _createCustomError = function (name, d, b) {
    _safeDefineName(d, name);
    d = objSetPrototypeOf(d, b);
    function __() {
        this.constructor = d;
        _safeDefineName(this, name);
    }
    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
    return d;
};
var _safeSetName = function (baseClass, name) {
    try {
        name && (baseClass[NAME] = name);
    }
    catch (e) {
    }
};
var _safeDefineName = function (target, name) {
    try {
        objDefine(target, NAME, { v: name, c: true, e: false });
    }
    catch (e) {
    }
};
function createCustomError(name, constructCb, errorBase) {
    var theBaseClass = errorBase || Error;
    var orgName = theBaseClass[PROTOTYPE][NAME];
    var captureFn = Error.captureStackTrace;
    return _createCustomError(name, function () {
        var _this = this;
        try {
            _safeSetName(theBaseClass, name);
            var _self = theBaseClass.apply(_this, arguments) || _this;
            if (_self !== _this) {
                var orgProto = objGetPrototypeOf(_this);
                if (orgProto !== objGetPrototypeOf(_self)) {
                    objSetPrototypeOf(_self, orgProto);
                }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, arguments);
            return _self;
        }
        finally {
            _safeSetName(theBaseClass, orgName);
        }
    }, theBaseClass);
}

function utcNow() {
    return (Date.now || polyUtcNow)();
}
function polyUtcNow() {
    return new Date().getTime();
}

var getLength = _unwrapProp(LENGTH);

var _perf;
function getPerformance() {
    (!_perf || (_globalLazyTestHooks.lzy && !_perf.b)) && (_perf = lazySafeGetInst("performance"));
    return _perf.v;
}
function perfNow() {
    var perf = getPerformance();
    if (perf && perf.now) {
        return perf.now();
    }
    return utcNow();
}
function elapsedTime(startTime) {
    return perfNow() - startTime;
}

var REF = "ref";
var UNREF = "un" + REF;
var HAS_REF = "hasRef";
var ENABLED = "enabled";
function _createTimerHandler(startTimer, refreshFn, cancelFn) {
    var _a;
    var ref = true;
    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
    var theTimerHandler;
    var _unref = function () {
        ref = false;
        timerId && timerId[UNREF] && timerId[UNREF]();
        return theTimerHandler;
    };
    var _ref = function () {
        ref = true;
        timerId && timerId[REF] && timerId[REF]();
        return theTimerHandler;
    };
    var _hasRef = function () {
        if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
        }
        return ref;
    };
    var _refresh = function () {
        timerId = refreshFn(timerId);
        if (!ref) {
            _unref();
        }
        return theTimerHandler;
    };
    var _cancel = function () {
        timerId && cancelFn(timerId);
        timerId = NULL_VALUE;
    };
    var _setEnabled = function (value) {
        !value && timerId && _cancel();
        value && !timerId && _refresh();
    };
    theTimerHandler = (_a = {
            cancel: _cancel,
            refresh: _refresh
        },
        _a[HAS_REF] = _hasRef,
        _a[REF] = _ref,
        _a[UNREF] = _unref,
        _a[ENABLED] = false,
        _a);
    objDefineProp(theTimerHandler, ENABLED, {
        get: function () { return !!timerId; },
        set: _setEnabled
    });
    return {
        h: theTimerHandler,
        dn: function () {
            timerId = NULL_VALUE;
        }
    };
}

function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
    var isArr = isArray(overrideFn);
    var len = isArr ? overrideFn.length : 0;
    var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
    var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
    var timerFn = theArgs[0];
    theArgs[0] = function () {
        handler.dn();
        timerFn.apply(self, arguments);
    };
    var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
            if (timerId.refresh) {
                timerId.refresh();
                return timerId;
            }
            clearFn.call(self, timerId);
        }
        return setFn.apply(self, theArgs);
    }, function (timerId) {
        clearFn.call(self, timerId);
    });
    return handler.h;
}
function scheduleTimeout(callback, timeout) {
    return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
}

var _hasIdleCallback;
var _defaultIdleTimeout$1 = 100;
var _maxExecutionTime = 50;
function hasIdleCallback() {
    !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(function () { return isDefined(requestIdleCallback); }, false));
    return !!(_hasIdleCallback.v ? requestIdleCallback : false);
}
function scheduleIdleCallback(callback, options) {
    function _createDeadline(timedOut) {
        var startTime = perfNow();
        return {
            didTimeout: timedOut,
            timeRemaining: function () {
                return _maxExecutionTime - elapsedTime(startTime);
            }
        };
    }
    if (hasIdleCallback()) {
        var handler_1 = _createTimerHandler(true, function (idleId) {
            idleId && cancelIdleCallback(idleId);
            return requestIdleCallback(function (deadline) {
                handler_1.dn();
                callback(deadline || _createDeadline(false));
            }, options);
        }, function (idleId) {
            cancelIdleCallback(idleId);
        });
        return handler_1.h;
    }
    var timeout = (options || {}).timeout;
    if (isUndefined(timeout)) {
        timeout = _defaultIdleTimeout$1;
    }
    return scheduleTimeout(function () {
        callback(_createDeadline(true));
    }, timeout);
}

function doAwaitResponse(value, cb) {
    return doAwait(value, function (value) {
        cb && cb({
            value: value,
            rejected: false
        });
    }, function (reason) {
        cb && cb({
            rejected: true,
            reason: reason
        });
    });
}
function doAwait(value, resolveFn, rejectFn, finallyFn) {
    var result = value;
    if (isPromiseLike(value)) {
        if (resolveFn || rejectFn) {
            result = value.then(resolveFn, rejectFn);
        }
    }
    else {
        resolveFn && resolveFn(value);
    }
    if (finallyFn) {
        result = doFinally(result, finallyFn);
    }
    return result;
}
function doFinally(value, finallyFn) {
    var result = value;
    if (finallyFn) {
        if (isPromiseLike(value)) {
            if (value.finally) {
                result = value.finally(finallyFn);
            }
            else {
                result = value.then(function (value) {
                    finallyFn();
                    return value;
                }, function (reason) {
                    finallyFn();
                    throw reason;
                });
            }
        }
        else {
            finallyFn();
        }
    }
    return result;
}

var _debugState;
var _debugResult;
var _debugHandled;
var _promiseDebugEnabled = false;
function _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {
    _debugState = _debugState || { toString: function () { return "[[PromiseState]]"; } };
    _debugResult = _debugResult || { toString: function () { return "[[PromiseResult]]"; } };
    _debugHandled = _debugHandled || { toString: function () { return "[[PromiseIsHandled]]"; } };
    objDefineProp(thePromise, _debugState, { get: stateFn });
    objDefineProp(thePromise, _debugResult, { get: resultFn });
    objDefineProp(thePromise, _debugHandled, { get: handledFn });
}
function setPromiseDebugState(enabled, logger) {
    _promiseDebugEnabled = enabled;
}

var STRING_STATES = [
    "pending", "resolving", "resolved", "rejected"
];

var DISPATCH_EVENT = "dispatchEvent";
var _hasInitEvent;
function emitEvent(target, evtName, populateEvent, useNewEvent) {
    var doc = getDocument();
    !_hasInitEvent && (_hasInitEvent = safeGetLazy(function () {
        var evt;
        if (doc && doc.createEvent) {
            evt = doc.createEvent("Event");
        }
        return (!!evt && evt.initEvent);
    }, null));
    var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
    populateEvent && populateEvent(theEvt);
    if (_hasInitEvent.v) {
        theEvt.initEvent(evtName, false, true);
    }
    if (theEvt && target[DISPATCH_EVENT]) {
        target[DISPATCH_EVENT](theEvt);
    }
    else {
        var handler = target["on" + evtName];
        if (handler) {
            handler(theEvt);
        }
        else {
            var theConsole = getInst("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, dumpObj(theEvt));
        }
    }
}

var STR_PROMISE = "Promise";

var NODE_UNHANDLED_REJECTION = "unhandledRejection";
var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
var _currentPromiseId = [];
var _uniquePromiseId = 0;
var _unhandledRejectionTimeout = 10;
var _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if (isFunction(value)) {
        return value.toString();
    }
    return dumpObj(value);
}
function _createPromise(newPromise, processor, executor) {
    var additionalArgs = arrSlice(arguments, 3);
    var _state = 0 ;
    var _hasResolved = false;
    var _settledValue;
    var _queue = [];
    var _id = _uniquePromiseId++;
    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    var _handled = false;
    var _unHandledRejectionHandler = null;
    var _thePromise;
    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
    var _then = function (onResolved, onRejected) {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function (resolve, reject) {
                _queue.push(function () {
                    try {
                        var handler = _state === 2  ? onResolved : onRejected;
                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                        if (isPromiseLike(value)) {
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            resolve(value);
                        }
                        else if (_state === 3 ) {
                            reject(value);
                        }
                        else {
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    };
    var _catch = function (onRejected) {
        return _then(undefined, onRejected);
    };
    var _finally = function (onFinally) {
        var thenFinally = onFinally;
        var catchFinally = onFinally;
        if (isFunction(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    };
    var _strState = function () {
        return STRING_STATES[_state];
    };
    var _processQueue = function () {
        if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            processor(pending);
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
        }
    };
    var _createSettleIfFn = function (newState, allowState) {
        return function (theValue) {
            if (_state === allowState) {
                if (newState === 2  && isPromiseLike(theValue)) {
                    _state = 1 ;
                    theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                _processQueue();
                if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
        };
    };
    var _notifyUnhandledRejection = function () {
        if (!_handled) {
            if (isNode()) {
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                var gbl = getWindow() || getGlobal();
                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                    objDefine(theEvt, "promise", { g: function () { return _thePromise; } });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    };
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    objDefineProp(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        _addDebugState$1(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });
    }
    if (hasSymbol()) {
        _thePromise[getKnownSymbol(11 )] = "IPromise";
    }
    var _toString = function () {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
    };
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        var _rejectFn = _createSettleIfFn(3 , 0 );
        try {
            executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    return _thePromise;
}
function _createAllPromise(newPromise) {
    return function (input) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (resolve, reject) {
            try {
                var values_1 = [];
                var pending_1 = 1;
                arrForEach(input, function (item, idx) {
                    if (item) {
                        pending_1++;
                        doAwait(item, function (value) {
                            values_1[idx] = value;
                            if (--pending_1 === 0) {
                                resolve(values_1);
                            }
                        }, reject);
                    }
                });
                pending_1--;
                if (pending_1 === 0) {
                    resolve(values_1);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
function _createResolvedPromise(newPromise) {
    return function (value) {
        var additionalArgs = arrSlice(arguments, 1);
        if (isPromiseLike(value)) {
            return value;
        }
        return newPromise(function (resolve) {
            resolve(value);
        }, additionalArgs);
    };
}
function _createRejectedPromise(newPromise) {
    return function (reason) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (_resolve, reject) {
            reject(reason);
        }, additionalArgs);
    };
}

var _processPendingItems = function (pending) {
    arrForEach(pending, function (fn) {
        try {
            fn();
        }
        catch (e) {
        }
    });
};
function syncItemProcessor() {
    return _processPendingItems;
}
function timeoutItemProcessor(timeout) {
    var callbackTimeout = isNumber(timeout) ? timeout : 0;
    return function (pending) {
        scheduleTimeout(function () {
            _processPendingItems(pending);
        }, callbackTimeout);
    };
}
function idleItemProcessor(timeout) {
    var options;
    if (timeout >= 0) {
        options = {
            timeout: +timeout
        };
    }
    return function (pending) {
        scheduleIdleCallback(function (deadline) {
            _processPendingItems(pending);
        }, options);
    };
}

function createAsyncPromise(executor, timeout) {
    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
}
var createAsyncAllPromise = _createAllPromise(createAsyncPromise);
var createAsyncResolvedPromise = _createResolvedPromise(createAsyncPromise);
var createAsyncRejectedPromise = _createRejectedPromise(createAsyncPromise);

var _isPromiseSupported;
function createNativePromise(executor, timeout) {
    !_isPromiseSupported && (_isPromiseSupported = lazySafeGetInst(STR_PROMISE));
    var PrmCls = _isPromiseSupported.v;
    if (!PrmCls) {
        return createAsyncPromise(executor);
    }
    if (!isFunction(executor)) {
        throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
    }
    var _state = 0 ;
    function _strState() {
        return STRING_STATES[_state];
    }
    var thePromise = new PrmCls(function (resolve, reject) {
        function _resolve(value) {
            _state = 2 ;
            resolve(value);
        }
        function _reject(reason) {
            _state = 3 ;
            reject(reason);
        }
        executor(_resolve, _reject);
    });
    objDefineProp(thePromise, "state", {
        get: _strState
    });
    return thePromise;
}
var createNativeAllPromise = _createAllPromise(createNativePromise);
var createNativeResolvedPromise = _createResolvedPromise(createNativePromise);
var createNativeRejectedPromise = _createRejectedPromise(createNativePromise);

function createSyncPromise(executor) {
    return _createPromise(createSyncPromise, syncItemProcessor(), executor);
}
var createSyncAllPromise = _createAllPromise(createSyncPromise);
var createSyncResolvedPromise = _createResolvedPromise(createSyncPromise);
var createSyncRejectedPromise = _createRejectedPromise(createSyncPromise);

var _defaultIdleTimeout;
function setDetaultIdleTimeout(idleDeadline) {
    _defaultIdleTimeout = idleDeadline;
}
function createIdlePromise(executor, timeout) {
    var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;
    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);
}
var createIdleAllPromise = _createAllPromise(createIdlePromise);
var createIdleResolvedPromise = _createResolvedPromise(createIdlePromise);
var createIdleRejectedPromise = _createRejectedPromise(createIdlePromise);

var _promiseCreator;
function setCreatePromiseImpl(creator) {
    _promiseCreator = creator ? getLazy(function () { return creator; }) : null;
}
function createPromise(executor, timeout) {
    !_promiseCreator && (_promiseCreator = getLazy(function () { return createNativePromise; }));
    return _promiseCreator.v.call(this, executor, timeout);
}
var createAllPromise = _createAllPromise(createPromise);
var createResolvedPromise = _createResolvedPromise(createPromise);
var createRejectedPromise = _createRejectedPromise(createPromise);

var REJECT = "reject";
var REJECTED_ERROR = "Rejected";
var _schedulerId = 0;
var _debugName;
var _debugIntState;
var _customErrors = {};
var _rejectDone = function () {
};
var _createError = function (type, evt, message) {
    !_customErrors[type] && (_customErrors[type] = createCustomError(type));
    var now = utcNow();
    return new (_customErrors[type])("Task [".concat(evt.id, "] ").concat(message || "", "- ").concat((evt.st ? "Running" : "Waiting"), ": ").concat(_calcTime(now, evt.st || evt.cr)));
};
function _calcTime(now, start) {
    return ((now - start) || "0") + " ms";
}
function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
    var now = utcNow();
    var expired = now - staleTimeoutPeriod;
    arrForEach(taskQueue, function (evt) {
        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
            evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
        }
    });
}
function _removeTask(queue, taskDetail) {
    var idx = arrIndexOf(queue, taskDetail);
    if (idx !== -1) {
        queue.splice(idx, 1);
    }
}
function _addDebugState(theScheduler, nameFn, stateFn) {
    _debugName = _debugName || { toString: function () { return "[[SchedulerName]]"; } };
    _debugIntState = _debugIntState || { toString: function () { return "[[SchedulerState]]"; } };
    objDefineProp(theScheduler, _debugName, { get: nameFn });
    objDefineProp(theScheduler, _debugIntState, { get: stateFn });
}
function createTaskScheduler(newPromise, name) {
    var _theTask;
    var _running = [];
    var _waiting = [];
    var _staleTimeoutPeriod = 600000;
    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
    var _taskCount = 0;
    var _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
    var _blockedTimer;
    newPromise = newPromise || createPromise;
    var _startBlockedTimer = function () {
        var hasTasks = (getLength(_running) + getLength(_waiting)) > 0;
        if (_staleTimeoutPeriod > 0) {
            if (!_blockedTimer) {
                _blockedTimer = scheduleTimeout(function () {
                    _abortStaleTasks(_running, _staleTimeoutPeriod);
                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));
                }, _staleTimeoutCheckPeriod);
                _blockedTimer.unref();
            }
            _blockedTimer && (_blockedTimer.enabled = hasTasks);
        }
    };
    var _queueTask = function (startAction, taskName, timeout) {
        var _a;
        var taskId = _schedulerName + "." + _taskCount++;
        if (taskName) {
            taskId += "-(" + taskName + ")";
        }
        var newTask = (_a = {
                id: taskId,
                cr: utcNow(),
                to: timeout
            },
            _a[REJECT] = function (reason) {
                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                newTask[REJECT] = _rejectDone;
            },
            _a);
        if (!_theTask) {
            newTask.p = newPromise(_runTask(newTask, startAction));
        }
        else {
            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
        }
        _theTask = newTask;
        return newTask.p;
    };
    var _runTask = function (taskDetail, startAction) {
        taskDetail.st = utcNow();
        _running.push(taskDetail);
        _startBlockedTimer();
        return function (onTaskResolve, onTaskReject) {
            var _promiseReject = function (reason) {
                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                taskDetail[REJECT] = _rejectDone;
                _doCleanup(taskDetail);
                onTaskResolve = null;
                onTaskReject && onTaskReject(reason);
                onTaskReject = null;
            };
            var taskId = taskDetail.id;
            if (taskDetail.rj) {
                _promiseReject(taskDetail.rj);
            }
            else {
                taskDetail[REJECT] = _promiseReject;
                try {
                    var startResult = startAction(taskId);
                    if (taskDetail.to && isPromiseLike(startResult)) {
                        taskDetail.t = scheduleTimeout(function () {
                            _promiseReject(_createError("Timeout", taskDetail));
                        }, taskDetail.to);
                    }
                    doAwait(startResult, function (theResult) {
                        _doCleanup(taskDetail);
                        onTaskReject = null;
                        onTaskResolve && onTaskResolve(theResult);
                        onTaskResolve = null;
                    }, _promiseReject);
                }
                catch (e) {
                    _promiseReject(e);
                }
            }
        };
    };
    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {
        _waiting.push(taskDetail);
        _startBlockedTimer();
        return newPromise(function (onWaitResolve, onWaitReject) {
            taskDetail.id;
            prevTask.id;
            doAwaitResponse(prevTask.p, function () {
                _removeTask(_waiting, taskDetail);
                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
            });
        });
    };
    var _doCleanup = function (taskDetail) {
        _removeTask(_running, taskDetail);
        taskDetail.t && taskDetail.t.cancel();
        taskDetail.t = null;
        if (_theTask && _theTask === taskDetail) {
            _theTask = null;
            if (getLength(_running) + getLength(_waiting) === 0) {
                _blockedTimer && _blockedTimer.cancel();
                _blockedTimer = null;
            }
        }
    };
    var theScheduler = {
        idle: true,
        queue: _queueTask,
        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {
            _blockedTimer && _blockedTimer.cancel();
            _blockedTimer = null;
            _staleTimeoutPeriod = staleTimeout;
            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
            _startBlockedTimer();
        }
    };
    objDefine(theScheduler, "idle", {
        g: function () {
            return getLength(_running) + getLength(_waiting) === 0;
        }
    });
    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {
        return {
            l: _theTask,
            r: _running,
            w: _waiting
        };
    });
    return theScheduler;
}

exports.createAllPromise = createAllPromise;
exports.createAsyncAllPromise = createAsyncAllPromise;
exports.createAsyncPromise = createAsyncPromise;
exports.createAsyncRejectedPromise = createAsyncRejectedPromise;
exports.createAsyncResolvedPromise = createAsyncResolvedPromise;
exports.createIdleAllPromise = createIdleAllPromise;
exports.createIdlePromise = createIdlePromise;
exports.createIdleRejectedPromise = createIdleRejectedPromise;
exports.createIdleResolvedPromise = createIdleResolvedPromise;
exports.createNativeAllPromise = createNativeAllPromise;
exports.createNativePromise = createNativePromise;
exports.createNativeRejectedPromise = createNativeRejectedPromise;
exports.createNativeResolvedPromise = createNativeResolvedPromise;
exports.createPromise = createPromise;
exports.createRejectedPromise = createRejectedPromise;
exports.createResolvedPromise = createResolvedPromise;
exports.createSyncAllPromise = createSyncAllPromise;
exports.createSyncPromise = createSyncPromise;
exports.createSyncRejectedPromise = createSyncRejectedPromise;
exports.createSyncResolvedPromise = createSyncResolvedPromise;
exports.createTaskScheduler = createTaskScheduler;
exports.doAwait = doAwait;
exports.doAwaitResponse = doAwaitResponse;
exports.doFinally = doFinally;
exports.setCreatePromiseImpl = setCreatePromiseImpl;
exports.setDetaultIdleTimeout = setDetaultIdleTimeout;
exports.setPromiseDebugState = setPromiseDebugState;
//# sourceMappingURL=ts-async.js.map
