import { arrForEach, arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, lazySafeGetInst } from "@nevware21/ts-utils";
import { doAwait } from "./await";
import { _addDebugState, _promiseDebugEnabled } from "./debug";
import { STRING_STATES } from "../internal/state";
import { emitEvent } from "./event";
import { STR_PROMISE } from "../internal/constants";
const NODE_UNHANDLED_REJECTION = "unhandledRejection";
const UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
let _currentPromiseId = [];
let _uniquePromiseId = 0;
let _unhandledRejectionTimeout = 10;
let _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if (isFunction(value)) {
        return value.toString();
    }
    return dumpObj(value);
}
export function _createPromise(newPromise, processor, executor) {
    let additionalArgs = arrSlice(arguments, 3);
    let _state = 0;
    let _hasResolved = false;
    let _settledValue;
    let _queue = [];
    let _id = _uniquePromiseId++;
    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    let _handled = false;
    let _unHandledRejectionHandler = null;
    let _thePromise;
    !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
    const _then = (onResolved, onRejected) => {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            let thenPromise = newPromise(function (resolve, reject) {
                _queue.push(function () {
                    try {
                        let handler = _state === 2 ? onResolved : onRejected;
                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);
                        if (isPromiseLike(value)) {
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            resolve(value);
                        }
                        else if (_state === 3) {
                            reject(value);
                        }
                        else {
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    };
    const _catch = (onRejected) => {
        return _then(undefined, onRejected);
    };
    const _finally = (onFinally) => {
        let thenFinally = onFinally;
        let catchFinally = onFinally;
        if (isFunction(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    };
    const _strState = () => {
        return STRING_STATES[_state];
    };
    const _processQueue = () => {
        if (_queue.length > 0) {
            let pending = _queue.slice();
            _queue = [];
            _handled = true;
            processor(pending);
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
        }
        else {
        }
    };
    const _createSettleIfFn = (newState, allowState) => {
        return (theValue) => {
            if (_state === allowState) {
                if (newState === 2 && isPromiseLike(theValue)) {
                    _state = 1;
                    theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                _processQueue();
                if (!_handled && newState === 3 && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
            else {
            }
        };
    };
    const _notifyUnhandledRejection = () => {
        if (!_handled) {
            if (isNode()) {
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                let gbl = getWindow() || getGlobal();
                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt) => {
                    objDefine(theEvt, "promise", { g: () => _thePromise });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    };
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    objDefineProp(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);
    }
    if (hasSymbol()) {
        _thePromise[getKnownSymbol(11)] = "IPromise";
    }
    const _toString = () => {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!isUndefined(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "");
    };
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!isFunction(executor)) {
            throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        const _rejectFn = _createSettleIfFn(3, 0);
        try {
            executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    return _thePromise;
}
export function _createAllPromise(newPromise) {
    return function (input) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((resolve, reject) => {
            try {
                let values = [];
                let pending = 1;
                arrForEach(input, (item, idx) => {
                    if (item) {
                        pending++;
                        doAwait(item, (value) => {
                            values[idx] = value;
                            if (--pending === 0) {
                                resolve(values);
                            }
                        }, reject);
                    }
                });
                pending--;
                if (pending === 0) {
                    resolve(values);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
export function _createResolvedPromise(newPromise) {
    return function (value) {
        let additionalArgs = arrSlice(arguments, 1);
        if (isPromiseLike(value)) {
            return value;
        }
        return newPromise((resolve) => {
            resolve(value);
        }, additionalArgs);
    };
}
export function _createRejectedPromise(newPromise) {
    return function (reason) {
        let additionalArgs = arrSlice(arguments, 1);
        return newPromise((_resolve, reject) => {
            reject(reason);
        }, additionalArgs);
    };
}
//# sourceMappingURL=base.js.map