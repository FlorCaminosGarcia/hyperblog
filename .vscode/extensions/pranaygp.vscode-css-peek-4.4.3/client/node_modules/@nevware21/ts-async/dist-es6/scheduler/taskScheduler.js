import { arrForEach, arrIndexOf, createCustomError, getLength, isPromiseLike, objDefine, objDefineProp, scheduleTimeout, utcNow } from "@nevware21/ts-utils";
import { doAwait, doAwaitResponse } from "../promise/await";
import { createPromise } from "../promise/promise";
const REJECT = "reject";
const REJECTED_ERROR = "Rejected";
let _schedulerId = 0;
let _debugName;
let _debugIntState;
let _customErrors = {};
const _rejectDone = () => {
};
var _createError = (type, evt, message) => {
    !_customErrors[type] && (_customErrors[type] = createCustomError(type));
    let now = utcNow();
    return new (_customErrors[type])(`Task [${evt.id}] ${message || ""}- ${(evt.st ? "Running" : "Waiting")}: ${_calcTime(now, evt.st || evt.cr)}`);
};
function _calcTime(now, start) {
    return ((now - start) || "0") + " ms";
}
function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
    let now = utcNow();
    let expired = now - staleTimeoutPeriod;
    arrForEach(taskQueue, (evt) => {
        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
            evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
        }
    });
}
function _removeTask(queue, taskDetail) {
    let idx = arrIndexOf(queue, taskDetail);
    if (idx !== -1) {
        queue.splice(idx, 1);
    }
}
function _addDebugState(theScheduler, nameFn, stateFn) {
    _debugName = _debugName || { toString: () => "[[SchedulerName]]" };
    _debugIntState = _debugIntState || { toString: () => "[[SchedulerState]]" };
    objDefineProp(theScheduler, _debugName, { get: nameFn });
    objDefineProp(theScheduler, _debugIntState, { get: stateFn });
}
export function createTaskScheduler(newPromise, name) {
    let _theTask;
    let _running = [];
    let _waiting = [];
    let _staleTimeoutPeriod = 600000;
    let _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
    let _taskCount = 0;
    let _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
    let _blockedTimer;
    newPromise = newPromise || createPromise;
    const _startBlockedTimer = () => {
        let hasTasks = (getLength(_running) + getLength(_waiting)) > 0;
        if (_staleTimeoutPeriod > 0) {
            if (!_blockedTimer) {
                _blockedTimer = scheduleTimeout(() => {
                    _abortStaleTasks(_running, _staleTimeoutPeriod);
                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));
                }, _staleTimeoutCheckPeriod);
                _blockedTimer.unref();
            }
            _blockedTimer && (_blockedTimer.enabled = hasTasks);
        }
        else {
        }
    };
    const _queueTask = (startAction, taskName, timeout) => {
        let taskId = _schedulerName + "." + _taskCount++;
        if (taskName) {
            taskId += "-(" + taskName + ")";
        }
        let newTask = {
            id: taskId,
            cr: utcNow(),
            to: timeout,
            [REJECT]: (reason) => {
                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                newTask[REJECT] = _rejectDone;
            }
        };
        if (!_theTask) {
            newTask.p = newPromise(_runTask(newTask, startAction));
        }
        else {
            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
        }
        _theTask = newTask;
        return newTask.p;
    };
    const _runTask = (taskDetail, startAction) => {
        taskDetail.st = utcNow();
        _running.push(taskDetail);
        _startBlockedTimer();
        return (onTaskResolve, onTaskReject) => {
            const _promiseReject = (reason) => {
                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                taskDetail[REJECT] = _rejectDone;
                _doCleanup(taskDetail);
                onTaskResolve = null;
                onTaskReject && onTaskReject(reason);
                onTaskReject = null;
            };
            let taskId = taskDetail.id;
            if (taskDetail.rj) {
                _promiseReject(taskDetail.rj);
            }
            else {
                taskDetail[REJECT] = _promiseReject;
                try {
                    let startResult = startAction(taskId);
                    if (taskDetail.to && isPromiseLike(startResult)) {
                        taskDetail.t = scheduleTimeout(() => {
                            _promiseReject(_createError("Timeout", taskDetail));
                        }, taskDetail.to);
                    }
                    doAwait(startResult, (theResult) => {
                        _doCleanup(taskDetail);
                        onTaskReject = null;
                        onTaskResolve && onTaskResolve(theResult);
                        onTaskResolve = null;
                    }, _promiseReject);
                }
                catch (e) {
                    _promiseReject(e);
                }
            }
        };
    };
    const _waitForPreviousTask = (taskDetail, prevTask, startAction) => {
        _waiting.push(taskDetail);
        _startBlockedTimer();
        return newPromise((onWaitResolve, onWaitReject) => {
            let taskId = taskDetail.id;
            let prevTaskId = prevTask.id;
            doAwaitResponse(prevTask.p, () => {
                _removeTask(_waiting, taskDetail);
                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
            });
        });
    };
    const _doCleanup = (taskDetail) => {
        _removeTask(_running, taskDetail);
        taskDetail.t && taskDetail.t.cancel();
        taskDetail.t = null;
        if (_theTask && _theTask === taskDetail) {
            _theTask = null;
            if (getLength(_running) + getLength(_waiting) === 0) {
                _blockedTimer && _blockedTimer.cancel();
                _blockedTimer = null;
            }
        }
    };
    let theScheduler = {
        idle: true,
        queue: _queueTask,
        setStaleTimeout: (staleTimeout, staleCheckPeriod) => {
            _blockedTimer && _blockedTimer.cancel();
            _blockedTimer = null;
            _staleTimeoutPeriod = staleTimeout;
            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
            _startBlockedTimer();
        }
    };
    objDefine(theScheduler, "idle", {
        g: () => {
            return getLength(_running) + getLength(_waiting) === 0;
        }
    });
    _addDebugState(theScheduler, () => _schedulerName, () => {
        return {
            l: _theTask,
            r: _running,
            w: _waiting
        };
    });
    return theScheduler;
}
//# sourceMappingURL=taskScheduler.js.map