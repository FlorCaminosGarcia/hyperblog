exports.id=928,exports.ids=[928],exports.modules={3917:(e,t,i)=>{i.d(t,{v:()=>SubscriptionManager});let SubscriptionManager=class SubscriptionManager{constructor(e,t){this.source=e,this.subscribe=t}_status="stopped";get status(){return this._status}_subscription;dispose(){this.stop()}start(){(null==this._subscription||"started"!==this._status)&&(this._subscription=this.subscribe(this.source),this._status="started")}pause(){this.stop("paused")}resume(){this.start()}stop(e){this._subscription?.dispose(),this._subscription=void 0,this._status=e??"stopped"}}},9505:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var s=i(1398),r=i(53),o=i(2625),n=i(746),a=i(4109),h=i(5859),l=i(4230),c=i(7551),p=i(6123),g=i(6234),d=i(8847),u=i(689),m=i(6695),v=i(3182),w=i(9487),b=i(1558),f=i(9395),y=i(5658),C=i(7685),R=i(5619),P=i(2331),S=i(3177),_=i(3790),B=i(5730),k=i(4039),I=i(7276),D=i(5211),O=i(3761),A=i(7614),W=i(6402),$=i(1094);async function H(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=W.H.get("launchpad.indicator.groups")??[];return(0,$.a)(t.items,i)}var T=i(41),L=i(4641),E=i(9827),F=i(2948),M=i(2809),q=i(6434),x=i(1335),U=i(3991),z=i(7820),N=i(3917),G=i(8261),Z=i(994);let V="home",Q=new Z.Oz(V,"launchpad/summary"),j=new Z.Oz(V,"overview/active"),Y=new Z.Oz(V,"overview/inactive"),X=new Z.Oz(V,"overviewFilter"),J=new Z.Q2(V,"overview/repository/change"),K=new Z.C1(V,"overview/repository/didChange"),ee=new Z.Q2(V,"previewEnabled/toggle"),et=new Z.Q2(V,"section/collapse"),ei=new Z.Q2(V,"walkthrough/dismiss"),es=new Z.C1(V,"ai/allAccess/didChange"),er=new Z.C1(V,"mcp/didChange"),eo=new Z.Q2(V,"ai/allAccess/dismiss"),en=new Z.Q2(V,"overview/filter/set"),ea=new Z.Q2(V,"openInGraph"),eh=new Z.C1(V,"repositories/didCompleteDiscovering"),el=new Z.C1(V,"previewEnabled/didChange"),ec=new Z.C1(V,"repository/wip/didChange"),ep=new Z.C1(V,"repositories/didChange"),eg=new Z.C1(V,"walkthroughProgress/didChange"),ed=new Z.C1(V,"integrations/didChange"),eu=new Z.C1(V,"launchpad/didChange"),em=new Z.C1(V,"subscription/didChange"),ev=new Z.C1(V,"org/settings/didChange"),ew=new Z.C1(V,"home/ownerFilter/didChange"),eb=new Z.C1(V,"account/didFocus");var ef=Object.defineProperty,ey=Object.getOwnPropertyDescriptor,eC=(e,t,i,s)=>{for(var r,o=s>1?void 0:s?ey(t,i):t,n=e.length-1;n>=0;n--)(r=e[n])&&(o=(s?r(t,i,o):r(o))||o);return s&&o&&ef(t,i,o),o};let eR=Object.freeze({dispose:()=>{}}),eP={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=s.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),s.workspace.isTrusted?eR:s.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,E.wt)(this.onContextChanged,this),this.container.integrations.onDidChange(this.onIntegrationsChanged,this),this.container.integrations.onDidChangeConnectionState(this.onIntegrationConnectionStateChanged,this),this.container.walkthrough.onDidChangeProgress(this.onWalkthroughProgressChanged,this),W.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onLaunchpadChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this),this.container.storage.onDidChange(this.onStorageChanged,this))}_disposable;_discovering;_etag;_etagFileSystem;_etagRepository;_etagSubscription;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1,limit:9}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[s]=i;if(s?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(eb,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onAIModelChanged(e){this.notifyDidChangeIntegrations()}onStorageChanged(e){!e.workspace&&e.keys.includes("mcp:banner:dismissed")&&this.onMcpBannerChanged()}onIntegrationsChanged(e){this.notifyDidChangeIntegrations()}onIntegrationConnectionStateChanged(e){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),{title:t,placeholder:i}=await (0,T.Nt)(this.container.git.openRepositories,"Switch",e?.name),s=await (0,T.oe)(this.container,t,i,this.container.git.openRepositories,{picked:e});if(null!=s&&s!==e)return this.selectRepository(s.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughProgressChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){W.H.changed(e,["home.preview.enabled","ai.enabled","ai.experimental.composer.enabled"])&&this.notifyDidChangeConfig()}onLaunchpadChanged(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async publishBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null!=i)return g.VC(t,void 0,(0,f.iw)(i))}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,L.Lb)(`${this.host.id}.pull`,this.pull,this),(0,L.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,L.Lb)(`${this.host.id}.publishBranch`,this.publishBranch,this),(0,L.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,L.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,L.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,L.Lb)(`${this.host.id}.previewFeedback`,()=>(0,F.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,L.Lb)(`${this.host.id}.whatsNew`,()=>(0,F.CZ)(n.DS.releaseNotes),this),(0,L.Lb)(`${this.host.id}.help`,()=>(0,F.CZ)(n.DS.helpCenter),this),(0,L.Lb)(`${this.host.id}.issues`,()=>(0,F.CZ)(n.DS.githubIssues),this),(0,L.Lb)(`${this.host.id}.info`,()=>(0,F.CZ)(n.DS.helpCenterHome),this),(0,L.Lb)(`${this.host.id}.discussions`,()=>(0,F.CZ)(n.DS.githubDiscussions),this),(0,L.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,L.Lb)(`${this.host.id}.ai.allAccess.dismiss`,()=>{this.dismissAiAllAccessBanner()},this),(0,L.Lb)("gitlens.home.changeBranchMergeTarget",this.changeBranchMergeTarget,this),(0,L.Lb)("gitlens.home.deleteBranchOrWorktree",this.deleteBranchOrWorktree,this),(0,L.Lb)("gitlens.home.pushBranch",this.pushBranch,this),(0,L.Lb)("gitlens.home.openMergeTargetComparison",this.mergeTargetCompare,this),(0,L.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,L.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,L.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,L.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,L.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,L.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,L.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,L.Lb)("gitlens.home.fetch",this.fetch,this),(0,L.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,L.Lb)("gitlens.visualizeHistory.repo:home",this.openInTimeline,this),(0,L.Lb)("gitlens.visualizeHistory.branch:home",this.openInTimeline,this),(0,L.Lb)("gitlens.openInView.branch:home",this.openInView,this),(0,L.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,L.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,L.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,L.Lb)("gitlens.home.startWork",this.startWork,this),(0,L.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this),(0,L.Lb)("gitlens.home.skipPausedOperation",this.skipPausedOperation,this),(0,L.Lb)("gitlens.home.continuePausedOperation",this.continuePausedOperation,this),(0,L.Lb)("gitlens.home.abortPausedOperation",this.abortPausedOperation,this),(0,L.Lb)("gitlens.home.openRebaseEditor",this.openRebaseEditor,this),(0,L.Lb)("gitlens.home.enableAi",this.enableAi,this),(0,L.Lb)("gitlens.ai.explainWip:home",this.explainWip,this),(0,L.Lb)("gitlens.ai.explainBranch:home",this.explainBranch,this),(0,L.Lb)("gitlens.composeCommits:home",e=>this.composeCommits(e),this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(ew,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case et.is(e):this.onCollapseSection(e.params);break;case ei.is(e):this.dismissWalkthrough();break;case eo.is(e):this.dismissAiAllAccessBanner();break;case en.is(e):this.setOverviewFilter(e.params);break;case Q.is(e):this.host.respond(Q,e,await H(this.container));break;case X.is(e):this.host.respond(X,e,this._overviewBranchFilter);break;case J.is(e):if(await this.onChooseRepository()==null)return;this.host.notify(K,void 0);break;case ee.is(e):this.onTogglePreviewEnabled();break;case ea.is(e):this.openInGraph(e.params);break;case j.is(e):this.host.respond(j,e,await this.getActiveBranchOverview());break;case Y.is(e):this.host.respond(Y,e,await this.getInactiveBranchOverview())}}includeBootstrap(e){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(eb,void 0))}hasRepositoryChanged(){if(this._repositorySubscription?.source!=null){if(this._repositorySubscription.source.etag!==this._etagRepository||this._repositorySubscription.source.etagFileSystem!==this._etagFileSystem)return!0}else if(this._etag!==this.container.git.etag)return!0;return!1}onVisibilityChanged(e){e?(this._repositorySubscription?.resume(),null==this._discovering&&(this.container.subscription.etag!==this._etagSubscription||this.hasRepositoryChanged())&&this.notifyDidChangeRepositories(!0)):this._repositorySubscription?.pause()}openInGraph(e){let t=null!=e?this._repositoryBranches.get(e.repoPath):void 0;if(null==t)return void(0,L.RS)("gitlens.showGraph",this.getSelectedRepository());if("branch"===e.type){let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return void(0,L.RS)("gitlens.showInCommitGraph",{ref:(0,f.iw)(i)})}(0,L.RS)("gitlens.showGraph",t.repo)}openInTimeline(e){let t=null==e?this.getSelectedRepository():this.container.git.getRepository(e.repoPath);if(null!=t){if(e?.type==="repo")return void(0,L.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri});if(e?.type==="branch"){let i=this._repositoryBranches.get(t.path),s=i?.branches.find(t=>t.id===e.branchId);null!=s&&(0,L.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri,head:(0,f.iw)(s)})}}}async openInView(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null==t||null==i)return;let s=await i.getWorktree();null==s||s.isDefault?await (0,l.sT)(i,{select:!0,focus:!0,expand:!0}):await (0,d.dw)(s,{select:!0,focus:!0,expand:!0})}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,L.RS)("gitlens.gitCommands",{command:"branch",state:{subcommand:"create",repo:this.getSelectedRepository(),suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}changeBranchMergeTarget(e){this.container.telemetry.sendEvent("home/changeBranchMergeTarget"),(0,L.RS)("gitlens.changeBranchMergeTarget",{command:"changeBranchMergeTarget",state:{repo:e.repoPath,branch:e.branchName,mergeBranch:e.mergeTargetName}})}async mergeIntoCurrent(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&g.h1(t,(0,f.iw)(i))}async rebaseCurrentOnto(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&g.RU(t,(0,f.iw)(i))}async explainBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=t&&(0,L.RS)("gitlens.ai.explainBranch",{repoPath:t.path,ref:i?.ref,source:{source:"home",context:{type:"branch"}}})}async explainWip(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null==t)return;let s=await i?.getWorktree();(0,L.RS)("gitlens.ai.explainWip",{repoPath:t.path,worktreePath:s?.path,source:{source:"home",context:{type:"wip"}}})}async composeCommits(e){let{repo:t}=await this.getRepoInfoFromRef(e);null!=t&&(0,L.RS)("gitlens.composeCommits",{repoPath:t.path,source:"home"})}enableAi(){this.container.telemetry.sendEvent("home/enableAi"),W.H.updateEffective("ai.enabled",!0)}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,L.RS)("gitlens.startWork",{command:"startWork",source:"home"})}async abortPausedOperation(e){await (0,p._e)(this.container.git.getRepositoryService(e.repoPath))}async continuePausedOperation(e){"revert"!==e.type&&await (0,p.Ts)(this.container.git.getRepositoryService(e.repoPath))}async skipPausedOperation(e){await (0,p.RG)(this.container.git.getRepositoryService(e.repoPath))}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.getRepositoryService(e.repoPath).config.getGitDir?.();if(null==t)return;let i=s.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,L.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async createCloudPatch(e){let{repo:t}=await this.getRepoInfoFromRef(e);if(null==t)return;let i=await t.git.status.getStatus();if(null==i)return void s.window.showErrorMessage("Unable to create cloud patch");let r=[];for(let e of i.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};r.push(t),e.staged&&e.wip&&r.push({...t,staged:!1})}let o={type:"wip",repository:{name:t.name,path:t.path,uri:t.uri.toString()},files:r,revision:{to:v.SU,from:"HEAD"}};(0,B.X)({mode:"create",create:{changes:[o]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),W.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return this.container.storage.get("home:walkthrough:dismissed")??!1}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getAiEnabled(){return W.H.get("ai.enabled")}getExperimentalComposerEnabled(){return W.H.get("ai.experimental.composer.enabled",void 0,!1)}getAmaBannerCollapsed(){return Date.now()>=new Date("2025-02-13T13:00:00-05:00").getTime()||(this.container.storage.get("home:sections:collapsed")?.includes("feb2025AmaBanner")??!1)}getMcpBannerCollapsed(){return!(0,k.W$)(this.container,!0)}getMcpCanAutoRegister(){return(0,k.nA)()}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}async getAiAllAccessBannerCollapsed(){if(!(0,I.X)())return!0;let e=await this.getAiAllAccessUserId();return this.container.storage.get(`gk:promo:${e}:ai:allAccess:dismissed`,!1)}async getAiAllAccessUserId(){let e=await this.container.subscription.getSubscription();return e.account?.id??"00000000"}async dismissAiAllAccessBanner(){this.container.telemetry.sendEvent("aiAllAccess/bannerDismissed",void 0,{source:"home"});let e=await this.getAiAllAccessUserId();this.container.storage.store(`gk:promo:${e}:ai:allAccess:dismissed`,!0).catch(),await this.onAiAllAccessBannerChanged()}getOrgSettings(){return{drafts:(0,E.SD)("gitlens:gk:organization:drafts:enabled",!1),ai:(0,E.SD)("gitlens:gk:organization:ai:enabled",!0)}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(await this.notifyDidChangeSubscription(e.current),(0,D.aE)(e.current.state)!==(0,D.aE)(e.previous.state)&&this.onOverviewRepoChanged(),await this.onAiAllAccessBannerChanged())}async getState(e){let[t,i,s,r]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"}),this.getAiAllAccessBannerCollapsed()]);if("rejected"===t.status)throw t.reason;let o=(0,z.Ro)(i)??[],n=o.some(e=>e.connected),a={model:(0,z.Ro)(s)};return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),aiEnabled:this.getAiEnabled(),experimentalComposerEnabled:this.getExperimentalComposerEnabled(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),aiAllAccessBannerCollapsed:(0,z.Ro)(r,!1),integrations:o,ai:a,hasAnyIntegrationConnected:n,walkthroughSupported:this.container.walkthrough.isWalkthroughSupported,walkthroughProgress:this.getWalkthroughProgress(),previewEnabled:this.getPreviewEnabled(),newInstall:(0,E.SD)("gitlens:install:new",!1),amaBannerCollapsed:this.getAmaBannerCollapsed(),mcpBannerCollapsed:this.getMcpBannerCollapsed(),mcpCanAutoRegister:this.getMcpCanAutoRegister()}}getPreviewEnabled(){return W.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:s.workspace.isTrusted}}async getActiveBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i="wip"===this._invalidateOverview,[s,r,o]=await Promise.allSettled([this.getBranchesData(e,t),this.isSubscriptionPro(),this.formatRepository(e)]),{branches:n,worktreesByBranch:a}=(0,z.Ro)(s),h=n.find(e=>"active"===this.getBranchOverviewType(e,a)),l=(0,z.Ro)(r),[c]=eS(this.container,[h],a,l,{isActive:!0,forceStatus:!!t||!!i||void 0});return i&&(this._invalidateOverview=void 0),this._etagFileSystem=e.etagFileSystem,{repository:(0,z.Ro)(o),active:c}}async getInactiveBranchOverview(){let e;null!=this._discovering&&await this._discovering;let t=this.getSelectedRepository();if(null==t)return;let i="repo"===this._invalidateOverview,[s,r,o]=await Promise.allSettled([this.getBranchesData(t,i),this.isSubscriptionPro(),this.formatRepository(t)]),{branches:n,worktreesByBranch:a}=(0,z.Ro)(s),h=n.filter(e=>"recent"===this.getBranchOverviewType(e,a)),l=(0,z.Ro)(r);if(this._overviewBranchFilter.stale.show)for(let t of((0,C.Xn)(n,{missingUpstream:!0,orderBy:"date:asc"}),n)){if(null!=e&&e.length>this._overviewBranchFilter.stale.limit)break;h.some(e=>e.id===t.id)||"stale"===this.getBranchOverviewType(t,a)&&(e??=[]).push(t)}let c=eS(this.container,h,a,l),p=null==e?void 0:eS(this.container,e,a,l);return i||(this._invalidateOverview=void 0),{repository:(0,z.Ro)(o),recent:c,stale:p}}async formatRepository(e){let t=await e.git.remotes.getBestRemotesWithProviders(),i=t.find(e=>e.supportsIntegration())??t[0];return(0,y.GS)(e,i)}_repositorySubscription;selectRepository(e){let t;return t=null!=e?this.container.git.getRepository(e):this.container.git.getBestRepositoryOrFirst(),this._repositorySubscription?.dispose(),this._repositorySubscription=void 0,null!=t&&(this._repositorySubscription=new N.v(t,e=>this.subscribeToRepository(e)),this.host.visible&&this._repositorySubscription.start()),t}resetBranchOverview(){(this._repositoryBranches.clear(),this.host.visible)?this._repositorySubscription?.resume():this._repositorySubscription?.pause()}subscribeToRepository(e){return s.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(t=>this.onOverviewWipChanged(t,e)),e.onDidChange(t=>{t.changed(m.Z_.Config,m.Z_.Head,m.Z_.Heads,m.Z_.Remotes,m.Z_.PausedOperationStatus,m.Z_.Unknown,m.Ti.Any)&&this.onOverviewRepoChanged(e)}))}onOverviewWipChanged(e,t){e.repository.id!==t.id||this._etagFileSystem===t.etagFileSystem||("repo"!==this._invalidateOverview&&(this._invalidateOverview="wip"),this.host.visible&&this.host.notify(ec,void 0))}onOverviewRepoChanged(e){if(null!=e){if(this._etagRepository===e.etag)return}else if(this._etag===this.container.git.etag)return;this._invalidateOverview="repo",this.host.visible&&this.notifyDidChangeRepositories()}async onAiAllAccessBannerChanged(){this.host.visible&&this.host.notify(es,await this.getAiAllAccessBannerCollapsed())}onMcpBannerChanged(){this.host.visible&&this.host.notify(er,{mcpBannerCollapsed:this.getMcpBannerCollapsed(),mcpCanAutoRegister:this.getMcpCanAutoRegister()})}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.source}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)||e.etag!==this._etagRepository){let t=await e.git.worktrees?.getWorktrees()??[],i=(0,R.PU)(t,{includeDefault:!0}),[s]=await Promise.allSettled([e.git.branches.getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,R.vJ)(i)}})]),r=(0,z.Ro)(s)?.values??[];this._etagRepository=e.etag,this._repositoryBranches.set(e.path,{repo:e,branches:r,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,U.x1)(await this.container.integrations.getConfigured(),e=>{if(!(0,a.LT)(e.integrationId))return;let t=a.U4.find(t=>t.id===e.integrationId);return{id:e.integrationId,name:O.Mt[e.integrationId].name,icon:`gl-provider-${O.Mt[e.integrationId].iconKey}`,connected:!0,supports:t?.supports!=null?t.supports:"git"===O.Mt[e.integrationId].type?["prs","issues"]:"issues"===O.Mt[e.integrationId].type?["issues"]:[],requiresPro:t?.requiresPro??!1}}),t=await Promise.allSettled(e),i=[...(0,U.x1)(t,e=>(0,z.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,D.aE)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),this._etagSubscription=this.container.subscription.etag,t=e.account?.email?(0,o.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(eh,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(ep,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e)return void this.notifyDidChangeRepositoriesCore();null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,x.s)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}getWalkthroughProgress(){if(this.getWalkthroughDismissed())return;let e=Object.fromEntries(this.container.walkthrough.getState());return{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress,state:e}}notifyDidChangeProgress(){let e=this.getWalkthroughProgress();null!=e&&this.host.notify(eg,e)}notifyDidChangeConfig(){this.host.notify(el,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed(),aiEnabled:this.getAiEnabled(),experimentalComposerEnabled:this.getExperimentalComposerEnabled()})}notifyDidChangeLaunchpad(){this.host.notify(eu,void 0)}async notifyDidChangeIntegrations(){let[e,t]=await Promise.allSettled([this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]),i=(0,z.Ro)(e)??[],s=i.some(e=>e.connected),r={model:(0,z.Ro)(t)};s&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(ed,{hasAnyIntegrationConnected:s,integrations:i,ai:r})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(em,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(ev,{orgSettings:this.getOrgSettings()})}async deleteBranchOrWorktree(e,t){let{repo:i,branch:r}=await this.getRepoInfoFromRef(e);if(null==r)return;let o=!1===r.worktree?void 0:r.worktree??await r.getWorktree();if(r.current&&null!=t&&(!o||o.isDefault)){let i=(0,P.km)(t.branchName),o=await s.window.showWarningMessage(`Before deleting the current branch '${r.name}', you will be switched to '${i}'.`,{modal:!0},{title:"Continue"});if(o?.title!=="Continue")return;await this.container.git.getRepositoryService(e.repoPath).ops?.checkout(i),(0,h.b)({command:"branch",state:{subcommand:"delete",repo:e.repoPath,references:r}})}else if(null!=i&&null!=o&&!o.isDefault){let e=await i.getCommonRepository(),t=await i.git.worktrees?.getWorktree(e=>e.isDefault);if(null==t||null==e)return;let o=await s.window.showWarningMessage(`Before deleting the worktree for '${r.name}', you will be switched to the default worktree.`,{modal:!0},{title:"Continue"});if(o?.title!=="Continue")return;let n=W.H.get("deepLinks.schemeOverride"),a="string"==typeof n?n:s.env.uriScheme,l={url:`${a}://${this.container.context.extension.id}/link/${G.vk.Repository}/-/${G.vk.Branch}/${encodeURIComponent(r.name)}?path=${encodeURIComponent(e.path)}&action=delete-branch`,repoPath:e.path,useProgress:!1,state:G.rq.GoToTarget};(0,h.b)({command:"worktree",state:{subcommand:"open",repo:t.repoPath,worktree:t,onWorkspaceChanging:async e=>{await this.container.storage.storeSecret("deepLinks:pending",JSON.stringify(l)),setTimeout(()=>{(0,L.S4)("workbench.action.closeWindow")},2e3)},worktreeDefaultOpen:"current"}})}}pushBranch(e){this.container.git.getRepositoryService(e.repoPath).ops?.push({reference:{name:e.branchName,ref:e.branchId,refType:"branch",remote:!1,repoPath:e.repoPath,upstream:e.branchUpstreamName?{name:e.branchUpstreamName,missing:!1}:void 0}})}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchName,e.mergeTargetName)}async pullRequestCompare(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void s.window.showErrorMessage("Unable to find pull request to compare");let i=(0,S.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void s.window.showErrorMessage("Unable to find pull request to open changes");let i=(0,S.tI)(e.repoPath,t.refs);return(0,c.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.getPullRequestFromRef(e);null==i?s.window.showErrorMessage("Unable to find pull request to open on remote"):(0,L.RS)("gitlens.openPullRequestOnRemote",{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.getPullRequestFromRef(e);null==t?s.window.showErrorMessage("Unable to find pull request to open details"):this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate({ref:e,describeWithAI:t,source:i}){let{branch:s}=await this.getRepoInfoFromRef(e);if(null==s)return;let o=await s.getRemote(),n=t?this.container.actionRunners.get("createPullRequest")?.find(e=>e.type===r.do.BuiltIn)?.id:void 0;(0,L.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=o?{name:o.name,provider:null!=o.provider?{id:o.provider.id,name:o.provider.name,domain:o.provider.domain}:void 0,url:o.url}:void 0,branch:{name:s.name,upstream:s.upstream?.name,isRemote:s.remote},describeWithAI:t,source:i},n)}async worktreeOpen(e){let{location:t,...i}=e,{branch:s}=await this.getRepoInfoFromRef(i),r=await s?.getWorktree();null!=r&&(0,M.OH)(r.uri,t?{location:t}:void 0)}async switchToBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);g.S_(t,i?(0,f.iw)(i):void 0)}async fetch(e){if(null==e){let e=this.getSelectedRepository();g.hd(e);return}let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&g.hd(t,(0,f.iw)(i))}getBranchOverviewType(e,t){if(e.current||t.get(e.id)?.opened)return"active";let i=e.date?.getTime();if(null!=i){let e=Date.now();if(i>e-eP[this._overviewBranchFilter.recent.threshold])return"recent";if(i<e-eP[this._overviewBranchFilter.stale.threshold])return"stale"}if(e.upstream?.missing)return"stale"}async getPullRequestFromRef(e){let{branch:t}=await this.getRepoInfoFromRef(e);return t?.getAssociatedPullRequest()}async getRepoInfoFromRef(e){let t=this.container.git.getRepository(e.repoPath);if(null==t)return{repo:void 0,branch:void 0};if(!e.branchName)return{repo:t,branch:void 0};let i=await t.git.branches.getBranch(e.branchName);return{repo:t,branch:i}}};function eS(e,t,i,s,r){let o,n;if(0===t.length)return[];let a=r?.isActive??!1,h=r?.forceStatus?{force:!0}:void 0,l=new Map,c=new Map,p=new Map,g=new Map,d=new Map,m=new Map,v=new Map,b=[];for(let r of t){r.upstream?.missing===!1&&l.set(r.id,r.getRemote());let t=i.get(r.id),u=r.date?.getTime();!0===s&&(c.set(r.id,eD(e,r,o)),p.set(r.id,r.getEnrichedAutolinks()),g.set(r.id,(0,w.GI)(e,r).then(e=>e.value)),m.set(r.id,e.git.getRepositoryService(r.repoPath).branches.getBranchContributionsOverview(r.ref)),r.current&&v.set(r.id,ek(e,r))),null!=t?d.set(r.id,t.getStatus(h)):!0===a&&(void 0===n&&(n=e.git.getRepositoryService(r.repoPath).status.getStatus()),d.set(r.id,n)),b.push({reference:(0,f.iw)(r),repoPath:r.repoPath,id:r.id,name:r.name,opened:a,timestamp:u,status:r.status,upstream:r.upstream,worktree:t?{name:t.name,uri:t.uri.toString(),isDefault:t.isDefault}:void 0})}return b.length>0&&function(e,t,i,s,r,o,n,a,h,l){for(let c of t){c.remote=s.get(c.id)?.then(async e=>{if(null!=e)return{name:e.name,provider:e.provider?{name:e.provider.name,icon:"remote"===e.provider.icon?"cloud":e.provider.icon,url:await e.provider.url({type:u.J.Repo}),supportedFeatures:e.provider.supportedFeatures}:void 0}}),c.pr=r.get(c.id);let t=o.get(c.id);c.autolinks=t?.then(e=>e_(e));let p=n.get(c.id);c.issues=p?.then(e=>e?.map(e=>({id:e.number||e.id,title:e.title,state:e.state,url:e.url}))??[]),c.wip=eO(e,c,a.get(c.id),i);let g=h.get(c.id);c.contributors=eB(e,g),c.mergeTarget=l.get(c.id)}}(e,b,a,l,c,p,g,d,m,v),b}async function e_(e){return null==e?[]:(await Promise.allSettled((0,U.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eB(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.contributionCount,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function ek(e,t){let i,s=await (0,b.Y7)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!s.mergeTargetBranch.paused&&s.mergeTargetBranch.value&&(i=s.mergeTargetBranch.value);let r=i??s.baseBranch??s.defaultBranch;if(null==r)return;let o=e.git.getRepositoryService(t.repoPath),n=await o.branches.getBranch(r);if(null==n)return;let[a,h,l]=await Promise.allSettled([o.commits.getLeftRightCommitCount((0,_.Xn)(n.name,t.ref,"..."),{excludeMerges:!0}),o.branches.getPotentialMergeOrRebaseConflict?.(t.name,n.name),o.branches.getBranchMergedStatus?.(t,n)]),c=(0,z.Ro)(a),p=null!=c?{ahead:c.right,behind:c.left}:void 0,g=(0,z.Ro)(l);return{repoPath:t.repoPath,id:n.id,name:n.name,status:p,mergedStatus:g,potentialConflicts:(0,z.Ro)(h),targetBranch:n.name,baseBranch:s.baseBranch,defaultBranch:s.defaultBranch}}async function eI(e,t,i){i??=e.launchpad.getCategorizedItems();let s=await i;if(null!=s.error)return;let r=s.items.find(e=>e.url===t.url);if(null==r){if(null!=(s=await e.launchpad.getCategorizedItems({search:[t]})).error)return;r=s.items.find(e=>e.url===t.url)}if(null!=r)return{uuid:r.uuid,category:r.actionableCategory,groups:(0,A._v)(r),suggestedActions:r.suggestedActions,failingCI:r.failingCI,hasConflicts:r.hasConflicts,review:{decision:r.reviewDecision,reviews:r.reviews??[],counts:{approval:r.approvalReviewCount,changeRequest:r.changeRequestReviewCount,comment:r.commentReviewCount,codeSuggest:r.codeSuggestionsCount}},author:r.author,createdDate:r.createdDate,viewer:{...r.viewer,enrichedItems:void 0}}}async function eD(e,t,i){let s=await t.getAssociatedPullRequest({avatarSize:64});if(null!=s)return{id:s.id,url:s.url,state:s.state,title:s.title,draft:s.isDraft,launchpad:eI(e,s,i)}}async function eO(e,t,i,s){if(null==i)return;let[r,o]=await Promise.allSettled([i,s?e.git.getRepositoryService(t.repoPath).pausedOps?.getPausedOperationStatus?.():void 0]),n=(0,z.Ro)(r),a=(0,z.Ro)(o);return{workingTreeState:n?.getDiffStatus(),hasConflicts:n?.hasConflicts,conflictsCount:n?.conflicts.length,pausedOpStatus:a}}eC([(0,q.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInGraph",1),eC([(0,q.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInTimeline",1),eC([(0,q.Rm)({args:{0:e=>`repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInView",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"createBranch",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"changeBranchMergeTarget",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"mergeIntoCurrent",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"rebaseCurrentOnto",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainBranch",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainWip",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"composeCommits",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"enableAi",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"startWork",1),eC([(0,q.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"abortPausedOperation",1),eC([(0,q.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"continuePausedOperation",1),eC([(0,q.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"skipPausedOperation",1),eC([(0,q.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"openRebaseEditor",1),eC([(0,q.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"createCloudPatch",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"dismissWalkthrough",1),eC([(0,q.Rm)()],HomeWebviewProvider.prototype,"dismissAiAllAccessBanner",1),eC([(0,q.Yz)({args:!1})],HomeWebviewProvider.prototype,"onSubscriptionChanged",1),eC([(0,q.Yz)({args:{0:!1}})],HomeWebviewProvider.prototype,"onOverviewWipChanged",1),eC([(0,q.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`,1:e=>e?.branchId}})],HomeWebviewProvider.prototype,"deleteBranchOrWorktree",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pushBranch",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}, mergeTargetId: ${e.mergeTargetId}`}})],HomeWebviewProvider.prototype,"mergeTargetCompare",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCompare",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestChanges",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestViewOnRemote",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestDetails",1),eC([(0,q.Rm)({args:{0:e=>`${e.ref.branchId}, upstream: ${e.ref.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCreate",1),eC([(0,q.Rm)({args:{0:e=>`${e.branchId}, worktree: ${e.worktree?.name}`}})],HomeWebviewProvider.prototype,"worktreeOpen",1),eC([(0,q.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"switchToBranch",1),eC([(0,q.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"fetch",1)}};