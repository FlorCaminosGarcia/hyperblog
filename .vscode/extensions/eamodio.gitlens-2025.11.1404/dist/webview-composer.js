exports.id=407,exports.ids=[407],exports.modules={3678:(e,t,o)=>{o.d(t,{ComposerWebviewProvider:()=>ComposerWebviewProvider});var i=o(1398),n=o(6202),s=o(6695),a=o(3182),r=o(1558),c=o(5773),d=o(41),m=o(6402),h=o(9827),l=o(7820),u=o(4684),g=o(994);let p="1.0.0",f={hunks:[],commits:[],baseCommit:null,selectedCommitId:null,selectedCommitIds:new Set,selectedUnassignedSection:null,selectedHunkIds:new Set,detailsSectionExpanded:{commitMessage:!0,aiExplanation:!0,filesChanged:!0},generatingCommits:!1,generatingCommitMessage:null,committing:!1,safetyError:null,loadingError:null,aiOperationError:null,hasUsedAutoCompose:!1,hasChanges:!0,workingDirectoryHasChanged:!1,indexHasChanged:!1,mode:"preview",recompose:null,aiEnabled:{org:!1,config:!1},ai:{model:void 0},onboardingDismissed:!1},C={sessionStart:"",sessionDuration:void 0,diff:{files:0,hunks:0,lines:0,staged:!1,unstaged:!1,commits:!1,unstagedIncluded:!1},commits:{initialCount:0,autoComposedCount:void 0,composedCount:void 0,finalCount:void 0},ai:{enabled:{org:!1,config:!1},model:void 0},onboarding:{dismissed:!1,stepReached:void 0},operations:{generateCommits:{count:0,cancelledCount:0,errorCount:0,feedback:{upvoteCount:0,downvoteCount:0}},generateCommitMessage:{count:0,cancelledCount:0,errorCount:0},finishAndCommit:{errorCount:0},undo:{count:0},redo:{count:0},reset:{count:0}},source:void 0,mode:"preview",errors:{safety:{count:0},operation:{count:0}},warnings:{workingDirectoryChanged:!1,indexChanged:!1}},x="composer",y=new g.Q2(x,"generateCommits"),_=new g.Q2(x,"generateCommitMessage"),w=new g.Q2(x,"finishAndCommit"),b=new g.Q2(x,"close"),v=new g.Q2(x,"reload"),k=new g.Q2(x,"cancelGenerateCommits"),S=new g.Q2(x,"cancelGenerateCommitMessage");new g.Q2(x,"cancelFinishAndCommit");let I=new g.Q2(x,"clearAIOperationError"),E=new g.Q2(x,"selectAIModel"),R=new g.Q2(x,"aiFeedbackHelpful"),A=new g.Q2(x,"aiFeedbackUnhelpful"),M=new g.Q2(x,"openOnboarding"),T=new g.Q2(x,"dismissOnboarding"),D=new g.Q2(x,"advanceOnboarding"),F=new g.Q2("composer","chooseRepository"),H=new g.Q2(x,"onAddHunksToCommit"),$=new g.Q2(x,"onUndo"),O=new g.Q2(x,"onRedo"),N=new g.Q2(x,"onReset"),P=new g.C1(x,"didStartGenerating"),B=new g.C1(x,"didStartGeneratingCommitMessage"),Q=new g.C1(x,"didGenerateCommits"),U=new g.C1(x,"didGenerateCommitMessage"),G=new g.C1(x,"didStartCommitting"),z=new g.C1(x,"didFinishCommitting"),W=new g.C1(x,"didSafetyError"),V=new g.C1(x,"didReloadComposer"),q=new g.C1(x,"didLoadingError"),j=new g.C1(x,"didWorkingDirectoryChange"),L=new g.C1(x,"didIndexChange"),Y=new g.C1(x,"didCancelGenerateCommits"),Z=new g.C1(x,"didCancelGenerateCommitMessage"),J=new g.C1(x,"didErrorAIOperation"),K=new g.C1(x,"didClearAIOperationError"),X=new g.C1(x,"didChangeAiEnabled"),ee=new g.C1(x,"didChangeAiModel");var et=o(8887);function eo(e,t){return t.filter(t=>e.hunkIndices.includes(t.index))}function ei(e){if(0===e.length)return{patch:"",filePatches:new Map};let t=new Map;for(let o of e){let e=o.diffHeader||`diff --git a/${o.fileName} b/${o.fileName}`,i=t.get(e);if(null==i&&(i=[],t.set(e,i)),o.isRename)i.push("");else{let e=`${o.hunkHeader}
${o.content}`;i.push(e)}}let o="";for(let[e,i]of t.entries()){o+=`${e.trim()}
`;let t=i.filter(e=>""!==e.trim());t.length>0&&(o+=`${t.join(`
`)}
`)}return{patch:o,filePatches:t}}function en(e,t){return Math.max(0,Math.min(e.start+e.count,t.start+t.count)-Math.max(e.start,t.start))}function es(e,t){let o=[],i=0,n=[];if(e){let t=(0,et.Tc)(e);({hunks:n,count:i}=ea(t,"staged",i)),o.push(...n)}if(t){let e=(0,et.Tc)(t);({hunks:n,count:i}=ea(e,"unstaged",i)),o.push(...n)}return o}function ea(e,t,o,i,n){let s=[],a=o;for(let o of e.files)if(o.hunks.length)for(let e of o.hunks){let r=++a,{additions:c,deletions:d}=function(e){let t=e.split(`
`),o=0,i=0;for(let e of t)e.startsWith("+")&&!e.startsWith("+++")?o++:e.startsWith("-")&&!e.startsWith("---")&&i++;return{additions:o,deletions:i}}(e.content),m={index:r,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e.header,content:e.content,additions:c,deletions:d,source:t,assigned:!1,isRename:!1,author:i,coAuthors:n};s.push(m)}else{let e,r,c=++a;if(o.metadata.binary)e="binary",r="Binary file";else if(o.metadata.modeChanged)e="mode change",r=`Mode change from ${o.metadata.modeChanged.oldMode||"?"} to ${o.metadata.modeChanged.newMode||"?"}`;else if(o.metadata.renamedOrCopied){e="rename";let t=o.metadata.renamedOrCopied?.similarity||100;r=`Rename from ${o.originalPath}
Rename to ${o.path}
Similarity index ${t}%`}else e="no-content-change",r=o.header.split(`
`).slice(1).join(`
`);let d={index:c,fileName:o.path,originalFileName:o.originalPath,diffHeader:o.header,hunkHeader:e,content:r,additions:0,deletions:0,source:t,assigned:!1,isRename:!1!==o.metadata.renamedOrCopied,author:i,coAuthors:n};s.push(d)}return{hunks:s,count:a}}async function er(e,t){if(t){let o=await el(e,t.baseSha,t.headSha);return{staged:void 0,unstaged:void 0,commits:o,unified:o}}let[o,i,n]=await Promise.allSettled([e.git.diff.getDiff?.(a.id),e.git.diff.getDiff?.(a.SU),e.git.diff.getDiff?.(a.SU,"HEAD",{notation:"..."})]);return{staged:(0,l.Ro)(o),unstaged:(0,l.Ro)(i),unified:(0,l.Ro)(n),commits:void 0}}async function ec(e,t,o,i,s){return{repoPath:e.path,headSha:i??null,baseSha:o??null,branchName:s,hashes:{staged:t.staged?.contents?await (0,n.sc)(t.staged.contents):null,unstaged:t.unstaged?.contents?await (0,n.sc)(t.unstaged.contents):null,unified:t.unified?.contents?await (0,n.sc)(t.unified.contents):null,commits:t.commits?.contents?await (0,n.sc)(t.commits.contents):null}}}async function ed(e,t,o,i){let s=[];try{if(e.path!==t.repoPath&&s.push(`Repository path changed from "${t.repoPath}" to "${e.path}"`),t.branchName){let o=await e.git.branches.getBranch(t.branchName);o?.sha!==t.headSha&&s.push(`HEAD commit changed from "${t.headSha}" to "${o?.sha}"`)}else{let o=await e.git.commits.getCommit("HEAD"),i=o?.sha??null;i!==t.baseSha&&s.push(`HEAD commit changed from "${t.baseSha}" to "${i}"`)}if(o?.length)if(t.hashes.commits){if(null===t.baseSha)return{isValid:!1,errors:["Base commit is null"]};if(null===t.headSha)return{isValid:!1,errors:["Head commit is null"]};let o=await el(e,t.baseSha,t.headSha);if(!o?.contents)return{isValid:!1,errors:["Failed to calculate combined diff"]};await (0,n.sc)(o.contents)!==t.hashes.commits&&s.push("Branch changes have been modified since composer opened")}else{let{staged:a,unstaged:r}=i??await er(e)??{staged:void 0,unstaged:void 0,unified:void 0},c={staged:a?.contents?await (0,n.sc)(a.contents):null,unstaged:r?.contents?await (0,n.sc)(r.contents):null};o.some(e=>"staged"===e.source)&&c.staged!==t.hashes.staged&&s.push("Staged changes have been modified since composer opened"),o.some(e=>"unstaged"===e.source)&&c.unstaged!==t.hashes.unstaged&&s.push("Unstaged changes have been modified since composer opened")}return{isValid:!s.length,errors:s}}catch(e){return s.push(`Failed to validate repository state: ${e instanceof Error?e.message:"Unknown error"}`),{isValid:!1,errors:s}}}async function em(e,t,o,i){try{let e,n=await t.git.branches.getBranch(o);if(!n||(i&&(e=await t.git.branches.getBranch(i)),!e))return;let s=await t.git.refs.getMergeBase(n.ref,e.ref);if(!s)return;let a=await t.git.commits.getCommit(s);if(!a)return;let r=await t.git.commits.getLog(`${e.ref}..${n.ref}`,{limit:0});if(!r?.commits?.size)return;let c=Array.from(r.commits.values()).reverse(),d=c[c.length-1];return{commits:c,baseCommit:{sha:a.sha,message:a.message??""},headCommitSha:d?.sha??n.sha}}catch{return}}async function eh(e,t){try{let o=await e.git.config.getCurrentUser(),i=[],n=[],s=0;for(let a of t){let t=e.git.diff;if(!t?.getDiff)continue;let r=await t.getDiff(a.sha,`${a.sha}~1`);if(!r?.contents)continue;let c=(0,et.Tc)(r.contents),d=[],m={...a.author,name:"You"===a.author.name?o?.name??a.author.name:a.author.name},{hunks:h,count:l}=ea(c,"commits",s,m,function(e){let t,o=[];if(!e.message)return o;let i=/^Co-authored-by:\s*(.+?)(?:\s*<(.+?)>)?\s*$/gm;for(;null!==(t=i.exec(e.message));){let[,i,n]=t;i&&o.push({name:i.trim(),email:n?.trim(),date:e.date})}return o}(a));n.push(...h),s=l,d.push(...h.map(e=>e.index));let u={id:a.sha,message:a.message||"",sha:a.sha,hunkIndices:d};i.push(u)}return{commits:i,hunks:n}}catch{return}}async function el(e,t,o){try{let i=e.git.diff;if(!i?.getDiff)return;let n=await i.getDiff(o,t);if(!n?.contents)return;return n}catch{return}}let ComposerWebviewProvider=class ComposerWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=i.Disposable.from(m.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,h.wt)(this.onContextChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this)),this._context={...C},this._safetyState={repoPath:"",headSha:null,baseSha:null,hashes:{staged:null,unstaged:null,unified:null}}}_disposable;_args;_cache=new u.o({accessTTL:3e5});_generateCommitsCancellation;_generateCommitMessageCancellation;_repositorySubscription;_currentRepository;_hunks=[];_safetyState;_recompose=null;_context;_ignoreIndexChange=!1;dispose(){this._cache.clear(),this.resetContext(),this._generateCommitsCancellation?.dispose(),this._generateCommitMessageCancellation?.dispose(),this._repositorySubscription?.dispose(),this._disposable.dispose()}onMessageReceived(e){switch(!0){case y.is(e):this.onGenerateCommits(e.params);break;case _.is(e):this.onGenerateCommitMessage(e.params);break;case w.is(e):this.onFinishAndCommit(e.params);break;case b.is(e):this.close();break;case v.is(e):this.onReloadComposer(e.params);break;case E.is(e):this.onSelectAIModel();break;case R.is(e):this.onAIFeedbackHelpful(e.params);break;case A.is(e):this.onAIFeedbackUnhelpful(e.params);break;case k.is(e):this.onCancelGenerateCommits();break;case S.is(e):this.onCancelGenerateCommitMessage();break;case I.is(e):this.onClearAIOperationError();break;case M.is(e):this.onOpenOnboarding();break;case D.is(e):this.onAdvanceOnboarding(e.params);break;case T.is(e):this.onDismissOnboarding();break;case H.is(e):this.onAddHunksToCommit(e.params);break;case $.is(e):this.onUndo();break;case O.is(e):this.onRedo();break;case N.is(e):this.onReset();break;case F.is(e):this.onChooseRepository()}}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.session.start":this._context.sessionStart,"context.session.duration":this._context.sessionDuration,"context.source":this._context.source,"context.mode":this._context.mode,"context.diff.files.count":this._context.diff.files,"context.diff.hunks.count":this._context.diff.hunks,"context.diff.lines.count":this._context.diff.lines,"context.diff.staged.exists":this._context.diff.staged,"context.diff.unstaged.exists":this._context.diff.unstaged,"context.diff.unstaged.included":this._context.diff.unstagedIncluded,"context.commits.initialCount":this._context.commits.initialCount,"context.commits.autoComposedCount":this._context.commits.autoComposedCount,"context.commits.composedCount":this._context.commits.composedCount,"context.commits.finalCount":this._context.commits.finalCount,"context.ai.enabled.config":this._context.ai.enabled.config,"context.ai.enabled.org":this._context.ai.enabled.org,"context.ai.model.id":this._context.ai.model?.id,"context.ai.model.name":this._context.ai.model?.name,"context.ai.model.provider.id":this._context.ai.model?.provider.id,"context.ai.model.temperature":this._context.ai.model?.temperature??void 0,"context.ai.model.maxTokens.input":this._context.ai.model?.maxTokens.input,"context.ai.model.maxTokens.output":this._context.ai.model?.maxTokens.output,"context.ai.model.default":this._context.ai.model?.default,"context.ai.model.hidden":this._context.ai.model?.hidden,"context.onboarding.stepReached":this._context.onboarding.stepReached,"context.onboarding.dismissed":this._context.onboarding.dismissed,"context.operations.generateCommits.count":this._context.operations.generateCommits.count,"context.operations.generateCommits.cancelled.count":this._context.operations.generateCommits.cancelledCount,"context.operations.generateCommits.error.count":this._context.operations.generateCommits.errorCount,"context.operations.generateCommits.feedback.upvote.count":this._context.operations.generateCommits.feedback.upvoteCount,"context.operations.generateCommits.feedback.downvote.count":this._context.operations.generateCommits.feedback.downvoteCount,"context.operations.generateCommitMessage.count":this._context.operations.generateCommitMessage.count,"context.operations.generateCommitMessage.cancelled.count":this._context.operations.generateCommitMessage.cancelledCount,"context.operations.generateCommitMessage.error.count":this._context.operations.generateCommitMessage.errorCount,"context.operations.finishAndCommit.error.count":this._context.operations.finishAndCommit.errorCount,"context.operations.undo.count":this._context.operations.undo.count,"context.operations.redo.count":this._context.operations.redo.count,"context.operations.reset.count":this._context.operations.reset.count,"context.warnings.workingDirectoryChanged":this._context.warnings.workingDirectoryChanged,"context.warnings.indexChanged":this._context.warnings.indexChanged,"context.errors.safety.count":this._context.errors.safety.count,"context.errors.operation.count":this._context.errors.operation.count}}includeBootstrap(e){return this._cache.get("bootstrap",()=>this.getBootstrapState())}async getBootstrapState(){let e;this.container.git.isDiscoveringRepositories&&await this.container.git.isDiscoveringRepositories;let t=this._args;return null==(e=t?.repoPath!=null?this.container.git.getRepository(t.repoPath):this.container.git.getBestRepositoryOrFirst())?{...this.initialState,loadingError:"No repository found. Please open a Git repository to use the Commit Composer."}:t?.branchName?this.initializeStateAndContextFromBranch(e,t.branchName,t.mode,t.source):this.initializeStateAndContextFromWorkingDirectory(e,t?.includedUnstagedChanges,t?.mode,t?.source)}get initialState(){return{...this.host.baseWebviewState,...f}}async initializeStateAndContext(e,t,o,i,n,s,a,r="preview",c,d){this._currentRepository=e,this._hunks=t;let m=await ec(e,i,n?.sha,s,a);this._safetyState=m,(a||n&&s)&&(this._recompose={enabled:!0,branchName:a,locked:!0});let h=this.getAiEnabled(),l=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId}),u=this.isOnboardingDismissed(),g=this.getOnboardingStepReached();return this._context.diff.files=new Set(t.map(e=>e.fileName)).size,this._context.diff.hunks=t.length,this._context.diff.lines=t.reduce((e,t)=>e+t.content.split(`
`).length-1,0),this._context.commits.initialCount=0,this._context.ai.enabled.org=h.org,this._context.ai.enabled.config=h.config,this._context.ai.model=l,this._context.onboarding.dismissed=u,this._context.onboarding.stepReached=g,this._context.source=c,this._context.mode=r,this._context.warnings.workingDirectoryChanged=!1,this._context.warnings.indexChanged=!1,this._context.sessionStart=new Date().toISOString(),this.sendTelemetryEvent(d?"composer/reloaded":"composer/loaded"),{...this.initialState,hunks:t,baseCommit:n??null,commits:o,aiEnabled:h,ai:{model:l},hasChanges:o.length>0,mode:r,onboardingDismissed:u,workingDirectoryHasChanged:!1,indexHasChanged:!1,repositoryState:this.getRepositoryState(),recompose:this._recompose??null}}async initializeStateAndContextFromWorkingDirectory(e,t,o="preview",i,n){this._repositorySubscription?.dispose();let s=(await e.git.status?.getUntrackedFiles())?.map(e=>e.path);if(s?.length)try{await e.git.staging?.stageFiles(s,{intentToAdd:!0}),this._ignoreIndexChange=!0}catch{}let[a,r,c]=await Promise.allSettled([er(e),e.git.commits.getCommit("HEAD"),e.git.branches.getBranch()]);s?.length&&await e.git.staging?.unstageFiles(s).catch();let d=(0,l.Ro)(a);this._context.diff.unstagedIncluded=!1,t&&(this._context.diff.unstagedIncluded=!0);let m=this._context.diff.unstagedIncluded?d?.unified:d?.staged,h=this._context.diff.unstagedIncluded?void 0:d?.unstaged;!d?.staged?.contents&&d?.unstaged?.contents&&(this._context.diff.unstagedIncluded=!0);let u=!!(m?.contents||h?.contents),g=es(m?.contents,h?.contents),p=(0,l.Ro)(r),f=(0,l.Ro)(c),C=!!m?.contents,x=!!h?.contents,y={id:"draft-commit-1",message:"",aiExplanation:"",hunkIndices:C&&x?g.filter(e=>"staged"===e.source).map(e=>e.index):g.map(e=>e.index)};return this._context.diff.staged=C,this._context.diff.unstaged=x,this._context.diff.commits=!1,this.subscribeToRepository(e),this.initializeStateAndContext(e,g,u?[y]:[],d,p?{sha:p.sha,message:p.message??"",repoName:e.name,branchName:f?.name??"main"}:void 0,void 0,void 0,o,i,n)}async initializeStateAndContextFromBranch(e,t,o="preview",i,n){let s,a=await e.git.branches.getBranch(t);if(!a)return{...this.initialState,loadingError:`Branch '${t}' not found.`};let c=t,d=a,m=new Set,h=0;for(;h<10&&(h++,!m.has(c));){m.add(c);let a=await (0,r.DY)(this.container,d);if(!a.paused&&a.value){s=a.value;let r=await em(this.container,e,t,s);if(r&&r.commits.length>0){let{commits:s,baseCommit:a,headCommitSha:d}=r,m=await eh(e,s);if(!m)return{...this.initialState,loadingError:`Failed to process commits for branch '${t}'.`};let{commits:h,hunks:l}=m,u=await er(e,{baseSha:a.sha,headSha:d});return this.initializeStateAndContext(e,l,h,u,{sha:a.sha,message:a.message,repoName:e.name,branchName:t},d,c,o,i,n)}let m=await e.git.branches.getBranch(s);if(!m||m.name===c)break;c=m.name,d=m}else break}return{...this.initialState,loadingError:s?`Branch '${t}' has no unique commits against any resolved merge target.`:`Unable to determine merge target for branch '${t}'.`}}getRepositoryState(){if(null==this._currentRepository)return;let{id:e,name:t,path:o,uri:i,virtual:n}=this._currentRepository;return{current:{id:e,name:t,path:o,uri:i.toString(),virtual:n},hasMultipleRepositories:this.container.git.openRepositoryCount>1}}async onAddHunksToCommit(e){"unstaged"===e.source&&(this._context.diff.unstagedIncluded=!0,this.sendTelemetryEvent("composer/action/includedUnstagedChanges"),await this.onReloadComposer({repoPath:this._currentRepository.path,mode:this._context.mode}))}onUndo(){this._context.operations.undo.count++,this.sendTelemetryEvent("composer/action/undo")}onRedo(){this._context.operations.redo.count++}onReset(){this._context.operations.reset.count++,this.sendTelemetryEvent("composer/action/reset")}async onChooseRepository(){let{title:e,placeholder:t}=await (0,d.Nt)(this.container.git.openRepositories,"Switch",this._currentRepository?.name),o=await (0,d.oe)(this.container,e,t,this.container.git.openRepositories,{picked:this._currentRepository});null!=o&&await this.onReloadComposer({repoPath:o.path,source:"composer"})}async onReloadComposer(e){try{this._cache.clear();let t=this._currentRepository;if((!t||null!=e.repoPath&&t?.path!==e.repoPath)&&!(t=null==e.repoPath?this.container.git.getBestRepositoryOrFirst():this.container.git.getRepository(e.repoPath))){this._context.errors.safety.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let o=this._recompose?.branchName?await this.initializeStateAndContextFromBranch(t,this._recompose.branchName,e.mode,e.source,!0):await this.initializeStateAndContextFromWorkingDirectory(t,this._context.diff.unstagedIncluded,e.mode,e.source,!0);if(o.loadingError)return void await this.host.notify(q,{error:o.loadingError});await this.host.notify(V,{hunks:o.hunks,commits:o.commits,baseCommit:o.baseCommit,loadingError:o.loadingError,hasChanges:o.hasChanges,repositoryState:o.repositoryState})}catch(e){this.sendTelemetryEvent("composer/reloaded",{"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(q,{error:e instanceof Error?e.message:"Failed to reload composer"})}}async onCancelGenerateCommits(){this._generateCommitsCancellation&&(this._generateCommitsCancellation.cancel(),await this.host.notify(Y,void 0))}async onCancelGenerateCommitMessage(){this._generateCommitMessageCancellation&&(this._generateCommitMessageCancellation.cancel(),await this.host.notify(Z,void 0))}async onClearAIOperationError(){await this.host.notify(K,void 0)}onOpenOnboarding(){this.advanceOnboardingStep(1)}onAdvanceOnboarding(e){this.advanceOnboardingStep(e.stepNumber)}advanceOnboardingStep(e){if(this.isOnboardingDismissed())return;let t=Math.max(this.container.storage.get("composer:onboarding:stepReached")??1,e);this._context.onboarding.stepReached=t,this.container.storage.store("composer:onboarding:stepReached",t).catch()}onDismissOnboarding(){this.isOnboardingDismissed()||(this._context.onboarding.dismissed=!0,this.container.storage.store("composer:onboarding:dismissed",p).catch())}isOnboardingDismissed(){return this.container.storage.get("composer:onboarding:dismissed")===p}getOnboardingStepReached(){return this.container.storage.get("composer:onboarding:stepReached")}resetContext(){this._context={...C}}onShowing(e,t,...o){return o?.[0]&&(this._cache.clear(),this.resetContext(),this._args=o[0],this.updateTitle(o[0].mode)),[!0,void 0]}updateTitle(e){"experimental"===(e??this._args?.mode??"preview")?this.host.title="Commit Composer (Experimental)":this.host.title="Commit Composer (Preview)"}async close(){this._context.sessionDuration=Date.now()-new Date(this._context.sessionStart).getTime(),await i.commands.executeCommand("workbench.action.closeActiveEditor")}async updateAiModel(){try{let e=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});this._context.ai.model=e,this.sendTelemetryEvent("composer/action/changeAiModel"),await this.host.notify(ee,{model:e})}catch{}}async onSelectAIModel(){await i.commands.executeCommand("gitlens.ai.switchProvider",{source:"composer",correlationId:this.host.instanceId,detail:"model-picker"})}async onAIFeedbackHelpful(e){this._context.operations.generateCommits.feedback.upvoteCount++,await this.sendComposerAIFeedback("helpful",e.sessionId)}async onAIFeedbackUnhelpful(e){this._context.operations.generateCommits.feedback.downvoteCount++,await this.sendComposerAIFeedback("unhelpful",e.sessionId)}async sendComposerAIFeedback(e,t){try{let o,i=await this.container.ai.getModel({silent:!0},{source:"composer",correlationId:this.host.instanceId});if(!i)return;let n={id:t||"composer-session",type:"generate-commits",feature:"composer",model:{id:i.id,name:i.name,maxTokens:i.maxTokens,provider:{id:i.provider.id,name:i.provider.name},default:i.default,hidden:i.hidden,temperature:i.temperature},usage:void 0};if("unhelpful"===e&&(o=await (0,c.E)(),void 0===o))return;(0,c._)(this.container,{source:"composer",correlationId:this.host.instanceId},n,e,o)}catch{}}subscribeToRepository(e){this._repositorySubscription?.dispose(),this._repositorySubscription=i.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(this.onRepositoryFileSystemChanged,this),e.onDidChange(this.onRepositoryChanged,this))}async onRepositoryChanged(e){if(e.repository.id!==this._currentRepository?.id)return;let t=this._ignoreIndexChange;this._ignoreIndexChange=!1,!e.changed(s.Z_.Index,s.Ti.Any)||t&&e.changed(s.Z_.Index,s.Ti.Exclusive)||(this._context.warnings.indexChanged=!0,await this.host.notify(L,void 0))}async onRepositoryFileSystemChanged(e){e.repository.id===this._currentRepository?.id&&(this._context.warnings.workingDirectoryChanged=!0,await this.host.notify(j,void 0))}async onGenerateCommits(e){let t={"customInstructions.used":!1,"customInstructions.length":0,"customInstructions.hash":"","customInstructions.setting.used":!1,"customInstructions.setting.length":0};try{let o=m.H.get("ai.generateCommits.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommits.count++,e.customInstructions&&(t["customInstructions.used"]=!0,t["customInstructions.length"]=e.customInstructions.length,t["customInstructions.hash"]=(0,n.Fx)(e.customInstructions)),this._generateCommitsCancellation=new i.CancellationTokenSource,await this.host.notify(P,void 0);let s=[];if(this._recompose?.enabled&&this._safetyState?.hashes.commits){let e=await el(this._currentRepository,this._safetyState.baseSha,this._safetyState.headSha);for(let t of es(e.contents)){let{author:e,coAuthors:o}=function(e,t){let o,i=e.filter(e=>null!=e.author&&e.fileName===t.fileName&&(!t.isRename||e.isRename===t.isRename)),n=new Map,s=new Map,a=0;for(let e of i){s.set(e.author.name,e.author),e.coAuthors?.forEach(e=>s.set(e.name,e));let i=function(e,t){let o=e.hunkHeader.match(/@@ -(\d+),(\d+)/),i=e.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/),n=t.hunkHeader.match(/@@ -(\d+),(\d+)/),s=t.hunkHeader.match(/@@ -\d+,\d+ \+(\d+),(\d+)/);return null==o||null==i||null==n||null==s?0:en({start:parseInt(o[1],10),count:parseInt(o[2],10)},{start:parseInt(n[1],10),count:parseInt(n[2],10)})+en({start:parseInt(i[1],10),count:parseInt(i[2],10)},{start:parseInt(s[1],10),count:parseInt(s[2],10)})}(e,t);n.has(e.author.name)&&(i+=n.get(e.author.name)),n.set(e.author.name,i),(null==o||i>a)&&(a=i,o=e.author)}return null!=o&&s.delete(o.name),{author:o,coAuthors:[...s.values()]}}(this._hunks,t);t.author=e,t.coAuthors=o.length?o:void 0,s.push({...t,assigned:!0})}this._hunks=s}else for(let t of e.hunkIndices)s.push({...this._hunks.find(e=>e.index===t),assigned:!0});let a=e.commits.map(e=>({id:e.id,message:e.message,aiExplanation:e.aiExplanation,hunkIndices:e.hunkIndices})),r=await this.container.ai.generateCommits(s,a,this._hunks.map(e=>({index:e.index,hunkHeader:e.hunkHeader})),{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitsCancellation.token,customInstructions:e.customInstructions});if(this._generateCommitsCancellation?.token.isCancellationRequested){this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Y,void 0);return}if(r&&"cancelled"!==r){if(0===r.commits.length){this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"no commits generated"}),await this.host.notify(J,{operation:"generate commits",error:"No commits generated"});return}let o=r.commits.map((e,t)=>({id:`ai-commit-${t}`,message:e.message,aiExplanation:e.explanation,hunkIndices:e.hunks.map(e=>e.hunk)}));this._context.commits.autoComposedCount=o.length,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose":"composer/action/compose",t),this._recompose?.enabled&&(this._recompose.locked=!1),await this.host.notify(Q,{commits:o,hunks:this._recompose?.enabled?this._hunks:void 0})}else"cancelled"===r?(this._context.operations.generateCommits.cancelledCount++,await this.host.notify(Y,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(J,{operation:"generate commits",error:void 0}))}catch(o){this._generateCommitsCancellation?.token.isCancellationRequested?(this._context.operations.generateCommits.cancelledCount++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Y,void 0)):(this._context.operations.generateCommits.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent(e.isRecompose?"composer/action/recompose/failed":"composer/action/compose/failed",{...t,"failure.reason":"error","failure.error.message":o instanceof Error?o.message:"unknown error"}),await this.host.notify(J,{operation:"generate commits",error:o instanceof Error?o.message:void 0}))}finally{this._generateCommitsCancellation?.dispose(),this._generateCommitsCancellation=void 0}}async onGenerateCommitMessage(e){let t={"customInstructions.setting.used":!1,"customInstructions.setting.length":0,overwriteExistingMessage:e.overwriteExistingMessage??!1};try{let o=m.H.get("ai.generateCommitMessage.customInstructions");o&&(t["customInstructions.setting.used"]=!0,t["customInstructions.setting.length"]=o.length),this._context.operations.generateCommitMessage.count++,this._generateCommitMessageCancellation=new i.CancellationTokenSource,await this.host.notify(B,{commitId:e.commitId});let{patch:n}=ei(this._hunks.filter(t=>e.commitHunkIndices.includes(t.index)));n||(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"Failed to create diff for commit"}),await this.host.notify(J,{operation:"generate commit message",error:"Failed to create diff for commit"}));let s=await this.container.ai.generateCommitMessage(n,{source:"composer",correlationId:this.host.instanceId},{cancellation:this._generateCommitMessageCancellation.token});if(this._generateCommitMessageCancellation?.token.isCancellationRequested){this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0);return}if(s&&"cancelled"!==s){let o=s.parsed.body?`${s.parsed.summary}

${s.parsed.body}`:s.parsed.summary;this.sendTelemetryEvent("composer/action/generateCommitMessage",t),await this.host.notify(U,{commitId:e.commitId,message:o})}else"cancelled"===s?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":"unknown error"}),await this.host.notify(J,{operation:"generate commit message",error:void 0}))}catch(e){this._generateCommitMessageCancellation?.token.isCancellationRequested?(this._context.operations.generateCommitMessage.cancelledCount++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"cancelled"}),await this.host.notify(Z,void 0)):(this._context.operations.generateCommitMessage.errorCount++,this._context.errors.operation.count++,this.sendTelemetryEvent("composer/action/generateCommitMessage/failed",{...t,"failure.reason":"error","failure.error.message":e instanceof Error?e.message:"unknown error"}),await this.host.notify(J,{operation:"generate commit message",error:e instanceof Error?e.message:void 0}))}finally{this._generateCommitMessageCancellation?.dispose(),this._generateCommitMessageCancellation=void 0}}async onFinishAndCommit(e){try{var t;let o,s,r,c;await this.host.notify(G,void 0);let d=this.container.git.getRepository(this._safetyState.repoPath);if(!d){await this.host.notify(z,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++;let e="Repository is no longer available";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let m=e.commits.flatMap(e=>e.hunkIndices),h=[];for(let e of m)h.push({...this._hunks.find(t=>t.index===e),assigned:!0});let l=h.filter(t=>e.commits.some(e=>e.hunkIndices.includes(t.index)));if(this._context.diff.unstagedIncluded){this._repositorySubscription?.dispose();let e=(await d.git.status?.getUntrackedFiles())?.map(e=>e.path);if(e?.length)try{o=await er(d),await d.git.staging?.stageFiles(e)}catch{}}let u=await ed(d,this._safetyState,l,o);if(!u.isValid){await this.host.notify(z,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=u.errors.join(`
`);this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let g=(t=e.commits,t.map(e=>{let{patch:t,filePatches:o}=ei(eo(e,h)),{author:i,coAuthors:n}=function(e){let t,o=new Map,i=new Map;for(let t of e)null!=t.author&&(i.set(t.author.name,t.author),t.coAuthors?.forEach(e=>i.set(e.name,e)),o.set(t.author.name,(o.get(t.author.name)??0)+t.additions+t.deletions));let n=0;for(let[e,s]of o.entries())(null==t||s>n)&&(t=i.get(e),n=s);return null!=t&&i.delete(t.name),{author:t,coAuthors:[...i.values()]}}(eo(e,h)),s=e.message;return n.length>0&&(s+=`
${n.map(e=>`
Co-authored-by: ${e.name} <${e.email}>`).join()}`),{message:s,explanation:e.aiExplanation,filePatches:o,patch:t,author:i}})),p=this.container.git.getRepositoryService(d.path);if(!p){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="No repository service found";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(e.baseCommit?.sha==null){let e=await p.patch?.createEmptyInitialCommit();if(null==e){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Could not create base commit";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}}let f=await d.git.patch?.createUnreachableCommitsFromPatches(e.baseCommit?.sha,g);if(!f?.length){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to create commits from patches";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}let C=e.baseCommit?.sha??(await d.git.commits.getCommit("HEAD")?"HEAD":a.BI),x=(await d.git.diff.getDiff?.(f[f.length-1],C,{notation:e.baseCommit?.sha?"...":void 0}))?.contents;if(!x){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Failed to get combined diff";throw this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),Error(e)}if(!function(e,t,o){let{hashes:i}=e;return i.commits?t===i.commits:t===(o?i.unified:i.staged)}(this._safetyState,await (0,n.sc)(x),this._context.diff.unstagedIncluded)){await this.host.notify(z,void 0),this._context.errors.safety.count++,this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e="Output diff does not match input";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(W,{error:e});return}let y=!1;if(await d.git.status.hasWorkingChanges({throwOnError:!0})){if(r=await p.stash?.getStash(),r?.stashes.size){let e=r.stashes.values().next().value;e&&(s=e)}let e=`Commit composer: ${new Date().toLocaleString()}`;await p.stash?.saveStash(e,void 0,{includeUntracked:!0}),r=await p.stash?.getStash(),r?.stashes.size&&(c=r.stashes.values().next().value)&&c.ref!==s?.ref&&c.message?.includes(e)&&(y=!0)}this._recompose?.enabled&&this._recompose.branchName?await d.git.refs.updateReference(`refs/heads/${this._recompose.branchName}`,f[f.length-1]):await p.ops?.reset(f[f.length-1],{mode:"hard"}),c&&y&&await p.stash?.applyStash(c.stashName,{deleteAfter:!0}),this._context.commits.finalCount=f.length,this.sendTelemetryEvent("composer/action/finishAndCommit"),await this.host.notify(z,void 0),i.commands.executeCommand("workbench.action.closeActiveEditor")}catch(t){this._context.errors.operation.count++,this._context.operations.finishAndCommit.errorCount++;let e=t instanceof Error?t.message:"unknown error";this.sendTelemetryEvent("composer/action/finishAndCommit/failed",{"failure.reason":"error","failure.error.message":e}),await this.host.notify(z,void 0),i.window.showErrorMessage(`Failed to commit changes: ${e}`)}}onAnyConfigurationChanged(e){if(m.H.changed(e,"ai.enabled")){let e=m.H.get("ai.enabled",void 0,!0);this._context.ai.enabled.config=e,this.host.notify(X,{config:e})}}onContextChanged(e){if("gitlens:gk:organization:ai:enabled"===e){let e=(0,h.SD)("gitlens:gk:organization:ai:enabled",!0);this._context.ai.enabled.org=e,this.host.notify(X,{org:e})}}onAIModelChanged(e){this.updateAiModel()}getAiEnabled(){return{org:(0,h.SD)("gitlens:gk:organization:ai:enabled",!0),config:m.H.get("ai.enabled",void 0,!0)}}sendTelemetryEvent(e,t){this.container.telemetry.enabled&&this.container.telemetry.sendEvent(e,{...this.getTelemetryContext(),...t})}}}};