exports.id=758,exports.ids=[758],exports.modules={450:(e,t,r)=>{r.r(t),r.d(t,{LinearAuthenticationProvider:()=>LinearAuthenticationProvider});var i=r(4109),s=r(5460);let LinearAuthenticationProvider=class LinearAuthenticationProvider extends s.DP{get authProviderId(){return i.NN.Linear}}},1446:(e,t,r)=>{r.r(t),r.d(t,{LinearIntegration:()=>LinearIntegration});var i=r(4109),s=r(134),o=r(3481),a=r(5711),n=r(3761);let u=n.Mt[i.NN.Linear],l=Object.freeze({id:u.id,scopes:u.scopes});let LinearIntegration=class LinearIntegration extends a.L{_autolinks;async autolinks(){if(!(this.maybeConnected??await this.isConnected())||null==this._session)return[];let e=this._autolinks?.get(this._session.accessToken);if(null!=e)return e;let t=await this.getOrganization(this._session);if(null==t)return[];let r=[];for(let e of await this.getTeams(this._session)??[]){let i=`${e.key}-`,s=`${e.key}_`;r.push({prefix:i,url:`${t.url}/issue/${i}<num>`,alphanumeric:!1,ignoreCase:!1,title:`Open Issue ${i}<num> on ${t.name}`,type:"issue",description:`${t.name} Issue ${i}<num>`,descriptor:{...t}}),r.push({prefix:s,url:`${t.url}/issue/${i}<num>`,alphanumeric:!1,ignoreCase:!1,referenceType:"branch",title:`Open Issue ${i}<num> on ${t.name}`,type:"issue",description:`${t.name} Issue ${i}<num>`,descriptor:{...t}})}return this._autolinks??=new Map,this._autolinks.set(this._session.accessToken,r),r}_organizations;async getOrganization({accessToken:e},t=!1){if(this._organizations??=new Map,null==this._organizations.get(e)||t){let t=await this.getProvidersApi(),r=await t.getLinearOrganization({accessToken:e}),i=r&&{id:r.id,key:r.key,name:r.name,url:r.url};i&&this._organizations.set(e,i)}return this._organizations.get(e)}_teams;async getTeams({accessToken:e},t=!1){if(this._teams??=new Map,null==this._teams.get(e)||t){let t=await this.getProvidersApi(),r=await t.getLinearTeamsForCurrentUser({accessToken:e}),i=r?.map(e=>({id:e.id,key:e.key,name:e.name,avatarUrl:e.iconUrl}));i&&this._teams.set(e,i)}return this._teams.get(e)}getProviderResourcesForUser(e){throw Error("Method not implemented.")}getProviderProjectsForResources(e,t){throw Error("Method not implemented.")}authProvider=l;getProviderAccountForResource(e,t){throw Error("Method not implemented.")}getProviderIssuesForProject(e,t,r){throw Error("Method not implemented.")}get id(){return i.NN.Linear}get key(){return"linear"}get name(){return u.name}get domain(){return u.domain}async searchProviderMyIssues(e,t,r){let i;if(null!=t)return;let s=await this.getProvidersApi(),a=!1,u=0,l=[];try{do{if(r?.isCancellationRequested)break;let t=await s.getIssuesForCurrentUser(this.id,{accessToken:e.accessToken,cursor:i});u+=1,a=t.paging?.more??!1,i=t.paging?.cursor;let o=t.values.map(e=>(0,n.Y9)(e,this)).filter(e=>null!=e);o.length>0&&l.push(...o)}while(u<10&&a)}catch(e){if(0===l.length)throw e;o.Vy.error(e,"searchProviderMyIssues")}return l}async getProviderLinkedIssueOrPullRequest(e,t,{key:r},i){let s=await this.getRawProviderIssue(e,t,r),o=s&&{...s,url:this.getIssueAutolinkLikeUrl(s)};return o&&(0,n.Y9)(o,this)}async getProviderIssue(e,t,r){let i=await this.getRawProviderIssue(e,t,r);return i&&(0,n.J3)(i,this)}async getRawProviderIssue(e,t,r){let i=await this.getProvidersApi();try{if(!(0,s.d)(t))return void o.Vy.error(void 0,"getProviderIssue: resource is not an IssueResourceDescriptor");let a=await i.getIssue(this.id,{resourceId:t.id,number:r},{accessToken:e.accessToken});if(null==a)return;return a}catch(e){o.Vy.error(e,"getProviderIssue");return}}getIssueAutolinkLikeUrl(e){let t=e.url;if(null==t)return null;let r=t.split("/").pop();return r&&e.number!==r?t.substring(0,t.length-r.length-1):t}}},1452:(e,t,r)=>{r.r(t),r.d(t,{GitLabIntegration:()=>GitLabIntegration,GitLabSelfHostedIntegration:()=>GitLabSelfHostedIntegration});var i=r(1398),s=r(4109),o=r(6434),a=r(3991),n=r(6317),u=r(5817),l=r(5707),c=r(7609),d=r(3761),h=Object.defineProperty,p=Object.getOwnPropertyDescriptor;let g=d.Mt[s.$r.GitLab],m=Object.freeze({id:g.id,scopes:g.scopes}),f=d.Mt[s.RR.GitLabSelfHosted],v=Object.freeze({id:f.id,scopes:f.scopes}),y=d.Mt[s.RR.CloudGitLabSelfHosted],w=Object.freeze({id:y.id,scopes:y.scopes});let GitLabIntegrationBase=class GitLabIntegrationBase extends u.d{async getProviderAccountForCommit({accessToken:e},t,r,i){return(await this.container.gitlab)?.getAccountForCommit(this,e,t.owner,t.name,r,{...i,baseUrl:this.apiBaseUrl})}async getProviderAccountForEmail({accessToken:e},t,r,i){return(await this.container.gitlab)?.getAccountForEmail(this,e,t.owner,t.name,r,{...i,baseUrl:this.apiBaseUrl})}async getProviderDefaultBranch({accessToken:e},t){return(await this.container.gitlab)?.getDefaultBranch(this,e,t.owner,t.name,{baseUrl:this.apiBaseUrl})}async getProviderLinkedIssueOrPullRequest({accessToken:e},t,{id:r}){return(await this.container.gitlab)?.getIssueOrPullRequest(this,e,t.owner,t.name,Number(r),{baseUrl:this.apiBaseUrl})}async getProviderIssue({accessToken:e},t,r){let i=await this.container.gitlab,o=await this.getProvidersApi(),a=this.id===s.RR.GitLabSelfHosted||this.id===s.RR.CloudGitLabSelfHosted;if(!i||!t||!r||!await i.getProjectId(this,e,t.owner,t.name,this.apiBaseUrl,void 0))return;let n=await o.getIssue(this.id,{namespace:t.owner,name:t.name,number:r},{accessToken:e,isPAT:a,baseUrl:a?`https://${this.domain}`:void 0}),u=null!=n?(0,d.Y9)(n,this):void 0;return null!=u?{...u,type:"issue"}:void 0}async getProviderPullRequestForBranch({accessToken:e},t,i,s){let{include:o,...a}=s??{},n=(await Promise.resolve().then(r.bind(r,7609))).toGitLabMergeRequestState;return(await this.container.gitlab)?.getPullRequestForBranch(this,e,t.owner,t.name,i,{...a,include:o?.map(e=>n(e)),baseUrl:this.apiBaseUrl})}async getProviderPullRequestForCommit({accessToken:e},t,r){return(await this.container.gitlab)?.getPullRequestForCommit(this,e,t.owner,t.name,r,{baseUrl:this.apiBaseUrl})}async getProviderPullRequest({accessToken:e},t,r){return(await this.container.gitlab)?.getPullRequest(this,e,t.owner,t.name,parseInt(r,10),{baseUrl:this.apiBaseUrl})}async getRepoInfo(e){return(await this.getProvidersApi()).getRepo(this.id,e.owner,e.name,void 0,{accessToken:this._session?.accessToken})}async getProviderRepositoryMetadata({accessToken:e},t,r){return(await this.container.gitlab)?.getRepositoryMetadata(this,e,t.owner,t.name,{baseUrl:this.apiBaseUrl},r)}async searchProviderMyPullRequests({accessToken:e},t){let r,i=await this.getProvidersApi(),o=this.id===s.RR.GitLabSelfHosted||this.id===s.RR.CloudGitLabSelfHosted,n=(await this.getCurrentAccount())?.username;if(!n)return Promise.resolve([]);let u=await i.getPullRequestsForUser(this.id,n,{accessToken:e,isPAT:o,baseUrl:o?`https://${this.domain}`:void 0});if(null==u)return Promise.resolve([]);if(null!=t){let e=new Map;for(let r of t)e.set(`${r.owner}/${r.name}`,r);r=u.values.filter(t=>null!=e.get(`${t.repository.owner.login}/${t.repository.name}`))}else r=u.values;return[...(0,a.pD)([...r.filter(e=>{let t=e.assignees?.some(e=>e.username===n),r=e.reviews?.some(e=>e.reviewer?.username===n||e.state===d.lE.ReviewRequested),i=e.author?.username===n;return t||r||i}).map(e=>(0,c.fromGitLabMergeRequestProvidersApi)(e,this))],e=>e.url,(e,t)=>e)]}async searchProviderMyIssues({accessToken:e},t){let r=await this.container.gitlab,i=await this.getProvidersApi(),o=this.id===s.RR.GitLabSelfHosted||this.id===s.RR.CloudGitLabSelfHosted;if(!r||!t)return;let a=(await Promise.allSettled(t.map(t=>r.getProjectId(this,e,t.owner,t.name,this.apiBaseUrl,void 0))??[])).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e);return(await i.getIssuesForRepos(this.id,a,{accessToken:e,isPAT:o,baseUrl:o?`https://${this.domain}`:void 0})).values.map(e=>(0,d.Y9)(e,this)).filter(e=>null!=e)}async searchProviderPullRequests({accessToken:e},t,r,i){let s=await this.container.gitlab;if(s)return s.searchPullRequests(this,e,{search:t,repos:r?.map(e=>`${e.owner}/${e.name}`),baseUrl:this.apiBaseUrl},i)}async mergeProviderPullRequest({accessToken:e},t,r){if(!this.isPullRequest(t))return!1;let i=await this.getProvidersApi(),o=this.id===s.RR.GitLabSelfHosted||this.id===s.RR.CloudGitLabSelfHosted;try{return await i.mergePullRequest(this.id,t,{...r,isPAT:o,baseUrl:o?`https://${this.domain}`:void 0,accessToken:e})}catch(e){return this.showMergeErrorMessage(e),!1}}async showMergeErrorMessage(e){let t="Reauthenticate";await i.window.showErrorMessage(`${e.message}. Would you like to try reauthenticating to provide additional access? Your token needs to have the 'api' scope to perform merge.`,t)===t&&await this.reauthenticate()}isPullRequest(e){return null!=e.refs}async getProviderCurrentAccount({accessToken:e}){let t=await this.getProvidersApi(),r=this.id===s.RR.GitLabSelfHosted||this.id===s.RR.CloudGitLabSelfHosted,i=await t.getCurrentUser(this.id,{accessToken:e,isPAT:r,baseUrl:r?`https://${this.domain}`:void 0});if(null!=i)return{provider:{id:this.id,name:this.name,domain:this.domain,icon:this.icon},id:i.id,name:i.name||void 0,email:i.email||void 0,avatarUrl:i.avatarUrl||void 0,username:i.username||void 0}}getProviderPullRequestIdentityFromMaybeUrl(e){return(0,l.f)(e,this.id)}};let GitLabIntegration=class GitLabIntegration extends GitLabIntegrationBase{authProvider=m;id=s.$r.GitLab;key=this.id;name="GitLab";get domain(){return g.domain}get apiBaseUrl(){return"https://gitlab.com/api"}access(){return Promise.resolve(!0)}};let GitLabSelfHostedIntegration=class GitLabSelfHostedIntegration extends GitLabIntegrationBase{constructor(e,t,r,i,o,a){super(e,t,r,i),this._domain=o,this.id=a,this.key=`${this.id}:${this.domain}`,this.authProvider=this.id===s.RR.GitLabSelfHosted?v:w}authProvider=v;key;name="GitLab Self-Hosted";get domain(){return this._domain}get apiBaseUrl(){return`https://${this._domain}/api`}async connect(e){return!!await (0,n.KH)(this.container,`Rich integration with ${this.name} is a Pro feature.`,{source:"integrations",detail:{action:"connect",integration:this.id}})&&super.connect(e)}};((e,t,r,i)=>{for(var s,o=p(t,r),a=e.length-1;a>=0;a--)(s=e[a])&&(o=s(t,r,o)||o);return o&&h(t,r,o)})([(0,o.Rm)()],GitLabSelfHostedIntegration.prototype,"connect",0)},1624:(e,t,r)=>{r.r(t),r.d(t,{GitHubAuthenticationProvider:()=>GitHubAuthenticationProvider,GitHubEnterpriseAuthenticationProvider:()=>GitHubEnterpriseAuthenticationProvider,GitHubEnterpriseCloudAuthenticationProvider:()=>GitHubEnterpriseCloudAuthenticationProvider});var i=r(1398),s=r(4109),o=r(3709),a=r(5460);let GitHubAuthenticationProvider=class GitHubAuthenticationProvider extends a.DP{constructor(e,t,r){super(e,t,r),this.disposables.push(i.authentication.onDidChangeSessions(e=>{e.provider.id===this.authProviderId&&this.fireChange()}))}get authProviderId(){return s.$r.GitHub}async getSession(e,t){let r=await (0,o.c)(this.container,this.authProviderId,e,{silent:!0});return(null!=r&&t?.forceNewSession&&(r=await (0,o.c)(this.container,this.authProviderId,e,{forceNewSession:!0})),null!=r)?r:super.getSession(e,t)}};let GitHubEnterpriseCloudAuthenticationProvider=class GitHubEnterpriseCloudAuthenticationProvider extends a.DP{get authProviderId(){return s.RR.CloudGitHubEnterprise}};let GitHubEnterpriseAuthenticationProvider=class GitHubEnterpriseAuthenticationProvider extends a.RH{get authProviderId(){return s.RR.GitHubEnterprise}async createSession(e){let t,r=i.window.createInputBox();r.ignoreFocusOut=!0;let s=[];try{let o={iconPath:new i.ThemeIcon("link-external"),tooltip:"Open the GitHub Access Tokens Page"};t=await new Promise(t=>{s.push(r.onDidHide(()=>t(void 0)),r.onDidChangeValue(()=>r.validationMessage=void 0),r.onDidAccept(()=>{let e=r.value.trim();if(!e){r.validationMessage="A personal access token is required";return}t(e)}),r.onDidTriggerButton(t=>{t===o&&i.env.openExternal(i.Uri.parse(`https://${e.domain}/settings/tokens`))})),r.password=!0,r.title=`GitHub Authentication  \u2022 ${e.domain}`,r.placeholder=`Requires a classic token with ${e.scopes.join(", ")} scopes`,r.prompt=`Paste your [GitHub Personal Access Token](https://${e.domain}/settings/tokens "Get your GitHub Access Token")`,r.buttons=[o],r.show()})}finally{r.dispose(),s.forEach(e=>void e.dispose())}if(t)return{id:this.configuredIntegrationService.getSessionId(e),accessToken:t,scopes:e?.scopes??[],account:{id:"",label:""},cloud:!1,domain:e.domain}}}},1633:(e,t,r)=>{r.r(t),r.d(t,{ProvidersApi:()=>ProvidersApi});var i=r(5291),s=r.n(i),o=r(1398),a=r(5369),n=r(6096),u=r(2097),l=r(4109),c=r(8412),d=r(3761);let ProvidersApi=class ProvidersApi{constructor(e,t){this.container=e,this.authenticationService=t;const r=(0,n.cQ)(),i=`${e.debugging?"GitLens-Debug":e.prerelease?"GitLens-Pre":"GitLens"}/${e.version} (${o.env.appName}/${o.version}; ${(0,u.uo)()})`,a=async({url:e,...t})=>h(await (0,n.hd)(e,{agent:r,...t,headers:{"User-Agent":i,...t.headers}})),c=s()({request:a});this.providers={[l.$r.GitHub]:{...d.Mt[l.$r.GitHub],provider:c.github,getCurrentUserFn:c.github.getCurrentUser.bind(c.github),getPullRequestsForReposFn:c.github.getPullRequestsForRepos.bind(c.github),getPullRequestsForUserFn:c.github.getPullRequestsAssociatedWithUser.bind(c.github),getIssuesForReposFn:c.github.getIssuesForRepos.bind(c.github)},[l.RR.CloudGitHubEnterprise]:{...d.Mt[l.RR.GitHubEnterprise],provider:c.github,getCurrentUserFn:c.github.getCurrentUser.bind(c.github),getPullRequestsForReposFn:c.github.getPullRequestsForRepos.bind(c.github),getPullRequestsForUserFn:c.github.getPullRequestsAssociatedWithUser.bind(c.github),getIssuesForReposFn:c.github.getIssuesForRepos.bind(c.github)},[l.RR.GitHubEnterprise]:{...d.Mt[l.RR.GitHubEnterprise],provider:c.github,getCurrentUserFn:c.github.getCurrentUser.bind(c.github),getPullRequestsForReposFn:c.github.getPullRequestsForRepos.bind(c.github),getPullRequestsForUserFn:c.github.getPullRequestsAssociatedWithUser.bind(c.github),getIssuesForReposFn:c.github.getIssuesForRepos.bind(c.github)},[l.$r.GitLab]:{...d.Mt[l.$r.GitLab],provider:c.gitlab,getRepoFn:c.gitlab.getRepo.bind(c.gitlab),getCurrentUserFn:c.gitlab.getCurrentUser.bind(c.gitlab),getPullRequestsForReposFn:c.gitlab.getPullRequestsForRepos.bind(c.gitlab),getPullRequestsForRepoFn:c.gitlab.getPullRequestsForRepo.bind(c.gitlab),getPullRequestsForUserFn:c.gitlab.getPullRequestsAssociatedWithUser.bind(c.gitlab),getIssueFn:c.gitlab.getIssue.bind(c.gitlab),getIssuesForReposFn:c.gitlab.getIssuesForRepos.bind(c.gitlab),getIssuesForRepoFn:c.gitlab.getIssuesForRepo.bind(c.gitlab),mergePullRequestFn:c.gitlab.mergePullRequest.bind(c.gitlab)},[l.RR.CloudGitLabSelfHosted]:{...d.Mt[l.$r.GitLab],provider:c.gitlab,getCurrentUserFn:c.gitlab.getCurrentUser.bind(c.gitlab),getPullRequestsForReposFn:c.gitlab.getPullRequestsForRepos.bind(c.gitlab),getPullRequestsForRepoFn:c.gitlab.getPullRequestsForRepo.bind(c.gitlab),getPullRequestsForUserFn:c.gitlab.getPullRequestsAssociatedWithUser.bind(c.gitlab),getIssueFn:c.gitlab.getIssue.bind(c.gitlab),getIssuesForReposFn:c.gitlab.getIssuesForRepos.bind(c.gitlab),getIssuesForRepoFn:c.gitlab.getIssuesForRepo.bind(c.gitlab),mergePullRequestFn:c.gitlab.mergePullRequest.bind(c.gitlab)},[l.RR.GitLabSelfHosted]:{...d.Mt[l.RR.GitLabSelfHosted],provider:c.gitlab,getCurrentUserFn:c.gitlab.getCurrentUser.bind(c.gitlab),getPullRequestsForReposFn:c.gitlab.getPullRequestsForRepos.bind(c.gitlab),getPullRequestsForRepoFn:c.gitlab.getPullRequestsForRepo.bind(c.gitlab),getPullRequestsForUserFn:c.gitlab.getPullRequestsAssociatedWithUser.bind(c.gitlab),getIssuesForReposFn:c.gitlab.getIssuesForRepos.bind(c.gitlab),getIssuesForRepoFn:c.gitlab.getIssuesForRepo.bind(c.gitlab)},[l.$r.Bitbucket]:{...d.Mt[l.$r.Bitbucket],provider:c.bitbucket,getCurrentUserFn:c.bitbucket.getCurrentUser.bind(c.bitbucket),getBitbucketResourcesForUserFn:c.bitbucket.getWorkspacesForUser.bind(c.bitbucket),getBitbucketPullRequestsAuthoredByUserForWorkspaceFn:c.bitbucket.getPullRequestsForUserAndWorkspace.bind(c.bitbucket),getPullRequestsForReposFn:c.bitbucket.getPullRequestsForRepos.bind(c.bitbucket),getPullRequestsForRepoFn:c.bitbucket.getPullRequestsForRepo.bind(c.bitbucket),mergePullRequestFn:c.bitbucket.mergePullRequest.bind(c.bitbucket)},[l.RR.BitbucketServer]:{...d.Mt[l.RR.BitbucketServer],provider:c.bitbucketServer,getRepoFn:c.bitbucketServer.getRepo.bind(c.bitbucketServer),getCurrentUserFn:c.bitbucketServer.getCurrentUser.bind(c.bitbucketServer),getBitbucketServerPullRequestsForCurrentUserFn:c.bitbucketServer.getPullRequestsForCurrentUser.bind(c.bitbucketServer),getPullRequestsForReposFn:c.bitbucketServer.getPullRequestsForRepos.bind(c.bitbucketServer),getPullRequestsForRepoFn:c.bitbucketServer.getPullRequestsForRepo.bind(c.bitbucketServer),mergePullRequestFn:c.bitbucketServer.mergePullRequest.bind(c.bitbucketServer)},[l.$r.AzureDevOps]:{...d.Mt[l.$r.AzureDevOps],provider:c.azureDevOps,getRepoOfProjectFn:c.azureDevOps.getRepo.bind(c.azureDevOps),getCurrentUserFn:c.azureDevOps.getCurrentUser.bind(c.azureDevOps),getCurrentUserForInstanceFn:c.azureDevOps.getCurrentUserForInstance.bind(c.azureDevOps),getAzureResourcesForUserFn:c.azureDevOps.getOrgsForUser.bind(c.azureDevOps),getAzureProjectsForResourceFn:c.azureDevOps.getAzureProjects.bind(c.azureDevOps),getPullRequestsForReposFn:c.azureDevOps.getPullRequestsForRepos.bind(c.azureDevOps),getPullRequestsForRepoFn:c.azureDevOps.getPullRequestsForRepo.bind(c.azureDevOps),getPullRequestsForAzureProjectsFn:c.azureDevOps.getPullRequestsForProjects.bind(c.azureDevOps),getIssuesForAzureProjectFn:c.azureDevOps.getIssuesForAzureProject.bind(c.azureDevOps),getReposForAzureProjectFn:c.azureDevOps.getReposForAzureProject.bind(c.azureDevOps),mergePullRequestFn:c.azureDevOps.mergePullRequest.bind(c.azureDevOps)},[l.RR.AzureDevOpsServer]:{...d.Mt[l.RR.AzureDevOpsServer],provider:c.azureDevOps,getRepoOfProjectFn:c.azureDevOps.getRepo.bind(c.azureDevOps),getCurrentUserFn:c.azureDevOps.getCurrentUser.bind(c.azureDevOps),getCurrentUserForInstanceFn:c.azureDevOps.getCurrentUserForInstance.bind(c.azureDevOps),getAzureResourcesForUserFn:c.azureDevOps.getCollectionsForUser.bind(c.azureDevOps),getAzureProjectsForResourceFn:c.azureDevOps.getAzureProjects.bind(c.azureDevOps),getPullRequestsForReposFn:c.azureDevOps.getPullRequestsForRepos.bind(c.azureDevOps),getPullRequestsForRepoFn:c.azureDevOps.getPullRequestsForRepo.bind(c.azureDevOps),getPullRequestsForAzureProjectsFn:c.azureDevOps.getPullRequestsForProjects.bind(c.azureDevOps),getIssuesForAzureProjectFn:c.azureDevOps.getIssuesForAzureProject.bind(c.azureDevOps),getReposForAzureProjectFn:c.azureDevOps.getReposForAzureProject.bind(c.azureDevOps),mergePullRequestFn:c.azureDevOps.mergePullRequest.bind(c.azureDevOps)},[l.NN.Jira]:{...d.Mt[l.NN.Jira],provider:c.jira,getCurrentUserForResourceFn:c.jira.getCurrentUserForResource.bind(c.jira),getJiraResourcesForCurrentUserFn:c.jira.getJiraResourcesForCurrentUser.bind(c.jira),getJiraProjectsForResourcesFn:c.jira.getJiraProjectsForResources.bind(c.jira),getIssueFn:c.jira.getIssue.bind(c.jira),getIssuesForProjectFn:c.jira.getIssuesForProject.bind(c.jira),getIssuesForResourceForCurrentUserFn:c.jira.getIssuesForResourceForCurrentUser.bind(c.jira)},[l.NN.Linear]:{...d.Mt[l.NN.Linear],provider:c.linear,getIssueFn:c.linear.getIssue.bind(c.linear),getIssuesForCurrentUserFn:c.linear.getIssuesForCurrentUser.bind(c.linear),getLinearOrganizationFn:c.linear.getLinearOrganization.bind(c.linear),getLinearTeamsForCurrentUserFn:c.linear.getTeamsForCurrentUser.bind(c.linear)},[l.NN.Trello]:{...d.Mt[l.NN.Trello],provider:c.trello}}}providers;getScopesForProvider(e){return this.providers[e]?.scopes}getProviderDomain(e){return this.providers[e]?.domain}getProviderPullRequestsPagingMode(e){return this.providers[e]?.pullRequestsPagingMode}getProviderIssuesPagingMode(e){return this.providers[e]?.issuesPagingMode}providerSupportsPullRequestFilters(e,t){return this.providers[e]?.supportedPullRequestFilters!=null&&t.every(t=>this.providers[e]?.supportedPullRequestFilters?.includes(t))}providerSupportsIssueFilters(e,t){return this.providers[e]?.supportedIssueFilters!=null&&t.every(t=>this.providers[e]?.supportedIssueFilters?.includes(t))}isRepoIdsInput(e){return null!=e&&Array.isArray(e)&&e.every(e=>"string"==typeof e||"number"==typeof e)}async getProviderToken(e,t){let r={domain:e.domain,scopes:e.scopes};try{let i=await this.authenticationService.get(e.id);return(await i.getSession(r,{createIfNeeded:t?.createSessionIfNeeded}))?.accessToken}catch{return}}getAzurePATForOAuthToken(e){return(0,a.K3)(`PAT:${e}`)}async ensureProviderTokenAndFunction(e,t,r){let i=this.providers[e];if(null==i)throw Error(`Provider with id ${e} not registered`);let s=r??await this.getProviderToken(i);if(null==s)throw Error(`Not connected to provider ${e}`);if(null==i[t])throw Error(`Provider with id ${e} does not support function: ${t}`);return{provider:i,token:s}}handleProviderError(e,t,r){if(null==this.providers[e])throw Error(`Provider with id ${e} not registered`);if(r?.response?.status!=null)switch(r.response.status){case 404:case 410:case 422:throw new c.LN(r);case 401:if(r.message?.includes("rate limit")){let e,i=r.response?.headers?.["x-ratelimit-reset"];throw null!=i&&Number.isNaN(e=parseInt(i,10))&&(e=void 0),new c.HG(r,t,e)}throw new c.v3(e,c.R.Unauthorized,r);case 403:throw new c.v3(e,c.R.Forbidden,r);case 429:{let e,i=r.response.headers?.["x-ratelimit-reset"];throw null!=i&&Number.isNaN(e=parseInt(i,10))&&(e=void 0),new c.HG(r,t,e)}default:if(r.response.status>=400&&r.response.status<500)throw new c.tk(r)}throw r}async getPagedResult(e,t,r,i,s="{}",o=!1,a){let n;try{n=JSON.parse(s)}catch{n={}}let u=n.value,l=n.type,c={};"page"===l?c={page:u}:"cursor"===l&&(c={cursor:u});let d={...t,...c};try{let e=await r?.(d,{token:i,isPAT:o,baseUrl:a});if(null==e)return{values:[]};let t=e.pageInfo?.hasNextPage??!1,s="{}";return e.pageInfo?.endCursor!=null?s=JSON.stringify({value:e.pageInfo?.endCursor,type:"cursor"}):e.pageInfo?.nextPage!=null&&(s=JSON.stringify({value:e.pageInfo?.nextPage,type:"page"})),{values:e.data,paging:{cursor:s,more:t}}}catch(t){return this.handleProviderError(e.id,i,t)}}async getRepo(e,t,r,i,s){if(e===l.$r.AzureDevOps&&null!=i){let{provider:o,token:a}=await this.ensureProviderTokenAndFunction(e,"getRepoOfProjectFn",s?.accessToken);try{let e=await o.getRepoOfProjectFn?.({namespace:t,name:r,project:i},{token:a,isPAT:s?.isPAT,baseUrl:s?.baseUrl});return e?.data}catch(t){return this.handleProviderError(e,a,t)}}{let{provider:o,token:a}=await this.ensureProviderTokenAndFunction(e,"getRepoFn",s?.accessToken);try{let e=await o.getRepoFn?.({namespace:t,name:r,project:i},{token:a,isPAT:s?.isPAT,baseUrl:s?.baseUrl});return e?.data}catch(t){return this.handleProviderError(e,a,t)}}}async getCurrentUser(e,t){let{provider:r,token:i}=await this.ensureProviderTokenAndFunction(e,"getCurrentUserFn",t?.accessToken);try{return(await r.getCurrentUserFn?.({},{token:i,isPAT:t?.isPAT,baseUrl:t?.baseUrl}))?.data}catch(t){return this.handleProviderError(e,i,t)}}async getCurrentUserForInstance(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getCurrentUserForInstanceFn",r?.accessToken);return(await i.getCurrentUserForInstanceFn?.({namespace:t},{token:s,isPAT:r?.isPAT,baseUrl:r?.baseUrl}))?.data}async getCurrentUserForResource(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getCurrentUserForResourceFn",r?.accessToken);try{return(await i.getCurrentUserForResourceFn?.({resourceId:t},{token:s,isPAT:r?.isPAT,baseUrl:r?.baseUrl}))?.data}catch(t){return this.handleProviderError(e,s,t)}}async getJiraResourcesForCurrentUser(e){let{provider:t,token:r}=await this.ensureProviderTokenAndFunction(l.NN.Jira,"getJiraResourcesForCurrentUserFn",e?.accessToken);try{return(await t.getJiraResourcesForCurrentUserFn?.({token:r}))?.data}catch(e){return this.handleProviderError(l.NN.Jira,r,e)}}async getLinearOrganization(e){let{provider:t,token:r}=await this.ensureProviderTokenAndFunction(l.NN.Linear,"getLinearOrganizationFn",e?.accessToken);try{let e=await t.getLinearOrganizationFn?.({token:r});return e?.data}catch(e){return this.handleProviderError(l.NN.Linear,r,e)}}async getLinearTeamsForCurrentUser(e){let{provider:t,token:r}=await this.ensureProviderTokenAndFunction(l.NN.Linear,"getLinearTeamsForCurrentUserFn",e?.accessToken);try{return(await t.getLinearTeamsForCurrentUserFn?.({token:r}))?.data}catch(e){return this.handleProviderError(l.NN.Linear,r,e)}}async getAzureResourcesForUser(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(t,"getAzureResourcesForUserFn",r?.accessToken);try{return(await i.getAzureResourcesForUserFn?.({userId:e},{token:s,isPAT:r?.isPAT,baseUrl:r?.baseUrl}))?.data}catch(e){return this.handleProviderError(l.$r.AzureDevOps,s,e)}}async getBitbucketResourcesForUser(e,t){let{provider:r,token:i}=await this.ensureProviderTokenAndFunction(l.$r.Bitbucket,"getBitbucketResourcesForUserFn",t?.accessToken);try{return(await r.getBitbucketResourcesForUserFn?.({userId:e},{token:i}))?.data}catch(e){return this.handleProviderError(l.$r.Bitbucket,i,e)}}async getBitbucketPullRequestsAuthoredByUserForWorkspace(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(l.$r.Bitbucket,"getBitbucketPullRequestsAuthoredByUserForWorkspaceFn",r?.accessToken);try{return(await i.getBitbucketPullRequestsAuthoredByUserForWorkspaceFn?.({userId:e,workspaceSlug:t},{token:s}))?.data}catch(e){return this.handleProviderError(l.$r.Bitbucket,s,e)}}async getBitbucketServerPullRequestsForCurrentUser(e,t){let{provider:r,token:i}=await this.ensureProviderTokenAndFunction(l.RR.BitbucketServer,"getBitbucketServerPullRequestsForCurrentUserFn",t?.accessToken);try{return(await r.getBitbucketServerPullRequestsForCurrentUserFn?.({},{token:i,baseUrl:e}))?.data}catch(e){return this.handleProviderError(l.RR.BitbucketServer,i,e)}}async getJiraProjectsForResources(e,t){let{provider:r,token:i}=await this.ensureProviderTokenAndFunction(l.NN.Jira,"getJiraProjectsForResourcesFn",t?.accessToken);try{return(await r.getJiraProjectsForResourcesFn?.({resourceIds:e},{token:i}))?.data}catch(e){return this.handleProviderError(l.NN.Jira,i,e)}}async getAzureProjectsForResource(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(t,"getAzureProjectsForResourceFn",r?.accessToken),o=r?.isPAT?s:this.getAzurePATForOAuthToken(s);try{return await this.getPagedResult(i,{namespace:e,...r},i.getAzureProjectsForResourceFn,o,r?.cursor,r?.isPAT,r?.baseUrl)}catch(e){return this.handleProviderError(l.$r.AzureDevOps,s,e)}}async getReposForAzureProject(e,t,r,i){let{provider:s,token:o}=await this.ensureProviderTokenAndFunction(r,"getReposForAzureProjectFn",i?.accessToken);return this.getPagedResult(s,{namespace:e,project:t,...i},s.getReposForAzureProjectFn,o,i?.cursor,i?.isPAT,i?.baseUrl)}async getPullRequestsForRepos(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getPullRequestsForReposFn",r?.accessToken);return this.getPagedResult(i,{...this.isRepoIdsInput(t)?{repoIds:t}:{repos:t},...r},i.getPullRequestsForReposFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getPullRequestsForRepo(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getPullRequestsForRepoFn",r?.accessToken);return this.getPagedResult(i,{repo:t,...r},i.getPullRequestsForRepoFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getPullRequestsForUser(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getPullRequestsForUserFn",r?.accessToken);return this.getPagedResult(i,{...e===l.$r.Bitbucket?{userId:t}:{username:t},...r},i.getPullRequestsForUserFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getPullRequestsForAzureProjects(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(t,"getPullRequestsForAzureProjectsFn",r?.accessToken),o=r?.isPAT?s:this.getAzurePATForOAuthToken(s);try{return(await i.getPullRequestsForAzureProjectsFn?.({projects:e,...r},{token:o,isPAT:r?.isPAT,baseUrl:r?.baseUrl}))?.data}catch(e){return this.handleProviderError(l.$r.AzureDevOps,s,e)}}async mergePullRequest(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"mergePullRequestFn",r?.accessToken),o=t.refs?.head;if(null==o||i.id===l.$r.AzureDevOps&&null==t.project)return!1;try{return await i.mergePullRequestFn?.({pullRequest:{headRef:{oid:o.sha},id:t.id,number:Number.parseInt(t.id,10),repository:{id:t.repository.repo,name:t.repository.repo,project:t.project?.name??"",owner:{login:t.repository.owner}},version:t.version},...r},{token:s,isPAT:r?.isPAT,baseUrl:r?.baseUrl}),!0}catch(t){return this.handleProviderError(e,s,t)}}async getIssuesForRepos(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getIssuesForReposFn",r?.accessToken);return this.getPagedResult(i,{...this.isRepoIdsInput(t)?{repoIds:t}:{repos:t},...r},i.getIssuesForReposFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getIssuesForRepo(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getIssuesForRepoFn",r?.accessToken);return this.getPagedResult(i,{repo:t,...r},i.getIssuesForRepoFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getIssuesForCurrentUser(e,t){let{provider:r,token:i}=await this.ensureProviderTokenAndFunction(e,"getIssuesForCurrentUserFn",t?.accessToken);return this.getPagedResult(r,t,r.getIssuesForCurrentUserFn,i,t?.cursor??void 0,t?.isPAT,t?.baseUrl)}async getIssuesForAzureProject(e,t,r,i){let{provider:s,token:o}=await this.ensureProviderTokenAndFunction(e,"getIssuesForAzureProjectFn",i?.accessToken);return this.getPagedResult(s,{namespace:t,project:r,...i},s.getIssuesForAzureProjectFn,o,i?.cursor,i?.isPAT,i?.baseUrl)}async getIssuesForProject(e,t,r,i){let{provider:s,token:o}=await this.ensureProviderTokenAndFunction(e,"getIssuesForProjectFn",i?.accessToken);try{let e=await s.getIssuesForProjectFn?.({projectKey:t,resourceId:r,...i},{token:o});return e?.data}catch(t){return this.handleProviderError(e,o,t)}}async getIssuesForResourceForCurrentUser(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getIssuesForResourceForCurrentUserFn",r?.accessToken);return this.getPagedResult(i,{resourceId:t},i.getIssuesForResourceForCurrentUserFn,s,r?.cursor,r?.isPAT,r?.baseUrl)}async getIssue(e,t,r){let{provider:i,token:s}=await this.ensureProviderTokenAndFunction(e,"getIssueFn",r?.accessToken);try{let e=await i.getIssueFn?.(t,{token:s,isPAT:r?.isPAT,baseUrl:r?.baseUrl});return e?.data}catch(t){return this.handleProviderError(e,s,t)}}};async function h(e){let t=e.headers.get("content-type")||"",r=null;if(t.startsWith("application/json")){let t=await e.text();r=t.trim().length>0?JSON.parse(t):null}else if(t.startsWith("text/")||""===t)r=await e.text();else if(t.startsWith("application/vnd.github.raw+json"))r=await e.arrayBuffer();else throw Error(`Unsupported content-type: ${t}`);let i={body:r,headers:Object.fromEntries(e.headers.entries()),status:e.status,statusText:e.statusText};if(!e.ok){let t=Error(e.statusText);throw Object.assign(t,{response:i}),t}return i}},2078:(e,t,r)=>{r.r(t),r.d(t,{BitbucketAuthenticationProvider:()=>BitbucketAuthenticationProvider,BitbucketServerAuthenticationProvider:()=>BitbucketServerAuthenticationProvider});var i=r(4109),s=r(5460);let BitbucketAuthenticationProvider=class BitbucketAuthenticationProvider extends s.DP{get authProviderId(){return i.$r.Bitbucket}};let BitbucketServerAuthenticationProvider=class BitbucketServerAuthenticationProvider extends s.DP{get authProviderId(){return i.RR.BitbucketServer}}},2148:(e,t,r)=>{r.r(t),r.d(t,{GitLabApi:()=>GitLabApi});var i=r(1398),s=r(6096),o=r(2097),a=r(8412),n=r(99),u=r(8439),l=r(6402),c=r(6434),d=r(3481),h=r(9135),p=r(3582),g=r(9204),m=r(7609),f=Object.defineProperty,v=Object.getOwnPropertyDescriptor,y=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?v(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&f(t,r,o),o};let w="gid://gitlab/User/";function b(e){return"string"==typeof e&&e?.startsWith(w)?e.substring(w.length):String(e)}let GitLabApi=class GitLabApi{_disposable;_projectIds=new Map;constructor(e){this._disposable=l.H.onDidChangeAny(e=>{(l.H.changedCore(e,["http.proxy","http.proxyStrictSSL"])||l.H.changed(e,["proxy","remotes"]))&&this.resetCaches()})}dispose(){this._disposable.dispose()}resetCaches(){this._projectIds.clear(),this._proxyAgents.clear()}_proxyAgents=new Map;getProxyAgent(e){if(o.HZ)return;let t=this._proxyAgents.get(e.id);if(void 0===t){let r=e.getIgnoreSSLErrors();t=(0,s.cQ)(!0!==r&&"force"!==r&&void 0),this._proxyAgents.set(e.id,t??null)}return t??void 0}async getAccountForCommit(e,t,r,s,o,n,u){let l=(0,h.dQ)(),c=await this.getProjectId(e,t,r,s,n?.baseUrl,u);if(c)try{let r,s=await this.request(e,t,n?.baseUrl,`v4/projects/${c}/repository/commits/${o}?stats=false`,{method:"GET"},u,l);for(let i of(await this.findUser(e,t,s.author_name,n)))if(i.name===s.author_name||i.publicEmail&&i.publicEmail===s.author_email){if(r=i,"active"===i.state)break}else((0,g.Q_)(i.name,s.author_name)||i.publicEmail&&(0,g.Q_)(i.publicEmail,s.author_email))&&(r=i);if(null==r)return;return r.avatarUrl&&!/^([a-zA-Z][\w+.-]+):/.test(r.avatarUrl)&&(r.avatarUrl=i.Uri.joinPath(i.Uri.parse(r.webUrl),"..",r.avatarUrl).toString()),{provider:e,id:String(r.id),name:r.name||void 0,email:s.author_email||void 0,avatarUrl:r.avatarUrl||void 0,username:r.username||void 0}}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,l)}}async getAccountForEmail(e,t,r,i,s,o){let n=(0,h.dQ)();try{let[r]=await this.findUser(e,t,s,o);if(null==r)return;return{provider:e,id:String(r.id),name:r.name||void 0,email:r.publicEmail||void 0,avatarUrl:r.avatarUrl||void 0,username:r.username||void 0}}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,n)}}async getDefaultBranch(e,t,r,i,s,o){let n=(0,h.dQ)();try{let a=`query getDefaultBranch(
	$fullPath: ID!
) {
	project(fullPath: $fullPath) {
		repository {
			rootRef
		}
}`,u=await this.graphql(e,t,s?.baseUrl,a,{fullPath:`${r}/${i}`},o,n),l=u?.data?.project?.repository?.rootRef??void 0;if(null==l)return;return{provider:e,name:l}}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,n)}}async getIssueOrPullRequest(e,t,r,i,s,o,n){let u=(0,h.dQ)();try{let a=`query getIssueOrMergeRequest(
	$fullPath: ID!
	$iid: String!
) {
	project(fullPath: $fullPath) {
		mergeRequest(iid: $iid) {
			author {
				id
				name
				avatarUrl
				webUrl
			}
			iid
			title
			description
			state
			createdAt
			updatedAt
			mergedAt
			webUrl
		}
		issue(iid: $iid) {
			author {
				id
				name
				avatarUrl
				webUrl
			}
			iid
			title
			description
			state
			createdAt
			updatedAt
			closedAt
			webUrl
		}
	}
}`,l=await this.graphql(e,t,o?.baseUrl,a,{fullPath:`${r}/${i}`,iid:String(s)},n,u);if(l?.data?.project?.issue!=null){let t=l.data.project.issue;return{provider:e,type:"issue",id:t.iid,nodeId:void 0,createdDate:new Date(t.createdAt),updatedDate:new Date(t.updatedAt),title:t.title,closed:"closed"===t.state,closedDate:null==t.closedAt?void 0:new Date(t.closedAt),url:t.webUrl,state:"locked"===t.state?"closed":t.state}}if(l?.data?.project?.mergeRequest!=null){let t=l.data.project.mergeRequest;return{provider:e,type:"pullrequest",id:t.iid,nodeId:void 0,createdDate:new Date(t.createdAt),updatedDate:new Date(t.updatedAt),title:t.title,closed:"closed"===t.state,closedDate:"closed"===t.state?new Date(t.updatedAt):void 0,url:t.webUrl,state:"locked"===t.state?"closed":t.state}}return}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,u)}}async getPullRequestForBranch(e,t,r,i,s,o,u){let l=(0,h.dQ)();try{let a,c=`
			nodes {
				iid
				author {
					id
					name
					avatarUrl
					webUrl
				}
				title
				description
				state
				createdAt
				updatedAt
				mergedAt
				webUrl
			}`,d=`query getMergeRequestForBranch(
	$fullPath: ID!
	$branches: [String!]
) {
	project(fullPath: $fullPath) {
		${o?.include==null?`mergeRequests(sourceBranches: $branches sort: UPDATED_DESC first: 1) {
			${c}
		}`:""}
		${o?.include?.includes("opened")?`opened: mergeRequests(sourceBranches: $branches state: opened sort: UPDATED_DESC first: 1) {
			${c}
		}`:""}
		${o?.include?.includes("merged")?`merged: mergeRequests(sourceBranches: $branches state: merged sort: UPDATED_DESC first: 1) {
			${c}
		}`:""}
		${o?.include?.includes("closed")?`closed: mergeRequests(sourceBranches: $branches state: closed sort: UPDATED_DESC first: 1) {
			${c}
		}`:""}
	}
}`,h=await this.graphql(e,t,o?.baseUrl,d,{fullPath:`${r}/${i}`,branches:[s],state:o?.include},u,l);if(o?.include==null)a=h?.data?.project?.mergeRequests?.nodes?.[0];else for(let e of o.include){let t;"opened"===e?t=h?.data?.project?.opened?.nodes?.[0]:"merged"===e?t=h?.data?.project?.merged?.nodes?.[0]:"closed"===e&&(t=h?.data?.project?.closed?.nodes?.[0]),null!=t&&(null==a||new Date(t.updatedAt)>new Date(a.updatedAt))&&(a=t)}if(null==a)return;return new n.B9(e,{id:b(a.author?.id)??"",name:a.author?.name??"Unknown",avatarUrl:a.author?.avatarUrl??"",url:a.author?.webUrl??""},String(a.iid),void 0,a.title,a.webUrl,{owner:r,repo:i},(0,m.fromGitLabMergeRequestState)(a.state),new Date(a.createdAt),new Date(a.updatedAt),"closed"!==a.state?void 0:new Date(a.updatedAt),null==a.mergedAt?void 0:new Date(a.mergedAt))}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,l)}}async getPullRequestForCommit(e,t,r,i,s,o,n){let u=(0,h.dQ)(),l=await this.getProjectId(e,t,r,i,o?.baseUrl,n);if(l)try{let a=await this.request(e,t,o?.baseUrl,`v4/projects/${l}/repository/commits/${s}/merge_requests`,{method:"GET"},n,u);if(null==a||0===a.length)return;return a.length>1&&a.sort((e,t)=>("opened"===e.state?-1:1)-("opened"===t.state?-1:1)||new Date(t.updated_at).getTime()-new Date(e.updated_at).getTime()),(0,m.fromGitLabMergeRequestREST)(a[0],e,{owner:r,repo:i})}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,u)}}async getPullRequest(e,t,r,i,s,o,n){let u=(0,h.dQ)();try{let a=`query getMergeRequest(
	$fullPath: ID!
	$iid: String!
) {
	project(fullPath: $fullPath) {
		mergeRequest(iid: $iid) {
			id,
			iid
			state,
			author {
				id
				name
				avatarUrl
				webUrl
			}
			diffRefs {
				baseSha
				headSha
			}
			title
			description
			webUrl
			createdAt
			updatedAt
			mergedAt
			targetBranch
			sourceBranch
			project {
				id
				fullPath
				webUrl
			}
			sourceProject {
				id
				fullPath
				webUrl
			}
		}
	}
}`,l=await this.graphql(e,t,o?.baseUrl,a,{fullPath:`${r}/${i}`,iid:String(s)},n,u);if(l?.data?.project?.mergeRequest==null)return;let c=l.data.project.mergeRequest;return(0,m.fromGitLabMergeRequest)(c,e)}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,u)}}async getRepositoryMetadata(e,t,r,i,s,o){let n=(0,h.dQ)(),u=await this.getProjectId(e,t,r,i,s?.baseUrl,o);if(u)try{let r=await this.request(e,t,s?.baseUrl,`v4/projects/${u}`,{method:"GET"},o,n);if(null==r)return;return{provider:e,owner:r.namespace.full_path,name:r.path,isFork:null!=r.forked_from_project,parent:null!=r.forked_from_project?{owner:r.forked_from_project.namespace.full_path,name:r.forked_from_project.path}:void 0}}catch(t){if(t instanceof a.LN)return;throw this.handleException(t,e,n)}}async searchPullRequests(e,t,r,i){let s=(0,h.dQ)(),o=r?.search;if(!o)return[];try{let a=await this.request(e,t,r?.baseUrl,`v4/search/?scope=merge_requests&search=${o}&per_page=20`,{method:"GET"},i,s);if(0===a.length)return[];let n=a.map((e,t)=>`$id_${t}: MergeRequestID!`).join(`
`),u=a.map((e,t)=>`mergeRequest_${t}: mergeRequest(id: $id_${t}) { ...mergeRequestFields }`).join(`
`),l=`fragment mergeRequestFields on MergeRequest {
				diffRefs {
					baseSha
					headSha
				}
				project {
					id
					fullPath
					webUrl
				}
				sourceProject {
					id
					fullPath
					webUrl
				}
			}`,c=`query getMergeRequests (${n}) {${u}} ${l}`,d=a.reduce((e,t,r)=>(e[`id_${r}`]=`gid://gitlab/MergeRequest/${t.id}`,e),{}),h=await this.graphql(e,t,r?.baseUrl,c,d,i,s);if(h?.data!=null)return a.reduce((t,r,i)=>{let s=h.data[`mergeRequest_${i}`];if(null==s)return t;let o={...s,iid:String(r.iid),id:String(r.id),state:r.state,author:{id:b(r.author?.id)??"",name:r.author?.name??"Unknown",avatarUrl:r.author?.avatar_url??"",webUrl:r.author?.web_url??""},title:r.title,description:r.description,webUrl:r.web_url,createdAt:r.created_at,updatedAt:r.updated_at,mergedAt:r.merged_at,sourceBranch:r.source_branch,targetBranch:r.target_branch};return t.push((0,m.fromGitLabMergeRequest)(o,e)),t},[]);return[]}catch(t){if(t instanceof a.LN)return[];throw this.handleException(t,e,s)}}async findUser(e,t,r,i,s){let o=(0,h.dQ)();try{let a=`query findUser(
$search: String!
) {
	users(search: $search) {
		nodes {
			id
			name
			username,
			publicEmail,
			state
			avatarUrl
			webUrl
		}
	}
}`,n=await this.graphql(e,t,i?.baseUrl,a,{search:r},s,o),u=n?.data?.users?.nodes;if(null==u||0===u.length)return[];let l=[];for(let e of u){let t=/gid:\/\/gitlab\/User\/([0-9]+)\b/.exec(e.id);null!=t&&l.push({id:parseInt(t[1],10),name:e.name,username:e.username,publicEmail:e.publicEmail||void 0,state:e.state,avatarUrl:e.avatarUrl,webUrl:e.webUrl})}return l}catch(t){if(t instanceof a.LN)return[];return this.handleException(t,e,o),[]}}getProjectId(e,t,r,i,s,o){let a=`${t}|${r}/${i}`,n=this._projectIds.get(a);return null==n&&(n=this.getProjectIdCore(e,t,r,i,s,o),this._projectIds.set(a,n)),n}async getProjectIdCore(e,t,r,i,s,o){let n=(0,h.dQ)();try{let a=`query getProjectId(
	$fullPath: ID!
) {
	project(fullPath: $fullPath) {
		id
	}
}`,u=await this.graphql(e,t,s,a,{fullPath:`${r}/${i}`},o,n),l=u?.data?.project?.id;if(null==l)return;let c=/gid:\/\/gitlab\/Project\/([0-9]+)\b/.exec(l);if(null==c)return;let d=c[1];return(0,h.TT)(n,` \u2022 projectId=${d}`),d}catch(t){if(t instanceof a.LN)return;this.handleException(t,e,n);return}}async graphql(e,t,r,o,n,u,l){let c;try{let i=(0,p.u)(`[GITLAB] POST ${r}`,{log:!1}),l=this.getProxyAgent(e);try{let i;if(null!=u){if(u.isCancellationRequested)throw new a.AL;i=new AbortController,u.onCancellationRequested(()=>i.abort())}if((c=await (0,s.Ff)(e.getIgnoreSSLErrors(),()=>(0,s.hd)(`${r??"https://gitlab.com/api"}/graphql`,{method:"POST",headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},agent:l,signal:i?.signal,body:JSON.stringify({query:o,variables:n})}))).ok){let e=await c.json();if("errors"in e)throw new a.QI("GitLab",c,e.errors);return e}throw new a.QI("GitLab",c)}finally{let e=/(^[^({\n]+)/.exec(o),t=` ${e?.[1].trim()??o}`;i?.stop({message:t})}}catch(r){throw r instanceof a.QI||"AbortError"===r.name?this.handleRequestError(e,t,r,l):d.Vy.isDebugging&&i.window.showErrorMessage(`GitLab request failed: ${r.message}`),r}}async request(e,t,r,o,n,u,l){let c,h=`${r??"https://gitlab.com/api"}/${o}`;try{let r=(0,p.u)(`[GITLAB] ${n?.method??"GET"} ${h}`,{log:!1}),i=this.getProxyAgent(e);try{let r;if(null!=u){if(u.isCancellationRequested)throw new a.AL;r=new AbortController,u.onCancellationRequested(()=>r.abort())}if((c=await (0,s.Ff)(e.getIgnoreSSLErrors(),()=>(0,s.hd)(h,{headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},agent:i,signal:r?.signal,...n}))).ok)return await c.json();throw new a.QI("GitLab",c)}finally{r?.stop()}}catch(r){throw r instanceof a.QI||"AbortError"===r.name?this.handleRequestError(e,t,r,l):d.Vy.isDebugging&&i.window.showErrorMessage(`GitLab request failed: ${r.message}`),r}}handleRequestError(e,t,r,s){if("AbortError"===r.name||!(r instanceof a.QI))throw new a.AL(r);switch(r.status){case 404:case 410:case 422:throw new a.LN(r);case 401:throw new a.v3("gitlab",a.R.Unauthorized,r);case 403:if(r.message.includes("rate limit exceeded")){let e,i=r.response?.headers?.get("x-ratelimit-reset");throw null!=i&&Number.isNaN(e=parseInt(i,10))&&(e=void 0),new a.HG(r,t,e)}throw new a.v3("gitlab",a.R.Forbidden,r);case 500:d.Vy.error(r,s),null!=r.response&&(e?.trackRequestException(),(0,u.wW)(`${e?.name??"GitLab"} failed to respond and might be experiencing issues.${null==e||"gitlab"===e.id?" Please visit the [GitLab status page](https://status.gitlab.com) for more information.":""}`));return;case 502:if(d.Vy.error(r,s),r.message.includes("timeout")){e?.trackRequestException(),(0,u.lW)(e?.name??"GitLab");return}break;default:if(r.status>=400&&r.status<500)throw new a.tk(r)}d.Vy.error(r,s),d.Vy.isDebugging&&i.window.showErrorMessage(`GitLab request failed: ${r.response?.errors?.[0]?.message??r.message}`)}handleException(e,t,r){return d.Vy.error(e,r),e instanceof a.v3&&this.showAuthenticationErrorMessage(e,t),e}async showAuthenticationErrorMessage(e,t){if(e.reason===a.R.Unauthorized||e.reason===a.R.Forbidden){let r="Reauthenticate";await i.window.showErrorMessage(`${e.message}. Would you like to try reauthenticating${e.reason===a.R.Forbidden?" to provide additional access":""}?`,r)===r&&(await t.reauthenticate(),this.resetCaches())}else i.window.showErrorMessage(e.message)}};y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getAccountForCommit",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getAccountForEmail",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getDefaultBranch",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getIssueOrPullRequest",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getPullRequestForBranch",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getPullRequestForCommit",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getPullRequest",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"getRepositoryMetadata",1),y([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitLabApi.prototype,"searchPullRequests",1)},2496:(e,t,r)=>{function i(){return"object"==typeof navigator&&"userAgent"in navigator?navigator.userAgent:"object"==typeof process&&void 0!==process.version?`Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`:"<environment undetectable>"}r.r(t),r.d(t,{GitHubApi:()=>GitHubApi});var s=`octokit-endpoint.js/0.0.0-development ${i()}`;function o(e){for(let t in e)void 0===e[t]&&delete e[t];return e}function a(e,t,r){var i;if("string"==typeof t){let[e,i]=t.split(" ");r=Object.assign(i?{method:e,url:i}:{url:e},r)}else r=Object.assign({},t);r.headers=(i=r.headers)?Object.keys(i).reduce((e,t)=>(e[t.toLowerCase()]=i[t],e),{}):{},o(r),o(r.headers);let s=function e(t,r){let i=Object.assign({},t);return Object.keys(r).forEach(s=>{(function(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return!1;let t=Object.getPrototypeOf(e);if(null===t)return!0;let r=Object.prototype.hasOwnProperty.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&Function.prototype.call(r)===Function.prototype.call(e)})(r[s])&&s in t?i[s]=e(t[s],r[s]):Object.assign(i,{[s]:r[s]})}),i}(e||{},r);return"/graphql"===r.url&&(e&&e.mediaType.previews?.length&&(s.mediaType.previews=e.mediaType.previews.filter(e=>!s.mediaType.previews.includes(e)).concat(s.mediaType.previews)),s.mediaType.previews=(s.mediaType.previews||[]).map(e=>e.replace(/-preview/,""))),s}var n=/\{[^{}}]+\}/g;function u(e){return e.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g,"").split(/,/)}function l(e,t){let r={__proto__:null};for(let i of Object.keys(e))-1===t.indexOf(i)&&(r[i]=e[i]);return r}function c(e){return e.split(/(%[0-9A-Fa-f]{2})/g).map(function(e){return/%[0-9A-Fa-f]/.test(e)||(e=encodeURI(e).replace(/%5B/g,"[").replace(/%5D/g,"]")),e}).join("")}function d(e){return encodeURIComponent(e).replace(/[!'()*]/g,function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})}function h(e,t,r){return(t="+"===e||"#"===e?c(t):d(t),r)?d(r)+"="+t:t}function p(e){return null!=e}function g(e){return";"===e||"&"===e||"?"===e}function m(e,t){var r=["+","#",".","/",";","?","&"];return"/"===(e=e.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,function(e,i,s){if(!i)return c(s);{let e="",s=[];if(-1!==r.indexOf(i.charAt(0))&&(e=i.charAt(0),i=i.substr(1)),i.split(/,/g).forEach(function(r){var i=/([^:\*]*)(?::(\d+)|(\*))?/.exec(r);s.push(function(e,t,r,i){var s=e[r],o=[];if(p(s)&&""!==s)if("string"==typeof s||"number"==typeof s||"boolean"==typeof s)s=s.toString(),i&&"*"!==i&&(s=s.substring(0,parseInt(i,10))),o.push(h(t,s,g(t)?r:""));else if("*"===i)Array.isArray(s)?s.filter(p).forEach(function(e){o.push(h(t,e,g(t)?r:""))}):Object.keys(s).forEach(function(e){p(s[e])&&o.push(h(t,s[e],e))});else{let e=[];Array.isArray(s)?s.filter(p).forEach(function(r){e.push(h(t,r))}):Object.keys(s).forEach(function(r){p(s[r])&&(e.push(d(r)),e.push(h(t,s[r].toString())))}),g(t)?o.push(d(r)+"="+e.join(",")):0!==e.length&&o.push(e.join(","))}else";"===t?p(s)&&o.push(d(r)):""===s&&("&"===t||"?"===t)?o.push(d(r)+"="):""===s&&o.push("");return o}(t,e,i[1],i[2]||i[3]))}),!e||"+"===e)return s.join(",");var o=",";return"?"===e?o="&":"#"!==e&&(o=e),(0!==s.length?e:"")+s.join(o)}}))?e:e.replace(/\/$/,"")}function f(e){let t,r,i=e.method.toUpperCase(),s=(e.url||"/").replace(/:([a-z]\w+)/g,"{$1}"),o=Object.assign({},e.headers),a=l(e,["method","baseUrl","url","headers","request","mediaType"]),c=(t=s.match(n))?t.map(u).reduce((e,t)=>e.concat(t),[]):[];s=({expand:m.bind(null,s)}).expand(a),/^http/.test(s)||(s=e.baseUrl+s);let d=l(a,Object.keys(e).filter(e=>c.includes(e)).concat("baseUrl"));if(!/application\/octet-stream/i.test(o.accept)&&(e.mediaType.format&&(o.accept=o.accept.split(/,/).map(t=>t.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,`application/vnd$1$2.${e.mediaType.format}`)).join(",")),s.endsWith("/graphql")&&e.mediaType.previews?.length)){let t=o.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g)||[];o.accept=t.concat(e.mediaType.previews).map(t=>{let r=e.mediaType.format?`.${e.mediaType.format}`:"+json";return`application/vnd.github.${t}-preview${r}`}).join(",")}if(["GET","HEAD"].includes(i)){var h;let e,t;h=s,e=/\?/.test(h)?"&":"?",s=0===(t=Object.keys(d)).length?h:h+e+t.map(e=>"q"===e?"q="+d.q.split("+").map(encodeURIComponent).join("+"):`${e}=${encodeURIComponent(d[e])}`).join("&")}else"data"in d?r=d.data:Object.keys(d).length&&(r=d);return o["content-type"]||void 0===r||(o["content-type"]="application/json; charset=utf-8"),["PATCH","PUT"].includes(i)&&void 0===r&&(r=""),Object.assign({method:i,url:s,headers:o},void 0!==r?{body:r}:null,e.request?{request:e.request}:null)}function v(e,t,r){return f(a(e,t,r))}var y=function e(t,r){let i=a(t,r);return Object.assign(v.bind(null,i),{DEFAULTS:i,defaults:e.bind(null,i),merge:a.bind(null,i),parse:f})}(null,{method:"GET",baseUrl:"https://api.github.com",headers:{accept:"application/vnd.github.v3+json","user-agent":s},mediaType:{format:""}}),w=r(6411);let RequestError=class RequestError extends Error{name;status;request;response;constructor(e,t,r){super(e),this.name="HttpError",this.status=Number.parseInt(t),Number.isNaN(this.status)&&(this.status=0),"response"in r&&(this.response=r.response);const i=Object.assign({},r.request);r.request.headers.authorization&&(i.headers=Object.assign({},r.request.headers,{authorization:r.request.headers.authorization.replace(/(?<! ) .*$/," [REDACTED]")})),i.url=i.url.replace(/\bclient_secret=\w+/g,"client_secret=[REDACTED]").replace(/\baccess_token=\w+/g,"access_token=[REDACTED]"),this.request=i}};async function b(e){let t,r=e.request?.fetch||globalThis.fetch;if(!r)throw Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");let i=e.request?.log||console,s=e.request?.parseSuccessResponseBody!==!1,o=function(e){if("object"!=typeof e||null===e||"[object Object]"!==Object.prototype.toString.call(e))return!1;let t=Object.getPrototypeOf(e);if(null===t)return!0;let r=Object.prototype.hasOwnProperty.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&Function.prototype.call(r)===Function.prototype.call(e)}(e.body)||Array.isArray(e.body)?JSON.stringify(e.body):e.body,a=Object.fromEntries(Object.entries(e.headers).map(([e,t])=>[e,String(t)]));try{t=await r(e.url,{method:e.method,body:o,redirect:e.request?.redirect,headers:a,signal:e.request?.signal,...e.body&&{duplex:"half"}})}catch(i){let t="Unknown Error";if(i instanceof Error){if("AbortError"===i.name)throw i.status=500,i;t=i.message,"TypeError"===i.name&&"cause"in i&&(i.cause instanceof Error?t=i.cause.message:"string"==typeof i.cause&&(t=i.cause))}let r=new RequestError(t,500,{request:e});throw r.cause=i,r}let n=t.status,u=t.url,l={};for(let[e,r]of t.headers)l[e]=r;let c={url:u,status:n,headers:l,data:""};if("deprecation"in l){let t=l.link&&l.link.match(/<([^<>]+)>; rel="deprecation"/),r=t&&t.pop();i.warn(`[@octokit/request] "${e.method} ${e.url}" is deprecated. It is scheduled to be removed on ${l.sunset}${r?`. See ${r}`:""}`)}if(204===n||205===n)return c;if("HEAD"===e.method){if(n<400)return c;throw new RequestError(t.statusText,n,{response:c,request:e})}if(304===n)throw c.data=await R(t),new RequestError("Not modified",n,{response:c,request:e});if(n>=400)throw c.data=await R(t),new RequestError(function(e){if("string"==typeof e)return e;if(e instanceof ArrayBuffer)return"Unknown error";if("message"in e){let t="documentation_url"in e?` - ${e.documentation_url}`:"";return Array.isArray(e.errors)?`${e.message}: ${e.errors.map(e=>JSON.stringify(e)).join(", ")}${t}`:`${e.message}${t}`}return`Unknown error: ${JSON.stringify(e)}`}(c.data),n,{response:c,request:e});return c.data=s?await R(t):t.body,c}async function R(e){var t;let r=e.headers.get("content-type");if(!r)return e.text().catch(()=>"");let i=(0,w.xL)(r);if("application/json"===(t=i).type||"application/scim+json"===t.type){let t="";try{return t=await e.text(),JSON.parse(t)}catch{return t}}return i.type.startsWith("text/")||i.parameters.charset?.toLowerCase()==="utf-8"?e.text().catch(()=>""):e.arrayBuffer().catch(()=>new ArrayBuffer(0))}var P=function e(t,r){let i=t.defaults(r);return Object.assign(function(t,r){let s=i.merge(t,r);if(!s.request||!s.request.hook)return b(i.parse(s));let o=(e,t)=>b(i.parse(i.merge(e,t)));return Object.assign(o,{endpoint:i,defaults:e.bind(null,i)}),s.request.hook(o,s)},{endpoint:i,defaults:e.bind(null,i)})}(y,{headers:{"user-agent":`octokit-request.js/10.0.5 ${i()}`}}),$=class extends Error{constructor(e,t,r){super(`Request failed due to following response errors:
`+r.errors.map(e=>` - ${e.message}`).join(`
`)),this.request=e,this.headers=t,this.response=r,this.errors=r.errors,this.data=r.data,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}name="GraphqlResponseError";errors;data},C=["method","baseUrl","url","headers","request","query","mediaType","operationName"],A=["query","method","url"],F=/\/api\/v3\/?$/,q=function e(t,r){let i=t.defaults(r);return Object.assign((e,t)=>(function(e,t,r){if(r){if("string"==typeof t&&"query"in r)return Promise.reject(Error('[@octokit/graphql] "query" cannot be used as variable name'));for(let e in r)if(A.includes(e))return Promise.reject(Error(`[@octokit/graphql] "${e}" cannot be used as variable name`))}let i="string"==typeof t?Object.assign({query:t},r):t,s=Object.keys(i).reduce((e,t)=>(C.includes(t)?e[t]=i[t]:(e.variables||(e.variables={}),e.variables[t]=i[t]),e),{}),o=i.baseUrl||e.endpoint.DEFAULTS.baseUrl;return F.test(o)&&(s.url=o.replace(F,"/api/graphql")),e(s).then(e=>{if(e.data.errors){let t={};for(let r of Object.keys(e.headers))t[r]=e.headers[r];throw new $(s,t,e.data)}return e.data.data})})(i,e,t),{defaults:e.bind(null,i),endpoint:i.endpoint})}(P,{headers:{"user-agent":`octokit-graphql.js/0.0.0-development ${i()}`},method:"POST",url:"/graphql"}),S=r(1398),U=r(5369),k=r(6096),D=r(2097),I=r(8412),G=r(99),E=r(645),x=r(3790),T=r(8439),_=r(6402),O=r(6434),j=r(3991),B=r(3481),L=r(9135),z=r(3582),M=r(8993),H=r(8841),N=Object.defineProperty,Q=Object.getOwnPropertyDescriptor,V=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?Q(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&N(t,r,o),o};let Y=Object.freeze({values:[]}),W=Object.freeze({ranges:[]}),J=`
closed
closedAt
createdAt
id
number
state
title
updatedAt
url
`,K=`
${J}
author {
	login
	avatarUrl(size: $avatarSize)
	url
}
baseRefName
baseRefOid
headRefName
headRefOid
headRepository {
	name
	owner {
		login
	}
	url
}
isCrossRepository
isDraft
mergedAt
permalink
repository {
	isFork
	name
	owner {
		login
	}
	url
	viewerPermission
}
`,Z=`
${K}
additions
assignees(first: 10) {
	nodes {
		login
		avatarUrl(size: $avatarSize)
		url
	}
}
checksUrl
deletions
mergeable
mergedBy {
	login
}
reviewDecision
latestReviews(first: 10) {
	nodes {
		author {
			login
			avatarUrl(size: $avatarSize)
			url
		}
		state
	}
}
reviewRequests(first: 10) {
	nodes {
		asCodeOwner
		id
		requestedReviewer {
			... on User {
				login
				avatarUrl(size: $avatarSize)
				url
			}
		}
	}
}
commits(last: 1) {
	nodes {
		commit {
			statusCheckRollup {
				state
			}
		}
	}
}
totalCommentsCount
viewerCanUpdate
`,X=`
${J}
assignees(first: 100) {
	nodes {
		login
		url
		avatarUrl(size: $avatarSize)
	}
}
author {
	login
	avatarUrl
	url
}
comments {
	totalCount
}
labels(first: 20) {
	nodes {
		color
		name
	}
}
reactions(content: THUMBS_UP) {
	totalCount
}
repository {
	name
	owner {
		login
	}
	viewerPermission
	url
}
`;let GitHubApi=class GitHubApi{_onDidReauthenticate=new S.EventEmitter;get onDidReauthenticate(){return this._onDidReauthenticate.event}_disposable;constructor(e){this._disposable=S.Disposable.from(this._onDidReauthenticate,_.H.onDidChangeAny(e=>{(_.H.changedCore(e,["http.proxy","http.proxyStrictSSL"])||_.H.changed(e,["outputLevel","proxy"]))&&this.resetCaches()}))}dispose(){this._disposable.dispose()}resetCaches(){this._proxyAgent=null,this._defaults.clear(),this._enterpriseVersions.clear()}_proxyAgent=null;get proxyAgent(){if(!D.HZ)return null===this._proxyAgent&&(this._proxyAgent=(0,k.cQ)()),this._proxyAgent}async getCurrentAccount(e,t,r){let i=(0,L.dQ)();try{let s=`query getCurrentAccount($avatarSize: Int) {
	viewer {
		name
		email
		login
		avatarUrl(size: $avatarSize)
	}
}`,o=await this.graphql(e,t,s,{...r},i);if(o?.viewer?.login==null)return;return{provider:e,id:o.viewer.login,name:o.viewer.name??void 0,email:o.viewer.email??void 0,avatarUrl:!o.viewer.avatarUrl||ee(r)?o.viewer.avatarUrl??void 0:o.viewer.email&&r?.baseUrl!=null?await this.createEnterpriseAvatarUrl(e,t,r.baseUrl,o.viewer.email,r.avatarSize):void 0,username:o.viewer.login??void 0}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,i)}}async getAccountForCommit(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getAccountForCommit(
	$owner: String!
	$repo: String!
	$rev: GitObjectID!
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $rev) {
			... on Commit {
				author {
					name
					email
					avatarUrl(size: $avatarSize)
					user {
						login
					}
				}
			}
		}
	}
}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,rev:s},a),l=u?.repository?.object?.author;if(null==l)return;return{provider:e,...l?.user?.login!=null?{id:l.user.login,username:l.user.login}:{id:void 0,username:void 0},name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||ee(o)?l.avatarUrl??void 0:l.email&&o?.baseUrl!=null?await this.createEnterpriseAvatarUrl(e,t,o.baseUrl,l.email,o.avatarSize):void 0}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getAccountForEmail(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getAccountForEmail(
	$emailQuery: String!
	$avatarSize: Int
) {
	search(type: USER, query: $emailQuery, first: 1) {
		nodes {
			... on User {
				name
				email
				avatarUrl(size: $avatarSize)
				login
			}
		}
	}
}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,emailQuery:`in:email ${s}`},a),l=u?.search?.nodes?.[0];if(l?.login==null)return;return{provider:e,id:l.login,name:l.name??void 0,email:l.email??void 0,avatarUrl:!l.avatarUrl||ee(o)?l.avatarUrl??void 0:l.email&&o?.baseUrl!=null?await this.createEnterpriseAvatarUrl(e,t,o.baseUrl,l.email,o.avatarSize):void 0,username:l.login??void 0}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getDefaultBranch(e,t,r,i,s){let o=(0,L.dQ)();try{let a=`query getDefaultBranch(
	$owner: String!
	$repo: String!
) {
	repository(name: $repo, owner: $owner) {
		defaultBranchRef {
			name
		}
	}
}`,n=await this.graphql(e,t,a,{...s,owner:r,repo:i},o),u=n?.repository?.defaultBranchRef?.name??void 0;if(null==u)return;return{provider:e,name:u}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,o)}}async getIssueOrPullRequest(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getIssueOrPullRequest(
	$owner: String!
	$repo: String!
	$number: Int!
) {
	repository(name: $repo, owner: $owner) {
		issueOrPullRequest(number: $number) {
			__typename
			... on Issue {
				${J}
			}
			... on PullRequest {
				${J}
			}
		}
	}
}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,number:s},a),l=u?.repository?.issueOrPullRequest;if(null==l)return;return{provider:e,type:"PullRequest"===l.__typename?"pullrequest":"issue",id:String(l.number),nodeId:l.id,createdDate:new Date(l.createdAt),updatedDate:new Date(l.updatedAt),title:l.title,closed:l.closed,closedDate:null==l.closedAt?void 0:new Date(l.closedAt),url:l.url,state:(0,H.fromGitHubIssueOrPullRequestState)(l.state)}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getIssue(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getIssue(
			$owner: String!
			$repo: String!
			$number: Int!
			$avatarSize: Int
		) {
			repository(name: $repo, owner: $owner) {
				issue(number: $number) {
					${X}${o?.includeBody?`
						body
						`:""}
				}
			}
		}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,number:s},a);if(u?.repository?.issue==null)return;return(0,H.fromGitHubIssue)(u.repository.issue,e)}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getPullRequest(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getPullRequest(
	$owner: String!
	$repo: String!
	$number: Int!
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		pullRequest(number: $number) {
			${Z}
		}
	}
}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,number:s},a);if(u?.repository?.pullRequest==null)return;return(0,H.fromGitHubPullRequestLite)(u.repository.pullRequest,e)}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getPullRequestForBranch(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getPullRequestForBranch(
	$owner: String!
	$repo: String!
	$branch: String!
	$limit: Int!
	$include: [PullRequestState!]
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		ref(qualifiedName: $branch) {
			associatedPullRequests(first: $limit, orderBy: {field: UPDATED_AT, direction: DESC}, states: $include) {
				nodes {
					${K}
				}
			}
		}
	}
}`,u=await this.graphql(e,t,n,{...o,owner:r,repo:i,branch:`refs/heads/${s}`,limit:10},a),l=u?.repository?.ref?.associatedPullRequests?.nodes?.filter(e=>null!=e&&(!e.repository.isFork||e.repository.owner.login===r));if(null==l||0===l.length)return;return l.length>1&&l.sort((e,t)=>(e.repository.owner.login===r?-1:1)-(t.repository.owner.login===r?-1:1)||("OPEN"===e.state?-1:1)-("OPEN"===t.state?-1:1)||new Date(t.updatedAt).getTime()-new Date(e.updatedAt).getTime()),(0,H.fromGitHubPullRequestLite)(l[0],e)}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getPullRequestForCommit(e,t,r,i,s,o,a){let n=(0,L.dQ)();try{let u=`query getPullRequestForCommit(
	$owner: String!
	$repo: String!
	$rev: GitObjectID!
	$avatarSize: Int
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $rev) {
			... on Commit {
				associatedPullRequests(first: 2, orderBy: {field: UPDATED_AT, direction: DESC}) {
					nodes {
						${K}
					}
				}
			}
		}
	}
}`,l=await this.graphql(e,t,u,{...o,owner:r,repo:i,rev:s},n,a),c=l?.repository?.object?.associatedPullRequests?.nodes?.filter(e=>null!=e&&(!e.repository.isFork||e.repository.owner.login===r));if(null==c||0===c.length)return;return c.length>1&&c.sort((e,t)=>(e.repository.owner.login===r?-1:1)-(t.repository.owner.login===r?-1:1)||("MERGED"===e.state?-1:1)-("MERGED"===t.state?-1:1)||new Date(t.updatedAt).getTime()-new Date(e.updatedAt).getTime()),(0,H.fromGitHubPullRequestLite)(c[0],e)}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,n)}}async getRepositoryMetadata(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getRepositoryMetadata(
	$owner: String!
	$repo: String!
) {
	repository(name: $repo, owner: $owner) {
		owner {
			login
		}
		name
		parent {
			owner {
				login
			}
			name
		}
	}
}`,u=await this.graphql(e,t,n,{...s,owner:r,repo:i},a,o),l=u?.repository??void 0;if(null==l)return;return{provider:e,owner:l.owner.login,name:l.name,isFork:null!=l.parent,parent:null!=l.parent?{owner:l.parent.owner.login,name:l.parent.name}:void 0}}catch(t){if(t instanceof I.LN)return;throw this.handleException(t,e,a)}}async getBlame(e,t,r,i,s){let o=(0,L.dQ)();try{let a=`query getBlameRanges(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String!
) {
	viewer { name }
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			...on Commit {
				blame(path: $path) {
					ranges {
						startingLine
						endingLine
						commit {
							oid
							parents(first: 3) { nodes { oid } }
							message
							additions
							changedFiles
							deletions
							author {
								avatarUrl
								date
								email
								name
							}
							committer {
								date
								email
								name
							}
						}
					}
				}
			}
		}
	}
}`,n=await this.graphql(void 0,e,a,{owner:t,repo:r,ref:i,path:s},o);if(null==n)return W;let u=n.repository?.object?.blame?.ranges;if(null==u||0===u.length)return{ranges:[],viewer:n.viewer?.name};return{ranges:u,viewer:n.viewer?.name}}catch(e){if(e instanceof I.LN)return W;throw this.handleException(e,void 0,o)}}async getBranches(e,t,r,i){let s=(0,L.dQ)();try{let o=`query getBranches(
	$owner: String!
	$repo: String!
	$branchQuery: String
	$cursor: String
	$limit: Int = 100
) {
	repository(owner: $owner, name: $repo) {
		refs(query: $branchQuery, refPrefix: "refs/heads/", first: $limit, after: $cursor) {
			pageInfo {
				endCursor
				hasNextPage
			}
			nodes {
				name
				target {
					oid
					...on Commit {
						authoredDate
						committedDate
					}
				}
			}
		}
	}
}`,a=await this.graphql(void 0,e,o,{owner:t,repo:r,branchQuery:i?.query,cursor:i?.cursor,limit:Math.min(100,i?.limit??100)},s);if(null==a)return Y;let n=a.repository?.refs;if(null==n)return Y;return{paging:{cursor:n.pageInfo.endCursor,more:n.pageInfo.hasNextPage},values:n.nodes}}catch(e){if(e instanceof I.LN)return Y;throw this.handleException(e,void 0,s)}}async getCommit(e,t,r,i){let s=(0,L.dQ)();try{let o=await this.request(void 0,e,"GET /repos/{owner}/{repo}/commits/{ref}",{owner:t,repo:r,ref:i},s),a=o?.data;if(null==a)return;let{commit:n}=a;return{oid:a.sha,parents:{nodes:a.parents.map(e=>({oid:e.sha}))},message:n.message,additions:a.stats?.additions,changedFiles:a.files?.length,deletions:a.stats?.deletions,author:{avatarUrl:a.author?.avatar_url??void 0,date:n.author?.date??new Date().toString(),email:n.author?.email??void 0,name:n.author?.name??""},committer:{date:n.committer?.date??new Date().toString(),email:n.committer?.email??void 0,name:n.committer?.name??""},files:a.files}}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,s)}}async getCommitForFile(e,t,r,i,s){if((0,x.HH)(i))return this.getCommit(e,t,r,i);let o=await this.getCommits(e,t,r,i,{limit:1,path:s});if(0!==o.values.length)return{...await this.getCommit(e,t,r,o.values[0].oid)??o.values[0],viewer:o.viewer}}async getBranchesWithCommits(e,t,r,i,s,o){let a=(0,L.dQ)();try{let n=`query getBranchesWithCommits(
	$owner: String!
	$repo: String!
	$since: GitTimestamp!
	$until: GitTimestamp!
) {
	repository(owner: $owner, name: $repo) {
		refs(first: 20, refPrefix: "refs/heads/") {
			nodes {
				name
				target {
					... on Commit {
						history(first: ${"contains"===s?10:1}, since: $since until: $until) {
							nodes { oid }
						}
					}
				}
			}
		}
	}
}`,u=await this.graphql(void 0,e,n,{owner:t,repo:r,since:o?.toISOString(),until:o?.toISOString()},a),l=u?.repository?.refs?.nodes;if(null==l)return[];let c=[];for(let e of l)for(let t of e.target.history.nodes)if(i.includes(t.oid)){c.push(e.name);break}return c}catch(e){if(e instanceof I.LN)return[];throw this.handleException(e,void 0,a)}}async getCommitCount(e,t,r,i){let s=(0,L.dQ)();try{let o=`query getCommitCount(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	repository(owner: $owner, name: $repo) {
		ref(qualifiedName: $ref) {
			target {
				... on Commit {
					history(first: 1) {
						totalCount
					}
				}
			}
		}
	}
}`,a=await this.graphql(void 0,e,o,{owner:t,repo:r,ref:i},s);return a?.repository?.ref?.target.history.totalCount}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,s)}}async getBranchWithCommit(e,t,r,i,s,o,a){let n=(0,L.dQ)();try{let u=`query getBranchWithCommit(
	$owner: String!
	$repo: String!
	$ref: String!
	$since: GitTimestamp!
	$until: GitTimestamp!
) {
	repository(owner: $owner, name: $repo) {
		ref(qualifiedName: $ref) {
			target {
				... on Commit {
					history(first: ${"contains"===o?100:1}, since: $since until: $until) {
						nodes { oid }
					}
				}
			}
		}
	}
}`,l=await this.graphql(void 0,e,u,{owner:t,repo:r,ref:`refs/heads/${i}`,since:a?.toISOString(),until:a?.toISOString()},n),c=l?.repository?.ref.target.history.nodes;if(null==c)return[];let d=[];for(let e of c)if(s.includes(e.oid)){d.push(i);break}return d}catch(e){if(e instanceof I.LN)return[];throw this.handleException(e,void 0,n)}}async getCommits(e,t,r,i,s){let o=(0,L.dQ)();if(s?.limit===1&&s?.path==null)return this.getCommitsCoreSingle(e,t,r,i);if((0,x.p8)(i))return this.getCommitsCoreRange(e,t,r,i);try{let a,n=`query getCommits(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String
	$author: CommitAuthor
	$after: String
	$before: String
	$limit: Int = 100
	$since: GitTimestamp
	$until: GitTimestamp
) {
	viewer { name }
	repository(name: $repo, owner: $owner) {
		object(expression: $ref) {
			... on Commit {
				history(first: $limit, author: $author, path: $path, after: $after, before: $before, since: $since, until: $until) {
					pageInfo {
						startCursor
						endCursor
						hasNextPage
						hasPreviousPage
					}
					nodes {
						... on Commit {
							oid
							message
							parents(first: 3) { nodes { oid } }
							additions
							changedFiles
							deletions
							author {
								avatarUrl
								date
								email
								name
							}
							committer {
								 date
								 email
								 name
							 }
						}
					}
				}
			}
		}
	}
}`;if(s?.authors!=null)if(1===s.authors.length){let[e]=s.authors;a={id:e.id,emails:e.email?[e.email]:void 0}}else{let e=s.authors.filter(e=>e.email).map(e=>e.email);a=e.length?{emails:e}:void 0}let u=await this.graphql(void 0,e,n,{owner:t,repo:r,ref:i,after:s?.after,before:s?.before,path:s?.path,author:a,limit:Math.min(100,s?.limit??100),since:"string"==typeof s?.since?s?.since:s?.since?.toISOString(),until:"string"==typeof s?.until?s?.until:s?.until?.toISOString()},o),l=u?.repository?.object?.history;if(null==l)return Y;return{paging:null!=l.pageInfo.endCursor?{cursor:l.pageInfo.endCursor??void 0,more:l.pageInfo.hasNextPage}:void 0,values:l.nodes,viewer:u?.viewer.name}}catch(e){if(e instanceof I.LN)return Y;throw this.handleException(e,void 0,o)}}async getCommitsCoreRange(e,t,r,i){let s=(0,L.dQ)();try{let s=await this.getComparison(e,t,r,i);if(null==s)return Y;return{values:s.commits?.map(e=>({oid:e.sha,parents:{nodes:e.parents.map(e=>({oid:e.sha}))},message:e.commit.message,author:{avatarUrl:e.author?.avatar_url??void 0,date:e.commit.author?.date??e.commit.author?.date??new Date().toString(),email:e.author?.email??e.commit.author?.email??void 0,name:e.author?.name??e.commit.author?.name??""},committer:{date:e.commit.committer?.date??new Date().toString(),email:e.committer?.email??e.commit.committer?.email??void 0,name:e.committer?.name??e.commit.committer?.name??""}})).reverse()}}catch(e){if(e instanceof I.LN)return Y;throw this.handleException(e,void 0,s)}}async getCommitsCoreSingle(e,t,r,i){let s=(0,L.dQ)();try{let o=`query getCommit(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	viewer { name }
	repository(name: $repo owner: $owner) {
		object(expression: $ref) {
			...on Commit {
				oid
				parents(first: 3) { nodes { oid } }
				message
				additions
				changedFiles
				deletions
				author {
					avatarUrl
					date
					email
					name
				}
				committer {
					date
					email
					name
				}
			}
		}
	}
}`,a=await this.graphql(void 0,e,o,{owner:t,repo:r,ref:i},s);if(null==a)return Y;let n=a.repository?.object;return null!=n?{values:[n],viewer:a.viewer.name}:Y}catch(e){if(e instanceof I.LN)return Y;throw this.handleException(e,void 0,s)}}async getCommitRefs(e,t,r,i,s){let o=(0,L.dQ)();try{let a=`query getCommitRefs(
	$owner: String!
	$repo: String!
	$ref: String!
	$after: String
	$before: String
	$first: Int
	$last: Int
	$path: String
	$since: GitTimestamp
	$until: GitTimestamp
) {
	repository(name: $repo, owner: $owner) {
		object(expression: $ref) {
			... on Commit {
				history(first: $first, last: $last, path: $path, since: $since, until: $until, after: $after, before: $before) {
					pageInfo { startCursor, endCursor, hasNextPage, hasPreviousPage }
					totalCount
					nodes { oid }
				}
			}
		}
	}
}`,n=await this.graphql(void 0,e,a,{owner:t,repo:r,ref:i,path:s?.path,first:s?.first,last:s?.last,after:s?.after,before:s?.before,since:s?.since,until:s?.until},o),u=n?.repository?.object?.history;if(null==u)return;return{pageInfo:u.pageInfo,totalCount:u.totalCount,values:u.nodes}}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,o)}}async getTagsWithCommit(e,t,r,i,s){let o=(0,L.dQ)();try{let a=`query getTagsWithCommit(
	$owner: String!
	$repo: String!
	$since: GitTimestamp!
	$until: GitTimestamp!
) {
	repository(owner: $owner, name: $repo) {
		refs(first: 20, refPrefix: "refs/tags/") {
			nodes {
				name
				target {
					... on Commit {
						history(first: 3, since: $since until: $until) {
							nodes { oid }
						}
					}
				}
			}
		}
	}
}`,n=await this.graphql(void 0,e,a,{owner:t,repo:r,since:s.toISOString(),until:s.toISOString()},o),u=n?.repository?.refs?.nodes;if(null==u)return[];let l=[];for(let e of u)for(let t of e.target.history.nodes)if(t.oid===i){l.push(e.name);break}return l}catch(e){if(e instanceof I.LN)return[];throw this.handleException(e,void 0,o)}}async getNextCommitRefs(e,t,r,i,s,o){let a,n=await this.getCommitDate(e,t,r,o);if(null==n)return[];let u=await this.getCommitRefs(e,t,r,i,{path:s,first:1,since:n});if(null==u)return[];let l=`${u.pageInfo.startCursor.split(" ",1)[0]} ${u.totalCount}`;if([,a]=l.split(" ",2),a=Math.min(parseInt(a,10),5),null==(u=await this.getCommitRefs(e,t,r,i,{path:s,last:a,before:l})))return[];let c=[];for(let{oid:e}of u.values){if(e===o)break;c.push(e)}return c.reverse()}async getCommitDate(e,t,r,i){let s=(0,L.dQ)();try{let o=`query getCommitDate(
	$owner: String!
	$repo: String!
	$sha: GitObjectID!
) {
	repository(name: $repo, owner: $owner) {
		object(oid: $sha) {
			... on Commit { committer { date } }
		}
	}
}`,a=await this.graphql(void 0,e,o,{owner:t,repo:r,sha:i},s);return a?.repository?.object?.committer.date}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,s)}}async getContributors(e,t,r){let i=(0,L.dQ)();try{let s=await this.request(void 0,e,"GET /repos/{owner}/{repo}/contributors",{owner:t,repo:r,per_page:100},i),o=s?.data;if(null==o)return[];return s.data}catch(e){if(e instanceof I.LN)return[];throw this.handleException(e,void 0,i)}}async getDefaultBranchName(e,t,r){let i=(0,L.dQ)();try{let s=`query getDefaultBranch(
	$owner: String!
	$repo: String!
) {
	repository(owner: $owner, name: $repo) {
		defaultBranchRef {
			name
		}
	}
}`,o=await this.graphql(void 0,e,s,{owner:t,repo:r},i);if(null==o)return;return o.repository?.defaultBranchRef?.name??void 0}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,i)}}async getCurrentUser(e,t,r){let i=(0,L.dQ)();try{let s=`query getCurrentUser(
	$owner: String!
	$repo: String!
) {
	viewer { name, email, login, id }
	repository(owner: $owner, name: $repo) { viewerPermission }
}`,o=await this.graphql(void 0,e,s,{owner:t,repo:r},i);if(null==o)return;return{name:o.viewer?.name,email:o.viewer?.email,username:o.viewer?.login,id:o.viewer?.id}}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,i)}}async getComparison(e,t,r,i){let s=(0,L.dQ)();if(!(0,x.p8)(i,"qualified-triple-dot")){let e=(0,x.jY)(i);i=(0,x.Xn)(e?.left||"HEAD",e?.right||"HEAD","...")}try{let o=await this.request(void 0,e,"GET /repos/{owner}/{repo}/compare/{basehead}",{owner:t,repo:r,basehead:i},s),a=o?.data;if(null==a)return;return a}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,s)}}async getRepositoryVisibility(e,t,r){let i=(0,L.dQ)();try{let s=`query getRepositoryVisibility(
	$owner: String!
	$repo: String!
) {
	repository(owner: $owner, name: $repo) {
		visibility
	}
}`,o=await this.graphql(void 0,e,s,{owner:t,repo:r},i);if(o?.repository?.visibility==null)return;return"PUBLIC"===o.repository.visibility?"public":"private"}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,i)}}async getTags(e,t,r,i){let s=(0,L.dQ)();try{let o=`query getTags(
	$owner: String!
	$repo: String!
	$tagQuery: String
	$cursor: String
	$limit: Int = 100
) {
	repository(owner: $owner, name: $repo) {
		refs(query: $tagQuery, refPrefix: "refs/tags/", first: $limit, after: $cursor, orderBy: { field: TAG_COMMIT_DATE, direction: DESC }) {
			pageInfo {
				endCursor
				hasNextPage
			}
			nodes {
				name
				target {
					oid
					...on Tag {
						message
						tagger { date }
						target {
					...on Commit {
								oid
						authoredDate
						committedDate
						message
					}
						}
					}
				}
			}
		}
	}
}`,a=await this.graphql(void 0,e,o,{owner:t,repo:r,tagQuery:i?.query,cursor:i?.cursor,limit:Math.min(100,i?.limit??100)},s);if(null==a)return Y;let n=a.repository?.refs;if(null==n)return Y;return{paging:{cursor:n.pageInfo.endCursor,more:n.pageInfo.hasNextPage},values:n.nodes}}catch(e){if(e instanceof I.LN)return Y;throw this.handleException(e,void 0,s)}}async resolveReference(e,t,r,i,s){let o=(0,L.dQ)();try{if(!s){let s=`query resolveReference(
	$owner: String!
	$repo: String!
	$ref: String!
) {
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			oid
		}
	}
}`,a=await this.graphql(void 0,e,s,{owner:t,repo:r,ref:i},o);return a?.repository?.object?.oid??void 0}let a=`query resolveReference(
	$owner: String!
	$repo: String!
	$ref: String!
	$path: String!
) {
	repository(owner: $owner, name: $repo) {
		object(expression: $ref) {
			... on Commit {
				history(first: 1, path: $path) {
					nodes { oid }
				}
			}
		}
	}
}`,n=await this.graphql(void 0,e,a,{owner:t,repo:r,ref:i,path:s},o);return n?.repository?.object?.history.nodes?.[0]?.oid??void 0}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,o)}}async searchCommits(e,t,r){let i,s,o,a=(0,L.dQ)(),n=Math.min(100,r?.limit??100);r?.cursor!=null?([i,s,o]=r.cursor.split(" ",3),i=parseInt(i,10),s=parseInt(s,10),o=parseInt(o,10)):(i=1,s=n,o=0);try{let n=await this.request(void 0,e,"GET /search/commits",{q:t,sort:r?.sort,order:r?.order,per_page:s,page:i},a),u=n?.data;if(null==u||0===u.items.length)return;let l=u.items.map(e=>({oid:e.sha,parents:{nodes:e.parents.map(e=>({oid:e.sha}))},message:e.commit.message,author:{avatarUrl:e.author?.avatar_url??void 0,date:e.commit.author?.date??e.commit.author?.date??new Date().toString(),email:e.author?.email??e.commit.author?.email??void 0,name:e.author?.name??e.commit.author?.name??""},committer:{date:e.commit.committer?.date??e.committer?.date??new Date().toString(),email:e.committer?.email??e.commit.committer?.email??void 0,name:e.committer?.name??e.commit.committer?.name??""}})),c=o+u.items.length,d=u.incomplete_results||u.total_count>c;return{pageInfo:{startCursor:`${i} ${s} ${o}`,endCursor:d?`${i+1} ${s} ${c}`:void 0,hasPreviousPage:u.total_count>0&&i>1,hasNextPage:d},totalCount:u.total_count,values:l}}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,a)}}async searchCommitShas(e,t,r){let i,s,o,a=(0,L.dQ)(),n=Math.min(100,r?.limit??100);r?.cursor!=null?([i,s,o]=r.cursor.split(" ",3),i=parseInt(i,10),s=parseInt(s,10),o=parseInt(o,10)):(i=1,s=n,o=0);try{let n=await this.request(void 0,e,"GET /search/commits",{q:t,sort:r?.sort,order:r?.order,per_page:s,page:i},a),u=n?.data;if(null==u||0===u.items.length)return;let l=o+u.items.length,c=u.incomplete_results||u.total_count>l;return{pageInfo:{startCursor:`${i} ${s} ${o}`,endCursor:c?`${i+1} ${s} ${l}`:void 0,hasPreviousPage:u.total_count>0&&i>1,hasNextPage:c},totalCount:u.total_count,values:u.items.map(e=>({sha:e.sha,authorDate:new Date(e.commit.author.date).getTime(),committerDate:new Date(e.commit.committer?.date??e.commit.author.date).getTime()}))}}catch(e){if(e instanceof I.LN)return;throw this.handleException(e,void 0,a)}}_enterpriseVersions=new Map;async getEnterpriseVersion(e,t,r){let i=this._enterpriseVersions.get(t);if(null!=i)return i;if(null===i)return;let s=(0,L.dQ)();try{let o=await this.request(e,t,"GET /meta",r,s),a=o?.data?.installed_version;i=a?(0,M.sH)(a):null}catch{i=null}return this._enterpriseVersions.set(t,i),i??void 0}async graphql(e,t,r,i,s,o){try{let s;if(null!=o){if(o.isCancellationRequested)throw new I.AL;s=new AbortController,o.onCancellationRequested(()=>s.abort()),i={...i,request:{...i?.request,signal:s.signal}}}return await (0,k.Ff)(e?.getIgnoreSSLErrors()??!1,()=>this.getDefaults(t,q)(r,i))}catch(r){if(r instanceof $){switch(r.errors?.[0]?.type){case"NOT_FOUND":throw new I.LN(r);case"FORBIDDEN":throw new I.v3("github",I.R.Forbidden,r);case"RATE_LIMITED":{let e,i=r.headers?.["x-ratelimit-reset"];throw null!=i&&Number.isNaN(e=parseInt(i,10))&&(e=void 0),new I.HG(r,t,e)}}B.Vy.isDebugging&&S.window.showErrorMessage(`GitHub request failed: ${r.errors?.[0]?.message??r.message}`)}else r instanceof RequestError||"AbortError"===r.name?this.handleRequestError(e,t,r,s):B.Vy.isDebugging&&S.window.showErrorMessage(`GitHub request failed: ${r.message}`);throw r}}async request(e,t,r,i,s,o){try{let s;if(null!=o){if(o.isCancellationRequested)throw new I.AL;s=new AbortController,o.onCancellationRequested(()=>s.abort()),i={...i,request:{...i?.request,signal:s.signal}}}return await (0,k.Ff)(e?.getIgnoreSSLErrors()??!1,()=>this.getDefaults(t,P)(r,i))}catch(r){throw r instanceof RequestError||"AbortError"===r.name?this.handleRequestError(e,t,r,s):B.Vy.isDebugging&&S.window.showErrorMessage(`GitHub request failed: ${r.message}`),r}}_defaults=new Map;getDefaults(e,t){let r=this._defaults.get(t);null==r&&(r=new Map,this._defaults.set(t,r));let i=r.get(e);return null==i&&(i=t.defaults({headers:{authorization:`token ${e}`},request:{agent:this.proxyAgent,fetch:D.HZ?(e,t)=>{if(null!=t.headers){let{"user-agent":e,...r}=t.headers;e&&(t.headers=r)}return(0,k.hd)(e,t)}:k.hd,hook:"debug"===B.Vy.logLevel||B.Vy.isDebugging?async(e,t)=>{let r=(0,z.u)(`[GITHUB] ${t.method} ${t.url}`,{log:!1});try{return await e(t)}finally{let e;try{if("string"==typeof t.query){let r=/(^[^({\n]+)/.exec(t.query);e=` ${r?.[1].trim()??t.query}`}}catch{}r?.stop({message:e})}}:void 0}}),r.set(e,i)),i}handleRequestError(e,t,r,i){if("AbortError"===r.name)throw new I.AL(r);switch(r.status){case 404:case 410:case 422:throw new I.LN(r);case 401:throw new I.v3("github",I.R.Unauthorized,r);case 403:if(r.message.includes("rate limit")){let e,i=r.response?.headers?.["x-ratelimit-reset"];throw null!=i&&Number.isNaN(e=parseInt(i,10))&&(e=void 0),new I.HG(r,t,e)}throw new I.v3("github",I.R.Forbidden,r);case 500:B.Vy.error(r,i),null!=r.response&&(e?.trackRequestException(),(0,T.wW)(`${e?.name??"GitHub"} failed to respond and might be experiencing issues.${null==e||"github"===e.id?" Please visit the [GitHub status page](https://githubstatus.com) for more information.":""}`));return;case 502:if(B.Vy.error(r,i),r.message.includes("timeout")){e?.trackRequestException(),(0,T.lW)(e?.name??"GitHub");return}break;case 503:B.Vy.error(r,i),e?.trackRequestException(),(0,T.wW)(`${e?.name??"GitHub"} failed to respond and might be experiencing issues.${null==e||"github"===e.id?" Please visit the [GitHub status page](https://githubstatus.com) for more information.":""}`);return;default:if(r.status>=400&&r.status<500)throw new I.tk(r)}B.Vy.error(r,i),B.Vy.isDebugging&&S.window.showErrorMessage(`GitHub request failed: ${r.response?.errors?.[0]?.message??r.message}`)}handleException(e,t,r,i){return B.Vy.error(e,r),e instanceof I.v3&&!i&&this.showAuthenticationErrorMessage(e,t),e}async showAuthenticationErrorMessage(e,t){if(e.reason===I.R.Unauthorized||e.reason===I.R.Forbidden){let r="Reauthenticate";await S.window.showErrorMessage(`${e.message}. Would you like to try reauthenticating${e.reason===I.R.Forbidden?" to provide additional access":""}?`,r)===r&&(await t?.reauthenticate(),this.resetCaches(),this._onDidReauthenticate.fire())}else S.window.showErrorMessage(e.message)}async createEnterpriseAvatarUrl(e,t,r,i,s){s=s??16;let o=await this.getEnterpriseVersion(e,t,{baseUrl:r});if((0,M.ib)(o,">= 3.0.0")){let o,a=(0,E.P)(i);null!=a&&S.Uri.parse(r).authority===a.authority&&(null!=a.userId?o=`${r}/enterprise/avatars/u/${encodeURIComponent(a.userId)}?s=${s}`:null!=a.login&&(o=`${r}/enterprise/avatars/${encodeURIComponent(a.login)}?s=${s}`)),null==o&&(o=`${r}/enterprise/avatars/u/e?email=${encodeURIComponent(i)}&s=${s}`);let n=await (0,k.Ff)(e?.getIgnoreSSLErrors()??!1,()=>(0,k.hd)(o,{method:"GET",headers:{Authorization:`Bearer ${t}`}}));if(n.ok){let e=(0,U.K3)(new Uint8Array(await n.arrayBuffer())),t=n.headers.get("content-type");return`data:${t};base64,${e}`}}return`https://avatars.githubusercontent.com/u/e?email=${encodeURIComponent(i)}&s=${s}`}async searchMyPullRequests(e,t,r,i){let s=(0,L.dQ)(),o=Math.min(100,_.H.get("launchpad.experimental.queryLimit")??100);try{let a=function(t){let r=[];return t.author.login===h&&r.push("authored"),t.assignees.nodes.some(e=>e.login===h)&&r.push("assigned"),t.reviewRequests.nodes.some(e=>e.requestedReviewer?.login===h)&&r.push("review-requested"),0===r.length&&r.push("mentioned"),(0,H.fromGitHubPullRequest)(t,e)},n=`query searchMyPullRequests(
	$search: String!
	$avatarSize: Int
) {
	search(first: ${o}, query: $search, type: ISSUE) {
		issueCount
		nodes {
			...on PullRequest {
				${Z}
			}
		}
	}
	viewer {
		login
	}
}`,u=r?.search?.trim()??"";r?.user&&(u+=` user:${r.user}`),r?.repos?.length&&(u+=` repo:${r.repos.join(" repo:")}`);let l=_.H.get("launchpad.ignoredRepositories")??[];l.length&&(u+=` -repo:${l.join(" -repo:")}`);let c=_.H.get("launchpad.includedOrganizations")??[];if(c.length)u+=` org:${c.join(" org:")}`;else{let e=_.H.get("launchpad.ignoredOrganizations")??[];e.length&&(u+=` -org:${e.join(" -org:")}`)}let d=await this.graphql(e,t,n,{search:`is:open is:pr involves:@me archived:false ${u}`.trim(),baseUrl:r?.baseUrl,avatarSize:r?.avatarSize},s,i);if(null==d)return[];let h=d.viewer.login;return d.search.nodes.map(e=>a(e))}catch(t){throw this.handleException(t,e,s,r?.silent)}}async searchMyIssues(e,t,r,i){let s=(0,L.dQ)(),o=`${X}${r?.includeBody?`
			body
			`:""}`,a=`query searchMyIssues(
				$authored: String!
				$assigned: String!
				$mentioned: String!
				$avatarSize: Int
			) {
				authored: search(first: 100, query: $authored, type: ISSUE) {
					nodes {
						... on Issue {
							${o}
						}
					}
				}
				assigned: search(first: 100, query: $assigned, type: ISSUE) {
					nodes {
						... on Issue {
							${o}
						}
					}
				}
				mentioned: search(first: 100, query: $mentioned, type: ISSUE) {
					nodes {
						... on Issue {
							${o}
						}
					}
				}
			}`,n=r?.search?.trim()??"";if(r?.user&&(n+=` user:${r.user}`),r?.repos!=null&&r.repos.length>0){let e="  repo:";n+=`${e}${r.repos.join(e)}`}let u="type:issue is:open archived:false";try{let o=await this.graphql(e,t,a,{authored:`${n} ${u} author:@me`.trim(),assigned:`${n} ${u} assignee:@me`.trim(),mentioned:`${n} ${u} mentions:@me`.trim(),baseUrl:r?.baseUrl,avatarSize:r?.avatarSize},s,i);if(null==o)return[];return[...(0,j.pD)([...o.assigned.nodes,...o.mentioned.nodes,...o.authored.nodes].map(function(t){return(0,H.fromGitHubIssue)(t,e)}),e=>e.url,(e,t)=>e)]}catch(t){throw this.handleException(t,e,s)}}async searchPullRequests(e,t,r,i){let s=(0,L.dQ)();try{let o=`query searchPullRequests(
	$searchQuery: String!
	$avatarSize: Int
) {
	search(first: 10, query: $searchQuery, type: ISSUE) {
		nodes {
			...on PullRequest {
				${Z}
			}
		}
	}
}`,a=r?.search?.trim()??"";if(r?.user&&(a+=` user:${r.user}`),r?.repos!=null&&r.repos.length>0){let e=" repo:";a+=`${e}${r.repos.join(e)}`}let n=await this.graphql(e,t,o,{searchQuery:`is:pr is:open archived:false ${a.trim()}`,baseUrl:r?.baseUrl,avatarSize:r?.avatarSize},s,i);if(null==n)return[];return n.search.nodes.map(t=>(0,H.fromGitHubPullRequest)(t,e))}catch(t){throw this.handleException(t,e,s)}}async mergePullRequest(e,t,r,i,s,o){let a,n=(0,L.dQ)();switch(s?.mergeMethod){case G.e0.Merge:a="MERGE";break;case G.e0.Rebase:a="REBASE";break;case G.e0.Squash:a="SQUASH"}try{let u=`mutation mergePullRequest(
	$id: ID!
	$expectedSourceSha: GitObjectID!
	$mergeMethod: PullRequestMergeMethod
) {
	mergePullRequest(input: { pullRequestId: $id, expectedHeadOid: $expectedSourceSha, mergeMethod: $mergeMethod }) {
		pullRequest {
			id
		}
	}
}`,l=await this.graphql(e,t,u,{id:r,expectedSourceSha:i,mergeMethod:a,baseUrl:s?.baseUrl},n,o);return l?.pullRequest?.id===r}catch(t){throw this.handleException(t,e,n)}}};function ee(e){return e?.baseUrl==null||"https://api.github.com"===e.baseUrl}V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForCommit",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getAccountForEmail",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getDefaultBranch",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getIssueOrPullRequest",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getIssue",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequest",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForBranch",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getPullRequestForCommit",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"getRepositoryMetadata",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getBlame",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getBranches",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommit",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitForFile",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getBranchesWithCommits",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitCount",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getBranchWithCommit",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommits",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCommitRefs",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getTagsWithCommit",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getNextCommitRefs",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getContributors",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getDefaultBranchName",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getCurrentUser",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getComparison",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getRepositoryVisibility",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"getTags",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"resolveReference",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommits",1),V([(0,O.Yz)({args:{0:"<token>"}})],GitHubApi.prototype,"searchCommitShas",1),V([(0,O.Yz)({args:{0:e=>e?.name,1:"<token>"}})],GitHubApi.prototype,"getEnterpriseVersion",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"searchMyPullRequests",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"searchMyIssues",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"searchPullRequests",1),V([(0,O.Yz)({args:{0:e=>e.name,1:"<token>"}})],GitHubApi.prototype,"mergePullRequest",1)},2548:(e,t,r)=>{r.r(t),r.d(t,{AzureDevOpsApi:()=>AzureDevOpsApi});var i=r(1398),s=r(5369),o=r(6096),a=r(2097),n=r(8412),u=r(8439),l=r(6402),c=r(6434),d=r(3481),h=r(9135),p=r(3582),g=r(8269),m=Object.defineProperty,f=Object.getOwnPropertyDescriptor,v=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?f(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&m(t,r,o),o};let AzureDevOpsApi=class AzureDevOpsApi{_disposable;_workItemStates=new WorkItemStates;constructor(e){this._disposable=l.H.onDidChangeAny(e=>{(l.H.changedCore(e,["http.proxy","http.proxyStrictSSL"])||l.H.changed(e,["outputLevel","proxy"]))&&this.resetCaches()})}dispose(){this._disposable.dispose()}_proxyAgent=null;get proxyAgent(){if(!a.HZ)return null===this._proxyAgent&&(this._proxyAgent=(0,o.cQ)()),this._proxyAgent}resetCaches(){this._proxyAgent=null,this._workItemStates.clear()}async getPullRequestForBranch(e,t,r,i,s,o){let a=(0,h.dQ)(),[n,u,l]=i.split("/");try{let i=await this.request(e,t,o?.baseUrl,`${r}/${n}/_apis/git/repositories/${l}/pullRequests?searchCriteria.status=all&searchCriteria.sourceRefName=refs/heads/${s}`,{method:"GET"},a),u=i?.value.sort((e,t)=>{let r="active"===e.status||"notSet"===e.status,i="active"===t.status||"notSet"===t.status;if(r!==i)return r?-1:1;let s=new Date(e.closedDate||e.creationDate);return new Date(t.closedDate||t.creationDate).getTime()-s.getTime()}),c=u?.[0];if(null==c)return;return(0,g.Yv)(c,e,r)}catch(e){d.Vy.error(e,a);return}}async getPullRequestForCommit(e,t,r,i,s,o,a,n){let u=(0,h.dQ)(),[l,c,p]=i.split("/");try{let i=await this.request(e,t,o,`${r}/${l}/_apis/git/repositories/${p}/pullrequestquery?api-version=4.1`,{method:"POST",body:JSON.stringify({queries:[{items:[s],type:"commit"}]})},u,n),a=i?.results[0]?.[s]?.[0];if(null==a)return;let c=await this.request(e,t,void 0,a.url,{method:"GET"},u,n);if(null==c)return;return(0,g.Yv)(c,e,r)}catch(e){d.Vy.error(e,u);return}}async getIssueOrPullRequest(e,t,r,i,s,o){let a=(0,h.dQ)(),[n,u,l]=i.split("/");if(o?.type===void 0||o?.type==="issue")try{let i=await this.request(e,t,o?.baseUrl,`${r}/${n}/_apis/wit/workItems/${s}`,{method:"GET"},a);if(null!=i){let s=i.fields["System.WorkItemType"],a=i.fields["System.State"],u=await this.getWorkItemStateCategory(s,a,e,t,r,n,o);return{id:i.id.toString(),type:"issue",nodeId:i.id.toString(),provider:e,createdDate:new Date(i.fields["System.CreatedDate"]),updatedDate:new Date(i.fields["System.ChangedDate"]),state:(0,g.cc)(u),closed:(0,g.XM)(u),title:i.fields["System.Title"],url:i._links.html.href}}}catch(e){if(e.original?.status!==404)return void d.Vy.error(e,a)}if(o?.type===void 0||o?.type==="pullrequest")try{let i=await this.request(e,t,o?.baseUrl,`${r}/${n}/_apis/git/repositories/${l}/pullRequests/${s}`,{method:"GET"},a);if(null!=i)return{id:i.pullRequestId.toString(),type:"pullrequest",nodeId:i.pullRequestId.toString(),provider:e,createdDate:new Date(i.creationDate),updatedDate:new Date(i.creationDate),state:(0,g.a0)(i.status),closed:(0,g.cg)(i.status),title:i.title,url:(0,g.DR)(i)}}catch(e){if(e.original?.status!==404)return void d.Vy.error(e,a)}}async getIssue(e,t,r,i,s){let o=(0,h.dQ)();try{let a=await this.request(e,t,s?.baseUrl,`${r.resourceName}/${r.name}/_apis/wit/workItems/${i}`,{method:"GET"},o);if(null!=a){let i=a.fields["System.WorkItemType"],o=a.fields["System.State"],n=await this.getWorkItemStateCategory(i,o,e,t,r.resourceName,r.name,s);return(0,g.oQ)(a,e,r,n)}}catch(e){if(e.original?.status!==404)return void d.Vy.error(e,o)}}async getAccountForCommit(e,t,r,i,s,o,a){let n=(0,h.dQ)(),[u,l,c]=i.split("/");try{let i=await this.request(e,t,o,`${r}/${u}/_apis/git/repositories/${c}/commits/${s}`,{method:"GET"},n),a=i?.author;if(!a)return;return{provider:e,id:void 0,username:void 0,name:a?.name,email:a?.email,avatarUrl:void 0}}catch(e){if(e.original?.status!==404)return void d.Vy.error(e,n)}}async getCurrentUserOnServer(e,t,r){let i=(0,h.dQ)();try{let s=await this.request(e,t,r,"_apis/connectionData",{method:"GET"},i),o=s?.authenticatedUser,a=o?.properties?.Account?.$value;if(!a)return;return{id:o.id,name:o.providerDisplayName,email:o.emailAddress,username:a}}catch(e){d.Vy.error(e,i,`Failed to get current user from ${r}`);return}}async getWorkItemStateCategory(e,t,r,i,s,o,a){let n=`${s}/${o}`,u=this._workItemStates.getStateCategory(n,e,t);if(null!=u)return u;let l=await this.retrieveWorkItemTypeStates(e,r,i,s,o,a);return this._workItemStates.saveTypeStates(n,e,l),this._workItemStates.getStateCategory(n,e,t)}async retrieveWorkItemTypeStates(e,t,r,i,s,o){let a=(0,h.dQ)();try{let n=await this.request(t,r,o?.baseUrl,`${i}/${s}/_apis/wit/workItemTypes/${e}/states`,{method:"GET"},a);return n?.value??[]}catch(e){return d.Vy.error(e,a),[]}}async request(e,t,r,a,u,l,c){let h,g=r?`${r}/${a}`:a;try{let r=(0,p.u)(`[AZURE] ${u?.method??"GET"} ${g}`,{log:!1}),i=this.proxyAgent;try{let r;if(null!=c){if(c.isCancellationRequested)throw new n.AL;r=new AbortController,c.onCancellationRequested(()=>r.abort())}if((h=await (0,o.Ff)(e.getIgnoreSSLErrors(),()=>(0,o.hd)(g,{headers:{Authorization:`Basic ${(0,s.K3)(`PAT:${t}`)}`,"Content-Type":"application/json"},agent:i,signal:r?.signal,...u}))).ok)return await h.json();throw new n.QI("AzureDevOps",h)}finally{r?.stop()}}catch(r){throw r instanceof n.QI||"AbortError"===r.name?this.handleRequestError(e,t,r,l):d.Vy.isDebugging&&i.window.showErrorMessage(`AzureDevOps request failed: ${r.message}`),r}}handleRequestError(e,t,r,s){if("AbortError"===r.name||!(r instanceof n.QI))throw new n.AL(r);switch(r.status){case 404:case 410:case 422:throw new n.LN(r);case 401:throw new n.v3("azureDevOps",n.R.Unauthorized,r);case 403:throw new n.v3("azure",n.R.Forbidden,r);case 500:d.Vy.error(r,s),null!=r.response&&(e?.trackRequestException(),(0,u.wW)(`${e?.name??"AzureDevOps"} failed to respond and might be experiencing issues.${null==e||"azure"===e.id?" Please visit the [AzureDevOps status page](https://status.dev.azure.com) for more information.":""}`));return;case 502:d.Vy.error(r,s);break;default:if(r.status>=400&&r.status<500)throw new n.tk(r)}d.Vy.error(r,s),d.Vy.isDebugging&&i.window.showErrorMessage(`AzureDevOps request failed: ${r.response?.errors?.[0]?.message??r.message}`)}};v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getPullRequestForBranch",1),v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getPullRequestForCommit",1),v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getIssueOrPullRequest",1),v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getIssue",1),v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getAccountForCommit",1),v([(0,c.Yz)({args:{0:e=>e.name,1:"<token>"}})],AzureDevOpsApi.prototype,"getCurrentUserOnServer",1);let WorkItemStates=class WorkItemStates{_categories=new Map;_types=new Map;getStateCategory(e,t,r){return this._categories.get(this.getStateKey(e,t,r))}clear(){this._categories.clear(),this._types.clear()}saveTypeStates(e,t,r){for(let i of(this.clearTypeStates(e,t),this._types.set(this.getTypeKey(e,t),r),r))this._categories.set(this.getStateKey(e,t,i.name),i.category)}hasTypeStates(e,t){return this._types.has(this.getTypeKey(e,t))}clearTypeStates(e,t){let r=this._types.get(this.getTypeKey(e,t));if(null!=r)for(let i of r)this._categories.delete(this.getStateKey(e,t,i.name))}getStateKey(e,t,r){return JSON.stringify([e,t,r])}getTypeKey(e,t){return JSON.stringify([e,t])}}},4019:(e,t,r)=>{r.r(t),r.d(t,{JiraIntegration:()=>JiraIntegration});var i=r(4109),s=r(3991),o=r(3481),a=r(5711),n=r(3761);let u=n.Mt[i.NN.Jira],l=Object.freeze({id:u.id,scopes:u.scopes});let JiraIntegration=class JiraIntegration extends a.L{authProvider=l;id=i.NN.Jira;key=this.id;name="Jira";get domain(){return u.domain}get apiBaseUrl(){return"https://api.atlassian.com"}_autolinks;async autolinks(){if(!(this.maybeConnected??await this.isConnected())||null==this._session||null==this._organizations||null==this._projects)return[];let e=this._autolinks?.get(this._session.accessToken);if(null!=e)return e;let t=[],r=this._organizations.get(this._session.accessToken);if(null!=r)for(let e of r){let r=this._projects.get(`${this._session.accessToken}:${e.id}`);if(null!=r)for(let i of r){let r=`${i.key}-`,s=`${i.key}_`;t.push({prefix:r,url:`${e.url}/browse/${r}<num>`,alphanumeric:!1,ignoreCase:!1,title:`Open Issue ${r}<num> on ${e.name}`,type:"issue",description:`${e.name} Issue ${r}<num>`,descriptor:{...e}}),t.push({prefix:s,url:`${e.url}/browse/${r}<num>`,alphanumeric:!1,ignoreCase:!1,referenceType:"branch",title:`Open Issue ${r}<num> on ${e.name}`,type:"issue",description:`${e.name} Issue ${r}<num>`,descriptor:{...e}})}}return this._autolinks??=new Map,this._autolinks.set(this._session.accessToken,t),t}async getProviderAccountForResource({accessToken:e},t){let r=await this.getProvidersApi(),i=await r.getCurrentUserForResource(this.id,t.id,{accessToken:e});if(null!=i)return(0,n.tf)(i,this)}_organizations;async getProviderResourcesForUser({accessToken:e},t=!1){if(this._organizations??=new Map,null==this._organizations.get(e)||t){let t=await this.getProvidersApi(),r=await t.getJiraResourcesForCurrentUser({accessToken:e});this._organizations.set(e,null!=r?r.map(e=>({...e,key:e.id})):void 0)}return this._organizations.get(e)}_projects;async getProviderProjectsForResources({accessToken:e},t,r=!1){this._projects??=new Map;let i=[];if(r)i=t;else for(let r of t){let t=`${e}:${r.id}`;null==this._projects.get(t)&&i.push(r)}if(i.length>0){let t=await this.getProvidersApi(),r=await t.getJiraProjectsForResources(i.map(e=>e.id),{accessToken:e});for(let t of i){let i=r?.filter(e=>e.resourceId===t.id);null!=i&&this._projects.set(`${e}:${t.id}`,i.map(e=>({...e})))}}return t.reduce((t,r)=>{let i=this._projects.get(`${e}:${r.id}`);return null!=i&&t.push(...i),t},[])}async getProviderIssuesForProject({accessToken:e},t,r){let i,o=await this.getProvidersApi(),a=async(r,i)=>{let s=await o.getIssuesForProject(this.id,t.name,t.resourceId,{authorLogin:i===n.mN.Author?r:void 0,assigneeLogins:i===n.mN.Assignee?[r]:void 0,mentionLogin:i===n.mN.Mention?r:void 0,accessToken:e});return s?.map(e=>(0,n.Y9)(e,this)).filter(e=>void 0!==e)};if(r?.user!=null&&r.filters.length>0){let e=Promise.allSettled(r.filters.map(e=>a(r.user,e)));i=[...(0,s.Bq)((0,s.x1)(await e,e=>"fulfilled"===e.status&&null!=e.value?e.value:void 0))];let t=new Map;for(let e of i)t.has(e.id)||t.set(e.id,e);return[...t.values()]}return i=await o.getIssuesForProject(this.id,t.name,t.resourceId,{accessToken:e}),i?.map(e=>(0,n.Y9)(e,this)).filter(e=>void 0!==e)}async searchProviderMyIssues(e,t,r){let i=t??await this.getProviderResourcesForUser(e);if(!i)return;let s=await this.getProvidersApi(),a=[];for(let t of i)try{let r,i=!1,o=0;do{let u=await s.getIssuesForResourceForCurrentUser(this.id,t.id,{accessToken:e.accessToken,cursor:r});o+=1,i=u.paging?.more??!1,r=u.paging?.cursor;let l=u.values.map(e=>(0,n.Y9)(e,this)).filter(e=>null!=e);l.length>0&&a.push(...l)}while(o<10&&i)}catch(e){o.Vy.error(e,"searchProviderMyIssues")}return a}async getProviderLinkedIssueOrPullRequest(e,t,{key:r}){let i=await this.getProvidersApi(),s=await i.getIssue(this.id,{resourceId:t.id,number:r},{accessToken:e.accessToken});return null!=s?(0,n.Y9)(s,this):void 0}async getProviderIssue(e,t,r){let i=await this.getProvidersApi(),s=await i.getIssue(this.id,{resourceId:t.id,number:r},{accessToken:e.accessToken}),o=null!=s?(0,n.Y9)(s,this):void 0;return null!=o?{...o,type:"issue"}:void 0}async providerOnConnect(){if(this._autolinks=void 0,null==this._session)return;let e=this.container.storage.get(`jira:${this._session.accessToken}:organizations`),t=this.container.storage.get(`jira:${this._session.accessToken}:projects`),r=e?.data?.map(e=>({...e})),i=t?.data?.map(e=>({...e}));for(let s of(null==e&&(r=await this.getProviderResourcesForUser(this._session,!0),await this.container.storage.deleteWithPrefix("jira"),await this.container.storage.store(`jira:${this._session.accessToken}:organizations`,{v:1,timestamp:Date.now(),data:r})),this._organizations??=new Map,this._organizations.set(this._session.accessToken,r),null==t&&r?.length&&(i=await this.getProviderProjectsForResources(this._session,r),await this.container.storage.store(`jira:${this._session.accessToken}:projects`,{v:1,timestamp:Date.now(),data:i})),this._projects??=new Map,i??[])){let e=`${this._session.accessToken}:${s.resourceId}`,t=this._projects.get(e);null==t?this._projects.set(e,[s]):t.some(e=>e.id===s.id)||t.push(s)}}providerOnDisconnect(){this._organizations=void 0,this._projects=void 0,this._autolinks=void 0}}},4604:(e,t,r)=>{r.r(t),r.d(t,{GitHubEnterpriseIntegration:()=>GitHubEnterpriseIntegration,GitHubIntegration:()=>GitHubIntegration});var i=r(4109),s=r(6434),o=r(6317),a=r(5817),n=r(1531),u=r(3761),l=Object.defineProperty,c=Object.getOwnPropertyDescriptor;let d=u.Mt[i.$r.GitHub],h=Object.freeze({id:d.id,scopes:d.scopes}),p=u.Mt[i.RR.GitHubEnterprise],g=Object.freeze({id:p.id,scopes:p.scopes}),m=u.Mt[i.RR.CloudGitHubEnterprise],f=Object.freeze({id:m.id,scopes:m.scopes});let GitHubIntegrationBase=class GitHubIntegrationBase extends a.d{async getProviderAccountForCommit({accessToken:e},t,r,i){return(await this.container.github)?.getAccountForCommit(this,e,t.owner,t.name,r,{...i,baseUrl:this.apiBaseUrl})}async getProviderAccountForEmail({accessToken:e},t,r,i){return(await this.container.github)?.getAccountForEmail(this,e,t.owner,t.name,r,{...i,baseUrl:this.apiBaseUrl})}async getProviderDefaultBranch({accessToken:e},t){return(await this.container.github)?.getDefaultBranch(this,e,t.owner,t.name,{baseUrl:this.apiBaseUrl})}async getProviderLinkedIssueOrPullRequest({accessToken:e},t,{id:r}){return(await this.container.github)?.getIssueOrPullRequest(this,e,t.owner,t.name,Number(r),{baseUrl:this.apiBaseUrl})}async getProviderIssue({accessToken:e},t,r){return(await this.container.github)?.getIssue(this,e,t.owner,t.name,Number(r),{baseUrl:this.apiBaseUrl,includeBody:!0})}async getProviderPullRequest({accessToken:e},t,r){return(await this.container.github)?.getPullRequest(this,e,t.owner,t.name,parseInt(r,10),{baseUrl:this.apiBaseUrl})}async getProviderPullRequestForBranch({accessToken:e},t,i,s){let{include:o,...a}=s??{},n=(await Promise.resolve().then(r.bind(r,8841))).toGitHubPullRequestState;return(await this.container.github)?.getPullRequestForBranch(this,e,t.owner,t.name,i,{...a,include:o?.map(e=>n(e)),baseUrl:this.apiBaseUrl})}async getProviderPullRequestForCommit({accessToken:e},t,r){return(await this.container.github)?.getPullRequestForCommit(this,e,t.owner,t.name,r,{baseUrl:this.apiBaseUrl})}async getProviderRepositoryMetadata({accessToken:e},t,r){return(await this.container.github)?.getRepositoryMetadata(this,e,t.owner,t.name,{baseUrl:this.apiBaseUrl},r)}async searchProviderMyPullRequests({accessToken:e},t,r,i){return(await this.container.github)?.searchMyPullRequests(this,e,{repos:t?.map(e=>`${e.owner}/${e.name}`),baseUrl:this.apiBaseUrl,silent:i},r)}async searchProviderMyIssues({accessToken:e},t,r){return(await this.container.github)?.searchMyIssues(this,e,{repos:t?.map(e=>`${e.owner}/${e.name}`),baseUrl:this.apiBaseUrl,includeBody:!0},r)}async searchProviderPullRequests({accessToken:e},t,r,i){return(await this.container.github)?.searchPullRequests(this,e,{search:t,repos:r?.map(e=>`${e.owner}/${e.name}`),baseUrl:this.apiBaseUrl},i)}async mergeProviderPullRequest({accessToken:e},t,r){let i=t.nodeId,s=t.refs?.head?.sha;return null!=i&&null!=s&&((await this.container.github)?.mergePullRequest(this,e,i,s,{mergeMethod:r?.mergeMethod,baseUrl:this.apiBaseUrl})??!1)}async getProviderCurrentAccount({accessToken:e},t){return(await this.container.github)?.getCurrentAccount(this,e,{...t,baseUrl:this.apiBaseUrl})}getProviderPullRequestIdentityFromMaybeUrl(e){return(0,n.h)(e,this.id)}};let GitHubIntegration=class GitHubIntegration extends GitHubIntegrationBase{authProvider=h;id=i.$r.GitHub;key=this.id;name="GitHub";get domain(){return d.domain}get apiBaseUrl(){return"https://api.github.com"}access(){return Promise.resolve(!0)}async refresh(){let e=await this.authenticationService.get(this.authProvider.id),t=await e.getSession(this.authProviderDescriptor);null==t&&this.maybeConnected?this.disconnect({silent:!0}):(t?.accessToken!==this._session?.accessToken&&(this._session=void 0),super.refresh())}};let GitHubEnterpriseIntegration=class GitHubEnterpriseIntegration extends GitHubIntegrationBase{constructor(e,t,r,s,o,a){super(e,t,r,s),this._domain=o,this.id=a,this.key=`${this.id}:${this.domain}`,this.authProvider=this.id===i.RR.GitHubEnterprise?g:f}authProvider;key;name="GitHub Enterprise";get domain(){return this._domain}get apiBaseUrl(){return`https://${this._domain}/api/v3`}async connect(e){return!!await (0,o.KH)(this.container,`Rich integration with ${this.name} is a Pro feature.`,{source:"integrations",detail:{action:"connect",integration:this.id}})&&super.connect(e)}};((e,t,r,i)=>{for(var s,o=c(t,r),a=e.length-1;a>=0;a--)(s=e[a])&&(o=s(t,r,o)||o);return o&&l(t,r,o)})([(0,s.Rm)()],GitHubEnterpriseIntegration.prototype,"connect",0)},5711:(e,t,r)=>{r.d(t,{L:()=>IssuesIntegration});var i=r(253),s=r(6434),o=r(9135),a=r(871),n=Object.defineProperty,u=Object.getOwnPropertyDescriptor,l=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?u(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&n(t,r,o),o};let IssuesIntegration=class IssuesIntegration extends a.s{type="issues";async getAccountForResource(e){let t=(0,o.dQ)();if(this.maybeConnected??await this.isConnected()){await this.refreshSessionIfExpired(t);try{let t=await this.getProviderAccountForResource(this._session,e);return this.resetRequestExceptionCount("getAccountForResource"),t}catch(e){this.handleProviderException("getAccountForResource",e);return}}}async getResourcesForUser(){let e=(0,o.dQ)();if(this.maybeConnected??await this.isConnected()){await this.refreshSessionIfExpired(e);try{let e=await this.getProviderResourcesForUser(this._session);return this.resetRequestExceptionCount("getResourcesForUser"),e}catch(e){this.handleProviderException("getResourcesForUser",e);return}}}async getProjectsForResources(e){let t=(0,o.dQ)();if(this.maybeConnected??await this.isConnected()){await this.refreshSessionIfExpired(t);try{let t=await this.getProviderProjectsForResources(this._session,e);return this.resetRequestExceptionCount("getProjectsForResources"),t}catch(e){this.handleProviderException("getProjectsForResources",e);return}}}async getProjectsForUser(){let e=await this.getResourcesForUser();if(null!=e)return this.getProjectsForResources(e)}async getIssuesForProject(e,t){let r=(0,o.dQ)();if(this.maybeConnected??await this.isConnected()){await this.refreshSessionIfExpired(r);try{let r=await this.getProviderIssuesForProject(this._session,e,t);return this.resetRequestExceptionCount("getIssuesForProject"),r}catch(e){this.handleProviderException("getIssuesForProject",e);return}}}};l([(0,i.G)(),(0,s.Yz)()],IssuesIntegration.prototype,"getAccountForResource",1),l([(0,i.G)(),(0,s.Yz)()],IssuesIntegration.prototype,"getResourcesForUser",1),l([(0,s.Yz)()],IssuesIntegration.prototype,"getProjectsForResources",1),l([(0,s.Yz)()],IssuesIntegration.prototype,"getIssuesForProject",1)},5911:(e,t,r)=>{r.r(t),r.d(t,{JiraAuthenticationProvider:()=>JiraAuthenticationProvider});var i=r(4109),s=r(5460);let JiraAuthenticationProvider=class JiraAuthenticationProvider extends s.DP{get authProviderId(){return i.NN.Jira}}},6120:(e,t,r)=>{r.r(t),r.d(t,{GitLabCloudAuthenticationProvider:()=>GitLabCloudAuthenticationProvider,GitLabLocalAuthenticationProvider:()=>GitLabLocalAuthenticationProvider,GitLabSelfHostedCloudAuthenticationProvider:()=>GitLabSelfHostedCloudAuthenticationProvider});var i=r(1398),s=r(4109),o=r(5460);let GitLabLocalAuthenticationProvider=class GitLabLocalAuthenticationProvider extends o.RH{constructor(e,t,r,i){super(e,t,r),this.authProviderId=i}async createSession(e){let t,r=i.window.createInputBox();r.ignoreFocusOut=!0;let s=[];try{let o={iconPath:new i.ThemeIcon("link-external"),tooltip:"Open the GitLab Access Tokens Page"};t=await new Promise(t=>{s.push(r.onDidHide(()=>t(void 0)),r.onDidChangeValue(()=>r.validationMessage=void 0),r.onDidAccept(()=>{let e=r.value.trim();if(!e){r.validationMessage="A personal access token is required";return}t(e)}),r.onDidTriggerButton(t=>{t===o&&i.env.openExternal(i.Uri.parse(`https://${e.domain}/-/profile/personal_access_tokens`))})),r.password=!0,r.title=`GitLab Authentication  \u2022 ${e.domain}`,r.placeholder=`Requires ${e.scopes.join(", ")} scopes`,r.prompt=`Paste your [GitLab Personal Access Token](https://${e.domain}/-/user_settings/personal_access_tokens?name=GitLens+Access+token&scopes=${e.scopes.join(",")} "Get your GitLab Access Token")`,r.buttons=[o],r.show()})}finally{r.dispose(),s.forEach(e=>void e.dispose())}if(t)return{id:this.configuredIntegrationService.getSessionId(e),accessToken:t,scopes:e?.scopes??[],account:{id:"",label:""},cloud:!1,domain:e.domain}}};let GitLabSelfHostedCloudAuthenticationProvider=class GitLabSelfHostedCloudAuthenticationProvider extends o.DP{get authProviderId(){return s.RR.CloudGitLabSelfHosted}};let GitLabCloudAuthenticationProvider=class GitLabCloudAuthenticationProvider extends o.DP{get authProviderId(){return s.$r.GitLab}}},6241:(e,t,r)=>{r.r(t),r.d(t,{AzureDevOpsAuthenticationProvider:()=>AzureDevOpsAuthenticationProvider,AzureDevOpsServerAuthenticationProvider:()=>AzureDevOpsServerAuthenticationProvider});var i=r(4109),s=r(5460);let AzureDevOpsAuthenticationProvider=class AzureDevOpsAuthenticationProvider extends s.DP{get authProviderId(){return i.$r.AzureDevOps}};let AzureDevOpsServerAuthenticationProvider=class AzureDevOpsServerAuthenticationProvider extends s.DP{get authProviderId(){return i.RR.AzureDevOpsServer}}},6251:(e,t,r)=>{r.r(t),r.d(t,{CloudIntegrationService:()=>CloudIntegrationService});var i=r(3481),s=r(9135),o=r(2765);let CloudIntegrationService=class CloudIntegrationService{constructor(e,t){this.container=e,this.connection=t}async getConnections(){let e=(0,s.dQ)(),t=await this.connection.fetchGkApi("v1/provider-tokens",{method:"GET"},{organizationId:!1});if(!t.ok){let r=(await t.json())?.error,s="string"==typeof r?r:r?.message??t.statusText;null!=r&&i.Vy.error(void 0,e,`Failed to get connected providers from cloud: ${s}`),this.container.telemetry.enabled&&this.container.telemetry.sendEvent("cloudIntegrations/getConnections/failed",{code:t.status});return}return(await t.json())?.data}async getConnectionSession(e,t){let r=(0,s.dQ)(),a=!!t,n=o.xq[e];if(null==n)return void i.Vy.error(void 0,r,`Unsupported cloud integration type: ${e}`);let u=t?{method:"POST",body:JSON.stringify({access_token:t})}:{method:"GET"},l=await this.connection.fetchGkApi(`v1/provider-tokens/${n}${a?"/refresh":""}`,u,{organizationId:!1});if(!l.ok){let s=(await l.json())?.error,o="string"==typeof s?s:s?.message??l.statusText;if(null!=s&&i.Vy.error(void 0,r,`Failed to ${a?"refresh":"get"} ${e} token from cloud: ${o}`),this.container.telemetry.enabled&&this.container.telemetry.sendEvent(t?"cloudIntegrations/refreshConnection/failed":"cloudIntegrations/getConnection/failed",{code:l.status,"integration.id":e}),a){let e=await this.connection.fetchGkApi(`v1/provider-tokens/${n}`,{method:"GET"},{organizationId:!1});if(e.ok)return(await e.json())?.data}return}return(await l.json())?.data}async disconnect(e){let t=(0,s.dQ)(),r=o.xq[e];if(null==r)return i.Vy.error(void 0,t,`Unsupported cloud integration type: ${e}`),!1;let a=await this.connection.fetchGkApi(`v1/provider-tokens/${r}`,{method:"DELETE"},{organizationId:!1});if(!a.ok){let r=(await a.json())?.error,s="string"==typeof r?r:r?.message??a.statusText;return null!=r&&i.Vy.error(void 0,t,`Failed to disconnect ${e} token from cloud: ${s}`),this.container.telemetry.enabled&&this.container.telemetry.sendEvent("cloudIntegrations/disconnect/failed",{code:a.status,"integration.id":e}),!1}return!0}}},6411:e=>{let t=function(){};t.prototype=Object.create(null);let r=/; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu,i=/\\([\v\u0020-\u00ff])/gu,s=/^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u,o={type:"",parameters:new t};Object.freeze(o.parameters),Object.freeze(o),e.exports.xL=function(e){let a,n,u;if("string"!=typeof e)return o;let l=e.indexOf(";"),c=-1!==l?e.slice(0,l).trim():e.trim();if(!1===s.test(c))return o;let d={type:c.toLowerCase(),parameters:new t};if(-1===l)return d;for(r.lastIndex=l;n=r.exec(e);){if(n.index!==l)return o;l+=n[0].length,a=n[1].toLowerCase(),'"'===(u=n[2])[0]&&(u=u.slice(1,u.length-1),i.test(u)&&(u=u.replace(i,"$1"))),d.parameters[a]=u}return l!==e.length?o:d}},7018:(e,t,r)=>{let i;r.r(t),r.d(t,{GitHubGitProvider:()=>GitHubGitProvider,stripOrigin:()=>eY});var s,o,a=r(1398),n=r(5433),u=r(746),l=r(4109),c=r(8412),d=r(1490),h=r(9411),p=r(1522),g=r(2609),m=r(7523),f=r(6695),v=r(3182),y=r(1865),w=r(3790),b=r(6402),R=r(9827),P=r(2597),$=r(253),C=r(6434),A=r(3481),F=r(9135),q=r(1362),S=r(7820),U=r(1462),k=r(3709);async function D(e){try{let e=a.extensions.getExtension("ms-vscode.remote-repositories")??a.extensions.getExtension("GitHub.remotehub");if(null==e)throw A.Vy.log("GitHub Repositories extension is not installed or enabled"),new c.dU("GitHub Repositories","GitHub.remotehub");return e.isActive?e.exports:await e.activate()}catch(t){if(A.Vy.error(t,"Unable to get required api from the GitHub Repositories extension"),!(t instanceof c.dU),e)return;throw t}}var I=((s=I||{})[s.Branch=0]="Branch",s[s.RemoteBranch=1]="RemoteBranch",s[s.Tag=2]="Tag",s[s.Commit=3]="Commit",s),G=((o=G||{})[o.Branch=0]="Branch",o[o.Tag=1]="Tag",o[o.Commit=2]="Commit",o[o.PullRequest=3]="PullRequest",o[o.Tree=4]="Tree",o),E=r(5399),x=r(7685),T=Object.defineProperty,_=Object.getOwnPropertyDescriptor,O=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?_(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&T(t,r,o),o};let j=Object.freeze({values:[]});let BranchesGitSubProvider=class BranchesGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getBranch(e,t,r){if(null!=t){let{values:[i]}=await this.getBranches(e,{filter:e=>e.name===t},r);return i}let i=this.cache.branch?.get(e);return null==i&&(i=(async function(){let{values:[t]}=await this.getBranches(e,{filter:e=>e.current},r);if(null!=t)return t;try{let{metadata:t}=await this.provider.ensureRepositoryContext(e),r=await t.getRevision();switch(r.type){case I.Tag:case I.Commit:return new E.Z(this.container,e,`refs/heads/${r.name}`,!0,void 0,r.revision,void 0,!1,!0)}return}catch(e){A.Vy.error(e,(0,F.dQ)());return}}).call(this),this.cache.branch?.set(e,i)),i}async getBranches(e,t,r){if(null==e)return j;let i=(0,F.dQ)(),s=t?.paging?.cursor?void 0:this.cache.branches?.get(e);null==s&&(s=(async function(){try{let r,{metadata:i,github:s,session:o}=await this.provider.ensureRepositoryContext(e),a=[],n=await i.getRevision();switch(n.type){case I.Branch:r=n.name;break;case I.RemoteBranch:{let e=n.name.indexOf(":");r=-1===e?n.name:n.name.substring(e+1)}}let u=t?.paging?.cursor,l=null==u;for(;;){let t=await s.getBranches(o.accessToken,i.repo.owner,i.repo.name,{cursor:u});for(let i of t.values)!function(t,r,i){let s=new Date("author-date"===b.H.get("advanced.commitOrdering")?r.target.authoredDate:r.target.committedDate),o=r.target.oid;a.push(new E.Z(t,e,`refs/heads/${r.name}`,i,s,o,{name:`origin/${r.name}`,missing:!1,state:{ahead:0,behind:0}},!1),new E.Z(t,e,`refs/remotes/origin/${r.name}`,!1,s,o,void 0,!1))}(this.container,i,i.name===r);if(!t.paging?.more||!l)return{...t,values:a};u=t.paging.cursor}}catch(t){return A.Vy.error(t,i),this.cache.branches?.delete(e),j}}).call(this),t?.paging?.cursor==null&&this.cache.branches?.set(e,s));let o=await s;return t?.filter!=null&&(o={...o,values:o.values.filter(t.filter)}),t?.sort!=null&&(0,x.Xn)(o.values,"boolean"==typeof t.sort?void 0:t.sort),o}async getBranchContributionsOverview(e,t,r){let i=(0,F.dQ)();try{let r,i,s=await this.getDefaultBranchName(e);if(null==s)return;let o=await this.provider.refs.getMergeBase(e,t,s);if(null==o)return;let a=await this.provider.contributors.getContributors(e,(0,w.Xn)(o,t,".."),{stats:!0});(0,x.tB)(a.contributors,{orderBy:"score:desc"});let n=0,u=0,l=0,c=0;for(let e of a.contributors){n+=e.contributionCount,u+=e.stats?.files??0,l+=e.stats?.additions??0,c+=e.stats?.deletions??0;let t=e.firstCommitDate?.getTime(),s=e.latestCommitDate?.getTime();(null!=t||null!=s)&&(r=null!=r?Math.min(r,t??1/0,s??1/0):t??s,i=null!=i?Math.max(i,t??-1/0,s??-1/0):s??t)}return{repoPath:e,branch:t,mergeTarget:s,mergeBase:o,commits:n,files:u,additions:l,deletions:c,latestCommitDate:null!=i?new Date(i):void 0,firstCommitDate:null!=r?new Date(r):void 0,contributors:a.contributors}}catch(e){A.Vy.error(e,i);return}}async getBranchesWithCommits(e,t,r,i,s){if(null==e||i?.commitDate==null)return[];let o=(0,F.dQ)();try{let{metadata:s,github:o,session:a}=await this.provider.ensureRepositoryContext(e);return r?await o.getBranchWithCommit(a.accessToken,s.repo.owner,s.repo.name,r,t.map(eY),i?.mode??"contains",i?.commitDate):await o.getBranchesWithCommits(a.accessToken,s.repo.owner,s.repo.name,t.map(eY),i?.mode??"contains",i?.commitDate)}catch(e){return A.Vy.error(e,o),[]}}async getDefaultBranchName(e,t,r){if(null==e)return;let i=(0,F.dQ)();try{let{metadata:t,github:r,session:i}=await this.provider.ensureRepositoryContext(e);return await r.getDefaultBranchName(i.accessToken,t.repo.owner,t.repo.name)}catch(e){A.Vy.error(e,i);return}}};O([(0,C.Rm)()],BranchesGitSubProvider.prototype,"getBranch",1),O([(0,C.Rm)({args:{1:!1}})],BranchesGitSubProvider.prototype,"getBranches",1),O([(0,C.Rm)()],BranchesGitSubProvider.prototype,"getBranchContributionsOverview",1),O([(0,C.Rm)()],BranchesGitSubProvider.prototype,"getBranchesWithCommits",1),O([(0,C.Rm)()],BranchesGitSubProvider.prototype,"getDefaultBranchName",1);var B=r(5439),L=r(7442),z=r(4169),M=r(7987),H=r(3991),N=r(8841),Q=Object.defineProperty,V=Object.getOwnPropertyDescriptor,Y=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?V(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&Q(t,r,o),o};let W=Promise.resolve(void 0);let CommitsGitSubProvider=class CommitsGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}get useCaching(){return!0}async getCommit(e,t,r){if(null==e)return;let i=(0,F.dQ)();try{if((0,w._k)(t,!0))return(0,M.O)(this.container,e,t,new Date,await this.provider.config.getCurrentUser(e));let{metadata:r,github:i,session:s}=await this.provider.ensureRepositoryContext(e),o=await i.getCommit(s.accessToken,r.repo.owner,r.repo.name,eY(t));if(null==o)return;let{viewer:a=s.account.label}=o,n=null!=a&&o.author.name===a?"You":o.author.name,u=null!=a&&o.committer.name===a?"You":o.committer.name;return new p.Yg(this.container,e,o.oid,new p.M7(n,o.author.email,new Date(o.author.date),o.author.avatarUrl),new p.M7(u,o.committer.email,new Date(o.committer.date)),o.message.split(`
`,1)[0],o.parents.nodes.map(e=>e.oid),o.message,{files:o.files?.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0}))},{files:o.changedFiles??0,additions:o.additions??0,deletions:o.deletions??0},[])}catch(e){A.Vy.error(e,i);return}}async getCommitCount(e,t,r){if(null==e)return;let i=(0,F.dQ)();try{let{metadata:r,github:i,session:s}=await this.provider.ensureRepositoryContext(e);return await i.getCommitCount(s?.accessToken,r.repo.owner,r.repo.name,eY(t))}catch(e){A.Vy.error(e,i);return}}async getCommitFiles(e,t,r){if(t===v.nB||(0,w._k)(t))return[];let i=await this.getCommit(e,t);return[...i?.fileset?.files??[]]}async getCommitForFile(e,t,r,i,s){if(null==e)return;let o=(0,F.dQ)();try{let{metadata:i,github:s,remotehub:o,session:a}=await this.provider.ensureRepositoryContext(e),n=this.provider.getRelativePath(t,o.getProviderRootUri(t));r=r&&"HEAD"!==r?r:(await i.getRevision()).revision;let u=await s.getCommitForFile(a.accessToken,i.repo.owner,i.repo.name,eY(r),n);if(null==u)return;let{viewer:l=a.account.label}=u,c=null!=l&&u.author.name===l?"You":u.author.name,d=null!=l&&u.committer.name===l?"You":u.committer.name;return new p.Yg(this.container,e,u.oid,new p.M7(c,u.author.email,new Date(u.author.date),u.author.avatarUrl),new p.M7(d,u.committer.email,new Date(u.committer.date)),u.message.split(`
`,1)[0],u.parents.nodes.map(e=>e.oid),u.message,null!=u.files?{files:void 0,filtered:{files:u.files?.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0})),pathspec:n}}:void 0,{files:u.changedFiles??0,additions:u.additions??0,deletions:u.deletions??0},[])}catch(e){A.Vy.error(e,o);return}}async getLeftRightCommitCount(e,t,r,i){if(null==e)return;let s=(0,F.dQ)(),{metadata:o,github:a,session:n}=await this.provider.ensureRepositoryContext(e);try{let e=await a.getComparison(n.accessToken,o.repo.owner,o.repo.name,eY(t));if(null==e)return;return{left:e.behind_by,right:e.ahead_by}}catch(e){A.Vy.error(e,s);return}}async getLog(e,t,r,i){if(null==e)return;let s=(0,F.dQ)(),o=this.provider.getPagingLimit(r?.limit);try{let{metadata:i,github:s,session:a}=await this.provider.ensureRepositoryContext(e);t=t&&"HEAD"!==t?t:(await i.getRevision()).revision;let n=await s.getCommits(a.accessToken,i.repo.owner,i.repo.name,eY(t),{all:r?.all,authors:r?.authors,after:r?.cursor,limit:o,since:r?.since?new Date(r.since):void 0}),u=new Map,{viewer:l=a.account.label}=n;for(let t of n.values){let r=null!=l&&t.author.name===l?"You":t.author.name,i=null!=l&&t.committer.name===l?"You":t.committer.name,s=u.get(t.oid);null==s&&(s=new p.Yg(this.container,e,t.oid,new p.M7(r,t.author.email,new Date(t.author.date),t.author.avatarUrl),new p.M7(i,t.committer.email,new Date(t.committer.date)),t.message.split(`
`,1)[0],t.parents.nodes.map(e=>e.oid),t.message,null!=t.files?{files:t.files.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0}))}:void 0,{files:t.changedFiles??0,additions:t.additions??0,deletions:t.deletions??0},[]),u.set(t.oid,s))}let c={repoPath:e,commits:u,sha:t,count:u.size,limit:o,hasMore:n.paging?.more??!1,endingCursor:n.paging?.cursor,query:i=>this.getLog(e,t,{...r,limit:i})};return c.hasMore&&(c.more=this.getLogMoreFn(c,t,r)),c}catch(e){A.Vy.error(e,s);return}}getLogMoreFn(e,t,r){return async i=>{let s=null!=i&&"object"==typeof i?i.until:void 0,o="number"==typeof i?i:void 0;if(s&&(0,H.zN)(e.commits.values(),e=>e.ref===s))return e;o=this.provider.getPagingLimit(o);let a=await this.getLog(e.repoPath,t,{...r,limit:o,cursor:e.endingCursor});if(null==a)return{...e,hasMore:!1,more:void 0};let n=new Map([...e.commits,...a.commits]),u={repoPath:e.repoPath,commits:n,sha:e.sha,count:n.size,limit:null==s?(e.limit??0)+o:void 0,hasMore:null!=s||a.hasMore,startingCursor:(0,H.HV)(e.commits)?.[0],endingCursor:a.endingCursor,pagedCommits:()=>{for(let t of e.commits.keys())a.commits.delete(t);return a.commits},query:e.query};return u.hasMore&&(u.more=this.getLogMoreFn(u,t,r)),u}}async getLogForPath(e,t,r,i,s){let o,a;if(null==e)return;let n=(0,F.dQ)(),u=this.provider.getRelativePath(t,e);if(null!=e&&e===u)throw Error(`Path cannot match the repository path; path=${u}`);if(i={...i,all:!1,limit:this.provider.getPagingLimit(i?.limit),renames:!1},(0,q.Np)(u))u=(0,q.x9)(u),i.isFolder=!0;else if(null==i.isFolder){let t=await this.provider.revision.getTreeEntryForRevision(e,r||"HEAD",u);i.isFolder=t?.type==="tree"}if(this.useCaching&&!i.isFolder&&null==i.authors&&null==i.cursor&&null==i.filters&&null==i.range&&null==i.since&&null==i.until&&(o="log",null!=r&&(o+=`:${r}`),i.all&&(o+=":all"),i.limit&&(o+=`:n${i.limit}`),i.merges&&(o+=`:merges=${i.merges}`),i.ordering&&(o+=`:ordering=${i.ordering}`),i.renames&&(o+=":follow")),o){if(null!=(a=await this.container.documentTracker.getOrAdd(B.nk.fromFile(u,e,r))).state){let s=a.state.getLog(o);if(null!=s)return A.Vy.debug(n,`Cache hit: '${o}'`),s.item;if(null!=r||null!=i.limit){let s=a.state.getLog(`log${i.renames?":follow":""}`);if(null!=s){if(null==r)return A.Vy.debug(n,`Cache hit: ~'${o}'`),s.item;A.Vy.debug(n,`Cache ?: '${o}'`);let a=await s.item;if(null!=a&&!a.hasMore&&a.commits.has(r)){A.Vy.debug(n,`Cache hit: '${o}'`);let s=!0,u=0,l=new Map((0,H.x1)(a.commits.entries(),([e,t])=>{if(s){if(e!==r)return;s=!1}if(u++,null==i.limit||!(u>i.limit))return[e,t]})),c={...i};return{...a,limit:i.limit,count:l.size,commits:l,query:i=>this.getLogForPath(e,t,r,{...c,limit:i})}}}}}A.Vy.debug(n,`Cache miss: '${o}'`),a.state??=new U.VV}let l=this.getLogForPathCore(e,u,r,i,s).catch(e=>{if(o&&a?.state!=null){let t=e?.toString()??"";return A.Vy.debug(n,`Cache replace (with empty promise): '${o}'`),a.state.setLog(o,{item:W,errorMessage:t}),W}});return o&&a?.state!=null&&(A.Vy.debug(n,`Cache add: '${o}'`),a.state.setLog(o,{item:l})),l}async getLogForPathCore(e,t,r,i,s){if(null==e)return;let o=this.provider.getPagingLimit(i.limit),a=await this.provider.ensureRepositoryContext(e);if(null==a)return;let{metadata:n,github:u,remotehub:l,session:c}=a,d=this.provider.getAbsoluteUri(t,e),h=this.provider.getRelativePath(d,l.getProviderRootUri(d));r=r&&"HEAD"!==r?r:(await n.getRevision()).revision;let f=await u.getCommits(c.accessToken,n.repo.owner,n.repo.name,eY(r),{all:i.all,after:i.cursor,path:h,limit:o,since:i.since?new Date(i.since):void 0}),v=new Map,{viewer:y=c.account.label}=f;for(let t of f.values){let r=null!=y&&t.author.name===y?"You":t.author.name,s=null!=y&&t.committer.name===y?"You":t.committer.name,o=v.get(t.oid);if(null==o){let a=t.files?.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0}));if(null!=a&&!i.isFolder&&1===t.changedFiles){let r=a.findIndex(e=>e.path===h);-1!==r&&a.splice(r,1,new g.l(this.container,e,h,m.NO.Modified,void 0,void 0,1===t.changedFiles?{additions:t.additions??0,deletions:t.deletions??0,changes:0}:void 0))}o=new p.Yg(this.container,e,t.oid,new p.M7(r,t.author.email,new Date(t.author.date),t.author.avatarUrl),new p.M7(s,t.committer.email,new Date(t.committer.date)),t.message.split(`
`,1)[0],t.parents.nodes.map(e=>e.oid),t.message,{files:void 0,filtered:{files:a,pathspec:h}},{files:t.changedFiles??0,additions:t.additions??0,deletions:t.deletions??0},[]),v.set(t.oid,o)}}let w={repoPath:e,commits:v,sha:r,count:v.size,limit:o,hasMore:f.paging?.more??!1,endingCursor:f.paging?.cursor,query:s=>this.getLogForPath(e,t,r,{...i,limit:s})};return w.hasMore&&(w.more=this.getLogForPathMoreFn(w,t,r,i)),w}getLogForPathMoreFn(e,t,r,i){return async s=>{let o=null!=s&&"object"==typeof s?s.until:void 0,a="number"==typeof s?s:void 0;if(o&&(0,H.zN)(e.commits.values(),e=>e.ref===o))return e;a=this.provider.getPagingLimit(a);let n=await this.getLogForPath(e.repoPath,t,r,{...i,limit:null==o?a:0,cursor:e.endingCursor});if(null==n)return{...e,hasMore:!1,more:void 0};let u=new Map([...e.commits,...n.commits]),l={repoPath:e.repoPath,commits:u,sha:e.sha,count:u.size,limit:null==o?(e.limit??0)+a:void 0,hasMore:null!=o||n.hasMore,endingCursor:n.endingCursor,query:e.query};return l.hasMore&&(l.more=this.getLogForPathMoreFn(l,t,r,i)),l}}async getLogShas(e,t,r,i){let s;return null==(s=r?.pathOrUri!=null?await this.getLogForPath(e,r.pathOrUri,t,r,i):await this.getLog(e,t,r,i))?[]:(0,H.Tj)(s.commits.values(),e=>e.ref)}getOldestUnpushedShaForPath(e,t,r){return Promise.resolve(void 0)}hasCommitBeenPushed(e,t,r){return Promise.resolve(!0)}async isAncestorOf(e,t,r,i){if(null==e)return!1;let s=(0,F.dQ)(),{metadata:o,github:a,session:n}=await this.provider.ensureRepositoryContext(e);try{let e=await a.getComparison(n.accessToken,o.repo.owner,o.repo.name,(0,w.Xn)(eY(t),eY(r),"..."));switch(e?.status){case"ahead":case"diverged":default:return!1;case"identical":case"behind":return!0}}catch(e){return A.Vy.error(e,s),!1}}async searchCommits(e,t,r,i,s){if(null==e)return{search:t,log:void 0};let o=(0,F.dQ)();(t={matchAll:!1,matchCase:!1,matchRegex:!0,matchWholeWord:!1,...t}).naturalLanguage&&("object"!=typeof t.naturalLanguage||!t.naturalLanguage.processedQuery)&&(t=await (0,z.I)(this.container,t,r));let a=t.query.includes("@me")?await this.provider.config.getCurrentUser(e):void 0;if(s?.isCancellationRequested)throw new c.AL;let{args:n,operations:u}=(0,L.O)(t,a),l=u.get("commit:");if(l?.size){let r=await this.getCommit(e,(0,H.$1)(l));return null==r?{search:t,log:void 0}:{search:t,log:{repoPath:e,commits:new Map([[r.sha,r]]),sha:r.sha,count:1,limit:1,hasMore:!1}}}if(!n.length)return{search:t,log:void 0};let d=this.provider.getPagingLimit(i?.limit);try{let{metadata:s,github:o,session:a}=await this.provider.ensureRepositoryContext(e),u=`repo:${s.repo.owner}/${s.repo.name}+${n.join("+").trim()}`,l=await o.searchCommits(a.accessToken,u,{cursor:i?.cursor,limit:d,sort:i?.ordering==="date"?"committer-date":i?.ordering==="author-date"?"author-date":void 0});if(null==l)return{search:t,log:void 0};let c=new Map,h=a.account.label;for(let t of l.values){let r=null!=h&&t.author.name===h?"You":t.author.name,i=null!=h&&t.committer.name===h?"You":t.committer.name,s=c.get(t.oid);null==s&&(s=new p.Yg(this.container,e,t.oid,new p.M7(r,t.author.email,new Date(t.author.date),t.author.avatarUrl),new p.M7(i,t.committer.email,new Date(t.committer.date)),t.message.split(`
`,1)[0],t.parents.nodes.map(e=>e.oid),t.message,null!=t.files?{files:t.files.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0}))}:void 0,{files:t.changedFiles??0,additions:t.additions??0,deletions:t.deletions??0},[]),c.set(t.oid,s))}let f={repoPath:e,commits:c,sha:void 0,count:c.size,limit:d,hasMore:l.pageInfo?.hasNextPage??!1,endingCursor:l.pageInfo?.endCursor??void 0,query:t=>this.getLog(e,void 0,{...i,limit:t})};if(f.hasMore){let e=function(s){return async o=>{o=this.provider.getPagingLimit(o);let a=(await this.searchCommits(s.repoPath,t,r,{...i,limit:o,cursor:s.endingCursor})).log;if(null==a)return{...s,hasMore:!1,more:void 0};let n=new Map([...s.commits,...a.commits]),u={repoPath:s.repoPath,commits:n,sha:s.sha,count:n.size,limit:(s.limit??0)+o,hasMore:a.hasMore,endingCursor:a.endingCursor,query:s.query};return u.hasMore&&(u.more=e.call(this,u)),u}};f.more=e.call(this,f)}return{search:t,log:f}}catch(e){return A.Vy.error(e,o),{search:t,log:void 0}}}};Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getCommit",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getCommitCount",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getCommitFiles",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getCommitForFile",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getLeftRightCommitCount",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getLog",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getLogForPath",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getLogShas",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"getOldestUnpushedShaForPath",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"hasCommitBeenPushed",1),Y([(0,C.Rm)()],CommitsGitSubProvider.prototype,"isAncestorOf",1),Y([(0,C.Rm)({args:{1:e=>`[${e.matchAll?"A":""}${e.matchCase?"C":""}${e.matchRegex?"R":""}${e.matchWholeWord?"W":""}]: ${e.query.length>500?`${e.query.substring(0,500)}...`:e.query}`}})],CommitsGitSubProvider.prototype,"searchCommits",1);var J=Object.defineProperty,K=Object.getOwnPropertyDescriptor;let ConfigGitSubProvider=class ConfigGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getCurrentUser(e){if(!e)return;let t=(0,F.dQ)(),r=this.cache.repoInfo.get(e),i=r?.user;if(null!=i)return i;if(null!==i)try{let{metadata:t,github:s,session:o}=await this.provider.ensureRepositoryContext(e);return i=await s.getCurrentUser(o.accessToken,t.repo.owner,t.repo.name),this.cache.repoInfo.set(e,{...r,user:i??null}),i}catch(i){A.Vy.error(i,t),this.cache.repoInfo.set(e,{...r,user:null});return}}};((e,t,r,i)=>{for(var s,o=K(t,r),a=e.length-1;a>=0;a--)(s=e[a])&&(o=s(t,r,o)||o);return o&&J(t,r,o)})([(0,$.G)(),(0,C.Rm)()],ConfigGitSubProvider.prototype,"getCurrentUser",0);var Z=r(302),X=r(7186),ee=r(5864),et=r(8160),er=r(4684),ei=Object.defineProperty,es=Object.getOwnPropertyDescriptor,eo=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?es(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&ei(t,r,o),o};let ContributorsGitSubProvider=class ContributorsGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getContributors(e,t,r,i,s){let o;if(null==e)return{contributors:[]};let a=(0,F.dQ)(),n=async s=>{let o=[];try{let{metadata:s,github:a,session:n}=await this.provider.ensureRepositoryContext(e),u=await this.provider.config.getCurrentUser(e);if(r?.stats){let s,o=function(t,i){for(let s of t){let t=`${s.author.name}|${s.author.email}`,o=s.date.getTime(),a=i.get(t);if(null==a){let r="You"===s.author.name||(0,et.h)(u,s.author.name,s.author.email);a=new Z.s(e,r?u?.name??s.author.name:s.author.name,s.author.email,r,1,[{sha:s.sha,date:s.date,message:s.message??s.summary,files:(0,X.Zx)(s.stats?.files),additions:s.stats?.additions,deletions:s.stats?.deletions}],s.date,s.date,s.stats?{...s.stats,files:(0,X.Zx)(s.stats?.files),contributionScore:(0,ee.vV)(s.stats,o)}:void 0),i.set(t,a)}else{a.contributionCount++;let e=new Date(o);e>a.latestCommitDate&&(a.latestCommitDate=e),e<a.firstCommitDate&&(a.firstCommitDate=e),a.contributions??=[],a.contributions.push({sha:s.sha,date:new Date(o),message:s.message??s.summary,files:(0,X.Zx)(s.stats?.files),additions:s.stats?.additions,deletions:s.stats?.deletions}),r?.stats&&null!=s.stats&&(null==a.stats?a.stats={...s.stats,files:(0,X.Zx)(s.stats?.files),contributionScore:(0,ee.vV)(s.stats,o)}:a.stats={additions:a.stats.additions+s.stats.additions,deletions:a.stats.deletions+s.stats.deletions,files:a.stats.files+(0,X.Zx)(s.stats?.files),contributionScore:a.stats.contributionScore+(0,ee.vV)(s.stats,o)})}}};if(s=r?.pathspec?await this.provider.commits.getLogForPath(e,r.pathspec,t,{all:r?.all,since:r?.since}):await this.provider.commits.getLog(e,t,{all:r?.all,merges:r?.merges,since:r?.since}),null!=s){let e=new Map;for(o(s.commits.values(),e);s.hasMore&&(s=await s.more?.(void 0),null!=s);)o(s.pagedCommits?.().values()??[],e);return{contributors:[...e.values()],cancelled:i?.isCancellationRequested?{reason:"cancelled"}:void 0}}}for(let t of(await a.getContributors(n.accessToken,s.repo.owner,s.repo.name)))"User"===t.type&&o.push(new Z.s(e,t.name??t.login??"",t.email,(0,et.h)(u,t.name,t.email,t.login),t.contributions,void 0,void 0,void 0,void 0,t.login,t.avatar_url,t.node_id));return{contributors:o,cancelled:i?.isCancellationRequested?{reason:"cancelled"}:void 0}}catch(e){if(s?.cancelled(),A.Vy.error(e,a),!(0,c.MB)(e))return{contributors:[]};return{contributors:[...o.values()],cancelled:{reason:"cancelled"}}}},u=this.cache.contributors;if(null==u)return n();let l=t??"";r?.all&&(l+=":all"),r?.pathspec&&(l+=`:pathspec=${r.pathspec}`,o=3e5),r?.merges&&(l+=`:merges=${r.merges}`),r?.since&&(l+=`:since=${r.since}`,o=3e5),r?.stats&&(l+=":stats");let d=u.get(e);return null==d&&u.set(e,d=new er.o({accessTTL:36e5})),d.get(l,n,o?{accessTTL:o}:void 0)}async getContributorsLite(e,t,r,i){if(null==e)return[];let s=(0,F.dQ)();try{let{metadata:t,github:r,session:i}=await this.provider.ensureRepositoryContext(e),s=await this.provider.config.getCurrentUser(e),o=await r.getContributors(i.accessToken,t.repo.owner,t.repo.name),a=[];for(let t of o)"User"===t.type&&a.push(new Z.s(e,t.name??t.login??"",t.email,(0,et.h)(s,t.name,t.email,t.login),t.contributions,void 0,void 0,void 0,void 0,t.login,t.avatar_url,t.node_id));return a}catch(e){return A.Vy.error(e,s),[]}}async getContributorsStats(e,t,r,i){if(null==e)return;let s=(0,F.dQ)();try{let{metadata:t,github:r,session:i}=await this.provider.ensureRepositoryContext(e),s=(await r.getContributors(i.accessToken,t.repo.owner,t.repo.name)).map(e=>e.contributions).sort((e,t)=>t-e);return{count:s.length,contributions:s}}catch(e){A.Vy.error(e,s);return}}};eo([(0,C.Rm)()],ContributorsGitSubProvider.prototype,"getContributors",1),eo([(0,C.Rm)()],ContributorsGitSubProvider.prototype,"getContributorsLite",1),eo([(0,C.Rm)()],ContributorsGitSubProvider.prototype,"getContributorsStats",1);var ea=r(5001),en=Object.defineProperty,eu=Object.getOwnPropertyDescriptor,el=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?eu(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&en(t,r,o),o};let DiffGitSubProvider=class DiffGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getChangedFilesCount(e,t){if(!t)return;let r=await this.provider.commits.getCommit(e,t);if(r?.stats==null)return;let{stats:i}=r,s=(0,X.Zx)(i.files);return{additions:i.additions,deletions:i.deletions,files:s}}async getDiffStatus(e,t,r,i){let s,o;if(null==e)return;let a=(0,F.dQ)(),{metadata:n,github:u,session:l}=await this.provider.ensureRepositoryContext(e);if((0,w.p8)(t)){if(s=t,!(0,w.p8)(t,"qualified")){let e=(0,w.jY)(t);s=(0,w.Xn)(e?.left||"HEAD",e?.right||"HEAD",e?.notation??"...")}}else s=(0,w.Xn)(t||"HEAD",r||"HEAD","...");if((0,w.p8)(s,"qualified-double-dot")){let e=(0,w.jY)(s);s=(0,w.Xn)(e.left,e.right,"..."),o=(0,w.Xn)(e.right,e.left,"...")}try{let t=await u.getComparison(l.accessToken,n.repo.owner,n.repo.name,eY(s)),r=t?.files,i=r;if(o){t=await u.getComparison(l.accessToken,n.repo.owner,n.repo.name,eY(o));let e=t?.files;i=[...new Set((0,H.KC)(r,e))]}return i?.map(t=>new g.l(this.container,e,t.filename??"",(0,N.fromCommitFileStatus)(t.status)??m.NO.Modified,t.previous_filename,void 0,o?void 0:{additions:t.additions??0,deletions:t.deletions??0,changes:t.changes??0}))}catch(e){A.Vy.error(e,a);return}}async getNextComparisonUris(e,t,r,i=0){if(!r)return;let s=(0,F.dQ)();try{let s=await this.provider.ensureRepositoryContext(e);if(null==s)return;let{metadata:o,github:a,remotehub:n,session:u}=s,l=this.provider.getRelativePath(t,n.getProviderRootUri(t)),c=(await o.getRevision()).revision;"HEAD"===r&&(r=c);let d=await a.getNextCommitRefs(u.accessToken,o.repo.owner,o.repo.name,c,l,eY(r));return{current:0===i?B.nk.fromFile(l,e,r):new B.nk(await this.provider.getBestRevisionUri(e,l,d[i-1])),next:new B.nk(await this.provider.getBestRevisionUri(e,l,d[i]))}}catch(e){throw A.Vy.error(e,s),e}}async getPreviousComparisonUris(e,t,r,i=0,s){if(r===v.nB)return;let o=(0,F.dQ)();r===v.SU&&(r=void 0);try{let s=await this.provider.ensureRepositoryContext(e);if(null==s)return;let{metadata:o,github:a,remotehub:n,session:u}=s,l=this.provider.getRelativePath(t,n.getProviderRootUri(t)),c=+(null!=r),d=await a.getCommitRefs(u.accessToken,o.repo.owner,o.repo.name,eY(!r||"HEAD"===r?(await o.getRevision()).revision:r),{path:l,first:c+i+1});if(null==d)return;let h=0===i?B.nk.fromFile(l,e,r):new B.nk(await this.provider.getBestRevisionUri(e,l,d.values[c+i-1]?.oid??v.nB));if(null==h||h.sha===v.nB)return;return{current:h,previous:new B.nk(await this.provider.getBestRevisionUri(e,l,d.values[c+i]?.oid??v.nB))}}catch(e){throw A.Vy.error(e,o),e}}async getPreviousComparisonUrisForRange(e,t,r,i,s){if(r===v.nB)return;let o=(0,F.dQ)();try{let s,o=await this.provider.ensureRepositoryContext(e);if(null==o)return;let{remotehub:a}=o,n=this.provider.getRelativePath(t,a.getProviderRootUri(t)),u=(0,ea.J0)(i),l=B.nk.fromFile(n,e,r),c=u,d=u,h=u;for(let t=0;t<2;t++){let t=await this.provider.getBlameForLine(s??l,h,void 0,{forceSingleLine:!0});if(null==t)break;r=t.commit.sha,n=t.commit.file?.path??t.commit.file?.originalPath??n,h=t.line.originalLine-1;let i=B.nk.fromFile(n,e,r);null==s||(l=s,c=d),s=i,d=h}if(null==l)return;let p=null!=c?c+1:i.startLine;return{current:l,previous:s,range:{startLine:p,endLine:p,active:i.active}}}catch(e){throw A.Vy.error(e,o),e}}};el([(0,C.Rm)()],DiffGitSubProvider.prototype,"getChangedFilesCount",1),el([(0,C.Rm)()],DiffGitSubProvider.prototype,"getDiffStatus",1),el([(0,C.Rm)()],DiffGitSubProvider.prototype,"getNextComparisonUris",1),el([(0,C.Rm)()],DiffGitSubProvider.prototype,"getPreviousComparisonUris",1),el([(0,C.Rm)()],DiffGitSubProvider.prototype,"getPreviousComparisonUrisForRange",1);var ec=r(5225),ed=r(9389),eh=r(1558),ep=r(3287),eg=r(2331),em=r(1576),ef=r(8361),ev=r(5754),ey=Object.defineProperty,ew=Object.getOwnPropertyDescriptor,eb=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?ew(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&ey(t,r,o),o};let eR=/"/g;let GraphGitSubProvider=class GraphGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getGraph(e,t,r,i,s){let o=i?.limit??b.H.get("graph.defaultItemLimit")??5e3,a=b.H.get("graph.commitOrdering",void 0,"date"),n=b.H.get("graph.avatars",void 0,!0),[u,l,c,d,h,p]=await Promise.allSettled([this.provider.commits.getLog(e,!t||(0,w._k)(t)?"HEAD":t,{all:!0,ordering:a,limit:o}),this.provider.branches.getBranch(e),this.provider.branches.getBranches(e,{filter:e=>e.remote}),this.provider.remotes.getRemotes(e),this.provider.tags.getTags(e),this.provider.config.getCurrentUser(e)]),g=new Map,m=(0,S.Ro)(l),f=new Map,v=new Map;null!=m&&(f.set(m.name,m),null!=m.sha&&v.set(m.sha,[m.name]));let y=(0,S.Ro)(c)?.values;if(null!=y)for(let e of y){if(f.set(e.name,e),null==e.sha)continue;let t=v.get(e.sha);null==t?v.set(e.sha,[e.name]):t.push(e.name)}let R=new Set,P=(0,S.Ro)(d)[0],$=null!=P?new Map([[P.name,P]]):new Map,C=new Map,A=new Map,F=(0,S.Ro)(h)?.values;if(null!=F)for(let e of F){if(null==e.sha)continue;let t=A.get(e.sha);null==t?A.set(e.sha,[e.name]):t.push(e.name)}return this.getGraphCore(e,r,(0,S.Ro)(u),m,f,v,P,$,C,A,(0,S.Ro)(p),g,R,void 0,void 0,void 0,{...i,useAvatars:n})}getGraphCore(e,t,r,i,s,o,a,n,u,l,c,d,h,p,g,m,f){let v,y,w,b,R,P,$,C,A,F={...f?.include,stats:!0},q=new Map;if(null==r)return{repoPath:e,avatars:d,ids:h,includes:F,branches:s,remotes:n,downstreams:q,stashes:p,worktrees:g,worktreesByBranch:m,rows:[]};let S=(r.pagedCommits?.()??r.commits)?.values();if(null==S)return{repoPath:e,avatars:d,ids:h,includes:F,branches:s,remotes:n,downstreams:q,stashes:p,worktrees:g,worktreesByBranch:m,rows:[]};let U=[],k=!1,D=!1,I=i.upstream?.name;for(let r of S){if(h.add(r.sha),k=r.sha===i.sha)if(w={webviewItem:`gitlens:branch${k?"+current":""}${i?.upstream!=null?"+tracking":""}${i?.starred?"+starred":""}`,webviewItemValue:{type:"branch",ref:(0,em.kA)(i.name,e,{id:i.id,refType:"branch",name:i.name,remote:!1,upstream:i.upstream})}},R=[{id:i.id,name:i.name,isCurrentHead:!0,context:(0,ev.C9)(w),upstream:null!=i.upstream?{name:i.upstream.name,id:(0,eg.Yk)(e,!0,i.upstream.name)}:void 0}],null!=i.upstream){if(C=(0,eg.Yk)(e,!0,i.name),v=((f?.useAvatars?a.provider?.avatarUri:void 0)??(0,ep.Wf)(this.container,a,t))?.toString(!0),w={webviewItem:`gitlens:branch+remote${(0,eh.mw)(this.container,C)?"+starred":""}`,webviewItemValue:{type:"branch",ref:(0,em.kA)(i.name,e,{id:C,refType:"branch",name:i.name,remote:!0,upstream:{name:a.name,missing:!1}})}},P=[{id:C,name:i.name,owner:a.name,url:a.url,avatarUrl:v,context:(0,ev.C9)(w),current:!0,hostingServiceType:a.provider?.gkProviderId}],null!=I){let e=q.get(I);null==e&&(e=[],q.set(I,e)),e.push(i.name)}}else P=[];else{R=[],P=[];let i=o.get(r.sha);if(null!=i)for(let r of i)C=(0,eg.Yk)(e,!0,r),y=(0,eg.km)(r),v=((f?.useAvatars?a.provider?.avatarUri:void 0)??(0,ep.Wf)(this.container,a,t))?.toString(!0),w={webviewItem:`gitlens:branch+remote${(0,eh.mw)(this.container,C)?"+starred":""}`,webviewItemValue:{type:"branch",ref:(0,em.kA)(r,e,{id:C,refType:"branch",name:r,remote:!0,upstream:{name:a.name,missing:!1}})}},P.push({id:C,name:y,owner:a.name,url:a.url,avatarUrl:v,context:(0,ev.C9)(w),hostingServiceType:a.provider?.gkProviderId})}$=[];let s=l.get(r.sha);if(null!=s)for(let t of s)A=(0,ef.gt)(e,t),w={webviewItem:"gitlens:tag",webviewItemValue:{type:"tag",ref:(0,em.kA)(t,e,{id:A,refType:"tag",name:t})}},$.push({id:A,name:t,annotated:!0,context:(0,ev.C9)(w)});if(r.author.email&&!d.has(r.author.email)){let e=r.getCachedAvatarUri();null!=e&&d.set(r.author.email,e.toString(!0))}D="You"===r.author.name,b={row:(0,ev.C9)({webviewItem:`gitlens:commit${k?"+HEAD":""}+current`,webviewItemValue:{type:"commit",ref:(0,em.kA)(r.sha,e,{refType:"revision",message:r.message})}}),avatar:(0,ev.C9)({webviewItem:`gitlens:contributor${D?"+current":""}`,webviewItemValue:{type:"contributor",repoPath:e,name:D&&c?.name!=null?c.name:r.author.name,email:r.author.email,current:D}})},U.push({sha:r.sha,parents:r.parents,author:r.author.name,email:r.author.email??"",date:r.committer.date.getTime(),message:(0,ec.E)(r.message&&String(r.message).length?r.message:r.summary),type:r.parents.length>1?"merge-node":"commit-node",heads:R,remotes:P,tags:$,contexts:b}),null!=r.stats&&u.set(r.sha,{files:(0,X.Zx)(r.stats.files),additions:r.stats.additions,deletions:r.stats.deletions})}return f?.ref==="HEAD"?f.ref=(0,H.$1)(r.commits.values())?.sha:f?.ref!=null&&(f.ref=void 0),{repoPath:e,avatars:d,ids:h,includes:F,branches:s,remotes:n,downstreams:q,stashes:p,worktrees:g,worktreesByBranch:m,rows:U,id:f?.ref??(0,H.$1)(r.commits.values())?.sha,paging:{limit:r.limit,startingCursor:r.startingCursor,hasMore:r.hasMore},more:async(v,y,w)=>{let b=await r.more?.(v);return this.getGraphCore(e,t,b,i,s,o,a,n,u,l,c,d,h,p,g,m,f)}}}async searchGraph(e,t,r,i){t={matchAll:!1,matchCase:!1,matchRegex:!0,matchWholeWord:!1,...t};let s=(0,L.b4)(t);try{let a=t.query.includes("@me")?await this.provider.config.getCurrentUser(e):void 0,n=new Map,{args:u,filters:l,operations:c}=(0,L.O)(t,a),d=c.get("commit:");if(null!=d){let i=await Promise.allSettled((0,H.Tj)(d,t=>this.provider.commits.getCommit(e,t.replace(eR,"")))),o=0;for(let e of i){let t=(0,S.Ro)(e);null!=t&&n.set(t.sha,{i:o++,date:Number(r?.ordering==="author-date"?t.author.date:t.committer.date),files:t.fileset?.files})}return{repoPath:e,query:t,queryFilters:l,comparisonKey:s,results:n}}if(!u.length)return{repoPath:e,query:t,queryFilters:l,comparisonKey:s,results:n};let{metadata:h,github:p,session:g}=await this.provider.ensureRepositoryContext(e),m=`repo:${h.repo.owner}/${h.repo.name}+${u.join("+").trim()}`;async function o(a,u){if(i?.isCancellationRequested)return{repoPath:e,query:t,queryFilters:l,comparisonKey:s,results:n};a=this.provider.getPagingLimit(a??b.H.get("advanced.maxSearchItems"));let c=await p.searchCommitShas(g.accessToken,m,{cursor:u,limit:a,sort:r?.ordering==="date"?"committer-date":r?.ordering==="author-date"?"author-date":void 0});if(null==c||i?.isCancellationRequested)return{repoPath:e,query:t,queryFilters:l,comparisonKey:s,results:n};for(let e of c.values)n.set(e.sha,{i:n.size,date:Number(r?.ordering==="author-date"?e.authorDate:e.committerDate),files:void 0});return u=c.pageInfo?.endCursor??void 0,{repoPath:e,query:t,queryFilters:l,comparisonKey:s,results:n,paging:c.pageInfo?.hasNextPage?{limit:a,hasMore:!0}:void 0,more:async e=>o.call(this,e,u)}}return await o.call(this,r?.limit)}catch(e){if(e instanceof ed.Do)throw e;throw new ed.Do(e)}}};eb([(0,C.Rm)()],GraphGitSubProvider.prototype,"getGraph",1),eb([(0,C.Rm)({args:{1:e=>`[${e.matchAll?"A":""}${e.matchCase?"C":""}${e.matchRegex?"R":""}${e.matchWholeWord?"W":""}]: ${e.query.length>500?`${e.query.substring(0,500)}...`:e.query}`,2:e=>`limit=${e?.limit}, ordering=${e?.ordering}`}})],GraphGitSubProvider.prototype,"searchGraph",1);var eP=Object.defineProperty,e$=Object.getOwnPropertyDescriptor,eC=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?e$(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&eP(t,r,o),o};let eA=/^[^/](?!.*\/\.)(?!.*\.\.)(?!.*\/\/)(?!.*@\{)[^\x00-\x1F\x7F ~^:?*[\\]+[^./]$/;let RefsGitSubProvider=class RefsGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}checkIfCouldBeValidBranchOrTagName(e,t){return Promise.resolve(eA.test(e))}async getMergeBase(e,t,r,i,s){if(null==e)return;let o=(0,F.dQ)(),{metadata:a,github:n,session:u}=await this.provider.ensureRepositoryContext(e);try{let e=await n.getComparison(u.accessToken,a.repo.owner,a.repo.name,(0,w.Xn)(eY(t),eY(r),"..."));return e?.merge_base_commit?.sha}catch(e){A.Vy.error(e,o);return}}async getReference(e,t,r){if(t&&t!==v.nB&&await this.isValidReference(e,t)){if("HEAD"!==t&&!(0,w.X$)(t)){let r=await this.provider.branches.getBranch(e,t);if(null!=r)return(0,em.kA)(r.ref,e,{id:r.id,refType:"branch",name:r.name,remote:r.remote,upstream:r.upstream});let i=await this.provider.tags.getTag(e,t);if(null!=i)return(0,em.kA)(i.ref,e,{id:i.id,refType:"tag",name:i.name})}return(0,em.kA)(t,e,{refType:"revision"})}}async hasBranchOrTag(e,t,r){let[{values:i},{values:s}]=await Promise.all([this.provider.branches.getBranches(e,{filter:t?.filter?.branches,sort:!1},r),this.provider.tags.getTags(e,{filter:t?.filter?.tags,sort:!1},r)]);return 0!==i.length||0!==s.length}isValidReference(e,t,r,i){return Promise.resolve(!0)}updateReference(e,t,r,i){return Promise.resolve()}};eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"checkIfCouldBeValidBranchOrTagName",1),eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"getMergeBase",1),eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"getReference",1),eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"hasBranchOrTag",1),eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"isValidReference",1),eC([(0,C.Rm)()],RefsGitSubProvider.prototype,"updateReference",1);var eF=r(1485),eq=r(7444),eS=r(9261),eU=Object.defineProperty,ek=Object.getOwnPropertyDescriptor;let RemotesGitSubProvider=class RemotesGitSubProvider extends eS.G{async getRemotes(e,t){if(null==e)return[];let r=(0,eq.$)(null,void 0),[,i,s]=a.Uri.parse(e,!0).path.split("/",3),o=`https://github.com/${i}/${s}.git`,n="https",u="github.com",l=`${i}/${s}`;return[new eF.X(this.container,e,"origin",n,u,l,(await (0,eq.m)(this.container,r))(o,u,l,n),[{type:"fetch",url:o},{type:"push",url:o}])]}};((e,t,r,i)=>{for(var s,o=ek(t,r),a=e.length-1;a>=0;a--)(s=e[a])&&(o=s(t,r,o)||o);return o&&eU(t,r,o)})([(0,C.Rm)({args:{1:!1}})],RemotesGitSubProvider.prototype,"getRemotes",0);var eD=Object.defineProperty,eI=Object.getOwnPropertyDescriptor,eG=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?eI(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&eD(t,r,o),o};let RevisionGitSubProvider=class RevisionGitSubProvider{constructor(e,t){this.container=e,this.provider=t}async getRevisionContent(e,t,r){let i=t?this.provider.createProviderUri(e,t,r):this.provider.createVirtualUri(e,t,r);return a.workspace.fs.readFile(i)}async getTreeEntryForRevision(e,t,r){if(null==e||!r)return;if(r&&(r=this.provider.getRelativePath(r,e)),"HEAD"===t){let r=await this.provider.ensureRepositoryContext(e);if(null==r)return;let i=await r.metadata.getRevision();t=i?.revision}let i=t?this.provider.createProviderUri(e,t,r):this.provider.createVirtualUri(e,t,r),s=await a.workspace.fs.stat(i);if(null!=s)return{ref:t,oid:"",path:this.provider.getRelativePath(i,e),size:s.size,type:(s.type&a.FileType.Directory)===a.FileType.Directory?"tree":"blob"}}async getTreeForRevision(e,t){if(null==e)return[];if("HEAD"===t){let r=await this.provider.ensureRepositoryContext(e);if(null==r)return[];let i=await r.metadata.getRevision();t=i?.revision}let r=t?this.provider.createProviderUri(e,t):this.provider.createVirtualUri(e,t),i=await a.workspace.fs.readDirectory(r);if(null==i)return[];let s=[];for(let[e,o]of i){let i=this.provider.getAbsoluteUri(e,r);s.push({ref:t,oid:"",path:this.provider.getRelativePath(e,i),size:0,type:(o&a.FileType.Directory)===a.FileType.Directory?"tree":"blob"})}return[]}async resolveRevision(e,t,r){let i;if(!t||t===v.nB)return{sha:t,revision:t};if(null==r){if((0,w.HH)(t)||t.endsWith("^3"))return{sha:t,revision:t}}else{if((0,w.RK)(t)&&(t="HEAD"),(0,w._k)(t))return{sha:t,revision:t};i=this.provider.getRelativePath(r,e)}let s=await this.provider.ensureRepositoryContext(e);if(null==s)return{sha:t,revision:t};let{metadata:o,github:a,session:n}=s,u=await a.resolveReference(n.accessToken,o.repo.owner,o.repo.name,eY(t),i);return null==u?{sha:i?v.nB:t,revision:t}:{sha:u,revision:(0,w.hg)(t)?u:t}}};eG([(0,$.G)(),(0,C.Rm)()],RevisionGitSubProvider.prototype,"getRevisionContent",1),eG([(0,$.G)(),(0,C.Rm)()],RevisionGitSubProvider.prototype,"getTreeEntryForRevision",1),eG([(0,$.G)(),(0,C.Rm)()],RevisionGitSubProvider.prototype,"getTreeForRevision",1),eG([(0,C.Rm)()],RevisionGitSubProvider.prototype,"resolveRevision",1);var eE=r(7569),ex=Object.defineProperty,eT=Object.getOwnPropertyDescriptor;let StatusGitSubProvider=class StatusGitSubProvider{constructor(e,t){this.container=e,this.provider=t}async getStatus(e,t){if(null==e)return;let r=await this.provider.ensureRepositoryContext(e);if(null==r)return;let i=await r.metadata.getRevision();if(null!=i)return new eE.l(this.container,e,i.name,i.revision,[],i.type===I.Branch||i.type===I.RemoteBranch?{name:`origin/${i.name}`,missing:!1,state:{ahead:0,behind:0}}:void 0)}hasWorkingChanges(){return Promise.resolve(!1)}getWorkingChangesState(){return Promise.resolve({staged:!1,unstaged:!1,untracked:!1})}hasConflictingFiles(){return Promise.resolve(!1)}getConflictingFiles(){return Promise.resolve([])}getUntrackedFiles(){return Promise.resolve([])}};((e,t,r,i)=>{for(var s,o=eT(t,r),a=e.length-1;a>=0;a--)(s=e[a])&&(o=s(t,r,o)||o);return o&&ex(t,r,o)})([(0,$.G)(),(0,C.Rm)()],StatusGitSubProvider.prototype,"getStatus",0);var e_=r(6791),eO=Object.defineProperty,ej=Object.getOwnPropertyDescriptor,eB=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?ej(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&eO(t,r,o),o};let eL=Object.freeze({values:[]});let TagsGitSubProvider=class TagsGitSubProvider{constructor(e,t,r){this.container=e,this.cache=t,this.provider=r}async getTag(e,t,r){let{values:[i]}=await this.getTags(e,{filter:e=>e.name===t},r);return i}async getTags(e,t,r){if(null==e)return eL;let i=(0,F.dQ)(),s=t?.paging?.cursor?void 0:this.cache.tags?.getOrCreate(e,async r=>{try{let r,i,{metadata:s,github:o,session:a}=await this.provider.ensureRepositoryContext(e),n=[],u=t?.paging?.cursor,l=null==u;for(;;){let t=await o.getTags(a.accessToken,s.repo.owner,s.repo.name,{cursor:u});for(let s of t.values)r=s.target.authoredDate??s.target.target?.authoredDate??s.target.tagger?.date,i=s.target.committedDate??s.target.target?.committedDate??s.target.tagger?.date,n.push(new e_.r(this.container,e,s.name,s.target.target?.oid??s.target.oid,s.target.message??s.target.target?.message??"",null!=r?new Date(r):void 0,null!=i?new Date(i):void 0));if(!t.paging?.more||!l)return{...t,values:n};u=t.paging.cursor}}catch(e){return r.cancelled(),A.Vy.error(e,i),eL}});if(null==s)return eL;let o=await s;return t?.filter!=null&&(o={...o,values:o.values.filter(t.filter)}),t?.sort!=null&&(0,x.uO)(o.values,"boolean"==typeof t.sort?void 0:t.sort),o}async getTagsWithCommit(e,t,r,i){if(null==e||r?.commitDate==null)return[];let s=(0,F.dQ)();try{let{metadata:i,github:s,session:o}=await this.provider.ensureRepositoryContext(e);return await s.getTagsWithCommit(o.accessToken,i.repo.owner,i.repo.name,eY(t),r?.commitDate)}catch(e){return A.Vy.error(e,s),[]}}};eB([(0,C.Rm)()],TagsGitSubProvider.prototype,"getTag",1),eB([(0,C.Rm)({args:{1:!1}})],TagsGitSubProvider.prototype,"getTags",1),eB([(0,C.Rm)()],TagsGitSubProvider.prototype,"getTagsWithCommit",1);var ez=Object.defineProperty,eM=Object.getOwnPropertyDescriptor,eH=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?eM(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&ez(t,r,o),o};let eN=Promise.resolve(void 0),eQ=["repo","read:user","user:email"];let GitHubGitProvider=class GitHubGitProvider{constructor(e){this.container=e,this._cache=new d.V(this.container),this._disposables.push(this._onDidChange,this._onWillChangeRepository,this._onDidChangeRepository,this._onDidCloseRepository,this._onDidOpenRepository,this._cache,a.authentication.onDidChangeSessions(this.onAuthenticationSessionsChanged,this))}descriptor={id:"github",name:"GitHub",virtual:!0};authenticationDescriptor={domain:"github.com",scopes:eQ};authenticationProviderId=l.$r.GitHub;supportedSchemes=new Set([u.xB.Virtual,u.xB.GitHub,u.xB.PRs]);_onDidChange=new a.EventEmitter;get onDidChange(){return this._onDidChange.event}_onWillChangeRepository=new a.EventEmitter;get onWillChangeRepository(){return this._onWillChangeRepository.event}_onDidChangeRepository=new a.EventEmitter;get onDidChangeRepository(){return this._onDidChangeRepository.event}_onDidCloseRepository=new a.EventEmitter;get onDidCloseRepository(){return this._onDidCloseRepository.event}_onDidOpenRepository=new a.EventEmitter;get onDidOpenRepository(){return this._onDidOpenRepository.event}_cache;_disposables=[];dispose(){this._disposables.forEach(e=>void e.dispose())}onAuthenticationSessionsChanged(e){e.provider.id===this.authenticationProviderId&&(this._sessionPromise=void 0,this.ensureSession(!1,!0))}onRepositoryChanged(e,t){this._cache.clearCaches(e.path),this._onWillChangeRepository.fire(t)}async discoverRepositories(e,t){if(!this.supportedSchemes.has(e.scheme))return[];try{let{remotehub:r}=await this.ensureRepositoryContext(e.toString(),!0),i=r.getVirtualWorkspaceUri(e);if(null==i)return[];return this.openRepository(void 0,i,!0,t?.silent)}catch(t){return t.message.startsWith("No provider registered with")&&(A.Vy.error(t,"No GitHub provider registered with Remote Repositories (yet); queuing pending discovery"),this._pendingDiscovery.add(e),this.ensurePendingRepositoryDiscovery()),[]}}_pendingDiscovery=new Set;_pendingTimer;ensurePendingRepositoryDiscovery(){null==this._pendingTimer&&0!==this._pendingDiscovery.size&&(this._pendingTimer=setTimeout(async()=>{try{let e=await D();for(let t of this._pendingDiscovery){if(null==e.getProvider(t)){this._pendingTimer=void 0,this.ensurePendingRepositoryDiscovery();return}this._pendingDiscovery.delete(t)}this._pendingTimer=void 0,setTimeout(()=>this._onDidChange.fire(),1),0!==this._pendingDiscovery.size&&this.ensurePendingRepositoryDiscovery()}catch{this._pendingTimer=void 0,this.ensurePendingRepositoryDiscovery()}},250))}updateContext(){(0,R.o)("gitlens:hasVirtualFolders",this.container.git.hasOpenRepositories(this.descriptor.id))}openRepository(e,t,r,i){return[new f.LN(this.container,{onDidRepositoryChange:this._onDidChangeRepository,onRepositoryChanged:this.onRepositoryChanged.bind(this)},this.descriptor,e??a.workspace.getWorkspaceFolder(t),t,r,i)]}async supports(e){let t;return t="timeline"===e,(0,R.o)(`gitlens:feature:unsupported:${e}`,!t),t}async visibility(e){let t=await this.remotes.getRemotes(e,{sort:!0});if(0===t.length)return["local",void 0];for await(let e of(0,S.w)(t.map(e=>this.getRemoteVisibility(e))))if("fulfilled"===e.status&&"public"===e.value[0])return["public",(0,y.U6)(e.value[1])];return["private",(0,y.U6)(t)]}async getRemoteVisibility(e){if(e.provider?.id!=="github")return["private",e];{let{github:t,metadata:r,session:i}=await this.ensureRepositoryContext(e.repoPath);return[await t.getRepositoryVisibility(i.accessToken,r.repo.owner,r.repo.name)??"private",e]}}async getOpenScmRepositories(){return[]}async getScmRepository(e){}async getOrOpenScmRepository(e){}canHandlePathOrUri(e,t){if(this.supportedSchemes.has(e))return"string"==typeof t?t:t.toString()}getAbsoluteUri(e,t){if("string"==typeof t)if((0,q.bm)(t))t=a.Uri.parse(t,!0);else throw a.window.showErrorMessage(`Unable to get absolute uri between ${"string"==typeof e?e:e.toString(!0)} and ${t}; Base path '${t}' must be a uri`),Error(`Base path '${t}' must be a uri`);if("string"==typeof e&&!(0,q.bm)(e)){let r=(0,q.Fd)(e);if(!(0,q.oP)(r))return a.Uri.joinPath(t,r)}let r=this.getRelativePath(e,t);return a.Uri.joinPath(t,r)}async getBestRevisionUri(e,t,r){return r?this.createProviderUri(e,r,t):this.createVirtualUri(e,r,t)}getRelativePath(e,t){let r;if("string"==typeof t)if((0,q.bm)(t))t=a.Uri.parse(t,!0);else throw a.window.showErrorMessage(`Unable to get relative path between ${"string"==typeof e?e:e.toString(!0)} and ${t}; Base path '${t}' must be a uri`),Error(`Base path '${t}' must be a uri`);if("string"==typeof e)if(!(0,q.bm)(e))return e=(0,q.Fd)(e),(r=(0,q.oP)(e)&&e.startsWith(t.path)?e.slice(t.path.length):e).charCodeAt(0)===u.s7.Slash&&(r=r.slice(1)),r;else e=a.Uri.parse(e,!0);return(0,q.Fd)((0,P.V8)(t.path.slice(1),e.path.slice(1)))}getRevisionUri(e,t,r){let i=this.createProviderUri(e,t,r);return t===v.nB?i.with({query:"~"}):i}async getWorkingUri(e,t){return this.createVirtualUri(e,void 0,t.path)}async excludeIgnoredUris(e,t){return t}async findRepositoryUri(e,t){let r=(0,F.dQ)();try{let t=await this.ensureRemoteHubApi();return await eV(e,t,e=>t.getProviderRootUri(e).with({scheme:u.xB.Virtual}))}catch(e){c.dU,A.Vy.error(e,r);return}}async getBlame(e,t){let r=(0,F.dQ)();if(t?.isDirty)return;let i="blame";null!=e.sha&&(i+=`:${e.sha}`);let s=await this.container.documentTracker.getOrAdd(e);if(null!=s.state){let e=s.state.getBlame(i);if(null!=e)return A.Vy.debug(r,`Cache hit: '${i}'`),e.item}A.Vy.debug(r,`Cache miss: '${i}'`),null==s.state&&(s.state=new U.VV);let o=this.getBlameCore(e,s,i,r);return null!=s.state&&(A.Vy.debug(r,`Cache add: '${i}'`),s.state.setBlame(i,{item:o})),o}async getBlameCore(e,t,r,i){try{let t=await this.ensureRepositoryContext(e.repoPath);if(null==t)return;let{metadata:r,github:i,remotehub:s,session:o}=t,n=s.getVirtualUri(s.getProviderRootUri(e)),l=this.getRelativePath(e,n);if(e.scheme===u.xB.Virtual){let[t,r]=await Promise.allSettled([a.workspace.fs.stat(e),a.workspace.fs.stat(e.with({scheme:u.xB.GitHub}))]);if("fulfilled"!==t.status||"fulfilled"!==r.status||t.value.mtime!==r.value.mtime)return}let c=e.sha&&"HEAD"!==e.sha?e.sha:(await r.getRevision()).revision,d=await i.getBlame(o.accessToken,r.repo.owner,r.repo.name,c,l),h=new Map,f=new Map,v=[];for(let t of d.ranges){let r=t.commit,{viewer:i=o.account.label}=d,s=null!=i&&r.author.name===i?"You":r.author.name,a=null!=i&&r.committer.name===i?"You":r.committer.name,u=h.get(s);null==u&&(u={name:s,lineCount:0},h.set(s,u)),u.lineCount+=t.endingLine-t.startingLine+1;let c=f.get(r.oid);null==c&&(c=new p.Yg(this.container,e.repoPath,r.oid,new p.M7(s,r.author.email,new Date(r.author.date),r.author.avatarUrl),new p.M7(a,r.committer.email,new Date(r.author.date)),r.message.split(`
`,1)[0],r.parents.nodes[0]?.oid?[r.parents.nodes[0]?.oid]:[],r.message,{files:void 0,filtered:{files:[new g.l(this.container,n.toString(),l,m.NO.Modified)],pathspec:l}},{files:r.changedFiles??0,additions:r.additions??0,deletions:r.deletions??0},[]),f.set(r.oid,c));for(let e=t.startingLine;e<=t.endingLine;e++){let t={sha:r.oid,originalLine:e,line:e};c.lines.push(t),v[e-1]=t}}let y=new Map([...h.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount));return{repoPath:e.repoPath,authors:y,commits:f,lines:v}}catch(e){if(null!=t.state&&!String(e).includes("No provider registered with")){let s=e?.toString()??"";return A.Vy.debug(i,`Cache replace (with empty promise): '${r}'`),t.state.setBlame(r,{item:eN,errorMessage:s}),t.setBlameFailure(e),eN}return}}async getBlameContents(e,t){}async getBlameForLine(e,t,r,i){let s=(0,F.dQ)();if(!r?.isDirty){if(!i?.forceSingleLine){let r=await this.getBlame(e);if(null==r)return;let i=r.lines[t];if(null==i){if(r.lines.length!==t)return;i=r.lines[t-1]}let s=r.commits.get(i.sha);if(null==s)return;return{author:{...r.authors.get(s.author.name),lineCount:s.lines.length},commit:s,line:i}}try{let r=await this.ensureRepositoryContext(e.repoPath);if(null==r)return;let{metadata:i,github:s,remotehub:o,session:a}=r,n=o.getVirtualUri(o.getProviderRootUri(e)),u=this.getRelativePath(e,n),l=e.sha&&"HEAD"!==e.sha?e.sha:(await i.getRevision()).revision,c=await s.getBlame(a.accessToken,i.repo.owner,i.repo.name,l,u),d=t+1,h=c.ranges.find(e=>e.startingLine===d);if(null==h)return;let f=h.commit,{viewer:v=a.account.label}=c,y=null!=v&&f.author.name===v?"You":f.author.name,w=null!=v&&f.committer.name===v?"You":f.committer.name,b=new p.Yg(this.container,e.repoPath,f.oid,new p.M7(y,f.author.email,new Date(f.author.date),f.author.avatarUrl),new p.M7(w,f.committer.email,new Date(f.author.date)),f.message.split(`
`,1)[0],f.parents.nodes[0]?.oid?[f.parents.nodes[0]?.oid]:[],f.message,{files:void 0,filtered:{files:[new g.l(this.container,n.toString(),u,m.NO.Modified)],pathspec:u}},{files:f.changedFiles??0,additions:f.additions??0,deletions:f.deletions??0},[]);for(let e=h.startingLine;e<=h.endingLine;e++){let t={sha:f.oid,originalLine:e,line:e};b.lines.push(t)}return{author:{name:y,lineCount:h.endingLine-h.startingLine+1},commit:b,line:{sha:f.oid,originalLine:h.startingLine,line:h.startingLine}}}catch(e){A.Vy.error(e,s);return}}}async getBlameForLineContents(e,t,r,i){}async getBlameForRange(e,t){let r=await this.getBlame(e);if(null!=r)return this.getBlameRange(r,e,t)}async getBlameForRangeContents(e,t,r){let i=await this.getBlameContents(e,r);if(null!=i)return this.getBlameRange(i,e,t)}getBlameRange(e,t,r){if(0===e.lines.length||0===r.start.line&&r.end.line===e.lines.length-1)return e;let i=e.lines.slice(r.start.line,r.end.line+1),s=new Set(i.map(e=>e.sha)),o=r.start.line+1,a=r.end.line+1,n=new Map,u=new Map;for(let t of e.commits.values()){if(!s.has(t.sha))continue;let e=t.with({lines:t.lines.filter(e=>e.line>=o&&e.line<=a)});u.set(t.sha,e);let r=n.get(e.author.name);null==r&&(r={name:e.author.name,lineCount:0},n.set(r.name,r)),r.lineCount+=e.lines.length}let l=new Map([...n.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount));return{repoPath:t.repoPath,authors:l,commits:u,lines:i}}async getDiffForFile(e,t,r){}async getDiffForFileContents(e,t,r){}async getDiffForLine(e,t,r,i){}async getLastFetchedTimestamp(e){}isTrackable(e){return this.supportedSchemes.has(e.scheme)}async isTracked(e){if(!this.isTrackable(e)||null==this.container.git.getRepository(e))return!1;let t=e.with({scheme:u.xB.GitHub});return null!=await a.workspace.fs.stat(t)}_branches;get branches(){return this._branches??=new BranchesGitSubProvider(this.container,this._cache,this)}_commits;get commits(){return this._commits??=new CommitsGitSubProvider(this.container,this._cache,this)}_config;get config(){return this._config??=new ConfigGitSubProvider(this.container,this._cache,this)}_contributors;get contributors(){return this._contributors??=new ContributorsGitSubProvider(this.container,this._cache,this)}_diff;get diff(){return this._diff??=new DiffGitSubProvider(this.container,this._cache,this)}_graph;get graph(){return this._graph??=new GraphGitSubProvider(this.container,this._cache,this)}_refs;get refs(){return this._refs??=new RefsGitSubProvider(this.container,this._cache,this)}_remotes;get remotes(){return this._remotes??=new RemotesGitSubProvider(this.container,this._cache,this)}_revision;get revision(){return this._revision??=new RevisionGitSubProvider(this.container,this)}_status;get status(){return this._status??=new StatusGitSubProvider(this.container,this)}_tags;get tags(){return this._tags??=new TagsGitSubProvider(this.container,this._cache,this)}async ensureRepositoryContext(e,t){let r,i,s=a.Uri.parse(e,!0);if(!/^github\+?/.test(s.authority))throw new c.gK(e,c.ax.NotAGitHubRepository);if(!t){let t=this.container.git.getRepository(s);if(null==t)throw new c.gK(e,c.ax.NotAGitHubRepository);s=t.uri}let o=this._remotehub;if(null==o)try{o=await this.ensureRemoteHubApi()}catch(t){throw!(t instanceof c.dU),new c.gK(e,c.ax.RemoteHubApiNotFound,t)}let n=await eV(s,o,e=>o?.getMetadata(e));if(n?.provider.id!=="github")throw new c.gK(e,c.ax.NotAGitHubRepository);let u=(0,h.JG)(s.authority);if(u.metadata?.ref?.type===G.PullRequest){let e=await n.getRevision();if(e.type===I.RemoteBranch){let[t]=e.name.split(":");t!==n.repo.owner&&(n.repo.owner=t)}}try{[r,i]=await Promise.all([this.ensureGitHub(),this.ensureSession()])}catch(t){if(t instanceof c.v3)throw new c.gK(e,t.reason===c.R.UserDidNotConsent?c.ax.GitHubAuthenticationDenied:c.ax.GitHubAuthenticationNotFound,t);throw new c.gK(e)}if(null==r)throw new c.gK(e);return{github:r,metadata:n,remotehub:o,session:i}}_github;async ensureGitHub(){if(null==this._github){let e=await this.container.github;null!=e&&this._disposables.push(e.onDidReauthenticate(()=>void this.ensureSession(!0))),this._github=e}return this._github}_remotehub;_remotehubPromise;async ensureRemoteHubApi(e){if(null==this._remotehubPromise&&(this._remotehubPromise=D(),this._remotehubPromise.then(e=>this._remotehub=e,()=>this._remotehub=void 0)),!e)return this._remotehubPromise;try{return await this._remotehubPromise}catch{return}}_sessionPromise;async ensureSession(e=!1,t=!1){if(e||null==this._sessionPromise){async function r(){let i=this.container.storage.get(`provider:authentication:skip:${this.descriptor.id}`,!1);try{let r;if(e?(i=!1,this.container.storage.delete(`provider:authentication:skip:${this.descriptor.id}`),r=await (0,k.c)(this.container,l.$r.GitHub,this.authenticationDescriptor,{forceNewSession:!0})):r=i||t?await (0,k.c)(this.container,l.$r.GitHub,this.authenticationDescriptor):await (0,k.c)(this.container,l.$r.GitHub,this.authenticationDescriptor,{createIfNeeded:!0}),null!=r)return r;throw Error("User did not consent")}catch(s){if(s instanceof Error&&s.message.includes("User did not consent")){if(!t&&(await this.container.storage.store(`provider:authentication:skip:${this.descriptor.id}`,!0),!i))return e||queueMicrotask(async()=>{let e="Re-enable";await a.window.showInformationMessage("GitLens has been disabled. Authentication is required for GitLens to work with remote GitHub repositories.",e)===e&&this.ensureSession(!0)}),e=!1,r.call(this);throw new c.v3("github",c.R.UserDidNotConsent)}throw A.Vy.error(s),new c.v3("github",void 0,s)}}this._sessionPromise=r.call(this)}return this._sessionPromise}createVirtualUri(e,t,r){var i;let s;if("string"==typeof t)t&&(s=(0,w.HH)(t)?{v:1,ref:{id:t,type:2}}:{v:1,ref:{id:t,type:4}});else switch(t?.refType){case"revision":case"stash":s={v:1,ref:{id:t.ref,type:2}};break;case"branch":case"tag":s={v:1,ref:{id:t.name,type:4}}}if("string"==typeof e&&(e=a.Uri.parse(e,!0)),r){let t=e.path;t.endsWith("/")&&(t=t.slice(0,-1)),r=this.getRelativePath(r,e),r=`${t}/${r.startsWith("/")?r.slice(0,-1):r}`}return e.with({scheme:u.xB.Virtual,authority:(i=s,`github${null!=i?`+${(0,n.lw)(JSON.stringify(i))}`:""}`),path:r??e.path})}createProviderUri(e,t,r){let i=this.createVirtualUri(e,t,r);return null==this._remotehub?i.scheme!==u.xB.Virtual?i:i.with({scheme:u.xB.GitHub}):this._remotehub.getProviderUri(i)}getPagingLimit(e){return 0===(e=Math.min(100,e??b.H.get("advanced.maxListItems")??100))&&(e=100),e}async resolveReferenceCore(e,t,r){if(null==r||"HEAD"===r)return(await t.getRevision()).revision;if((0,w.HH)(r))return r;if((0,w.p8)(r))return;let[i,s]=await Promise.allSettled([this.branches.getBranches(e,{filter:e=>e.name===r}),this.tags.getTags(e,{filter:e=>e.name===r})]);return r=(0,S.Ro)(i)?.values[0]?.sha??(0,S.Ro)(s)?.values[0]?.sha}};async function eV(e,t,r){let s=!1;for(;;)try{return await r(e)}catch(r){if(!s&&(/No provider registered/i.test(r.message)||null==t.getProvider(e))){i??=t.loadWorkspaceContents(e);try{await i,s=!0;continue}catch{}}throw r}}function eY(e){return e?.replace(/(?:^|(?<=..))origin\//,"")}eH([(0,C.Rm)()],GitHubGitProvider.prototype,"getBestRevisionUri",1),eH([(0,C.Rm)()],GitHubGitProvider.prototype,"getWorkingUri",1),eH([(0,C.Rm)({args:{1:e=>e.length}})],GitHubGitProvider.prototype,"excludeIgnoredUris",1),eH([(0,$.G)(),(0,C.Yz)()],GitHubGitProvider.prototype,"findRepositoryUri",1),eH([(0,$.G)((e,t)=>`${e.toString()}|${t?.isDirty}`),(0,C.Rm)({args:{1:e=>e?.isDirty}})],GitHubGitProvider.prototype,"getBlame",1),eH([(0,C.Rm)({args:{1:"<contents>"}})],GitHubGitProvider.prototype,"getBlameContents",1),eH([(0,$.G)((e,t,r,i)=>`${e.toString()}|${t}|${r?.isDirty}|${i?.forceSingleLine}`),(0,C.Rm)({args:{2:e=>e?.isDirty}})],GitHubGitProvider.prototype,"getBlameForLine",1),eH([(0,C.Rm)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForLineContents",1),eH([(0,C.Rm)()],GitHubGitProvider.prototype,"getBlameForRange",1),eH([(0,C.Rm)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getBlameForRangeContents",1),eH([(0,C.Rm)({args:{0:"<blame>"}})],GitHubGitProvider.prototype,"getBlameRange",1),eH([(0,C.Rm)()],GitHubGitProvider.prototype,"getDiffForFile",1),eH([(0,C.Rm)({args:{2:"<contents>"}})],GitHubGitProvider.prototype,"getDiffForFileContents",1),eH([(0,C.Rm)()],GitHubGitProvider.prototype,"getDiffForLine",1),eH([(0,$.G)()],GitHubGitProvider.prototype,"ensureRepositoryContext",1),eH([(0,$.G)()],GitHubGitProvider.prototype,"ensureGitHub",1)},7609:(e,t,r)=>{r.r(t),r.d(t,{fromGitLabMergeRequest:()=>l,fromGitLabMergeRequestProvidersApi:()=>u,fromGitLabMergeRequestREST:()=>n,fromGitLabMergeRequestState:()=>o,toGitLabMergeRequestState:()=>a});var i=r(99),s=r(3761);function o(e){return"locked"===e?"closed":e}function a(e){return e}function n(e,t,r){return new i.B9(t,{id:e.author?.id??"",name:e.author?.name??"Unknown",avatarUrl:e.author?.avatar_url??"",url:e.author?.web_url??""},String(e.iid),void 0,e.title,e.web_url,r,o(e.state),new Date(e.created_at),new Date(e.updated_at),null==e.closed_at?void 0:new Date(e.closed_at),null==e.merged_at?void 0:new Date(e.merged_at))}function u(e,t){let r={...e,id:String(e.number),permissions:e.permissions??{canMerge:!0,canMergeAndBypassProtections:!1}};return(0,s.QF)(r,t)}function l(e,t){let r;try{r=new URL(e.author?.avatarUrl??"").toString()}catch{try{let t=new URL(e.author?.webUrl??"");t.pathname="",t.search="",t.hash="",r=e.author?.avatarUrl?t.toString()+e.author?.avatarUrl:void 0}catch{r=void 0}}let[s,a]=e.project.fullPath.split("/");return new i.B9(t,{id:e.author?.id??"",name:e.author?.name??"Unknown",avatarUrl:r,url:e.author?.webUrl??""},e.iid,e.id,e.title,e.webUrl||"",{owner:s,repo:a,url:e.project.webUrl},o(e.state),new Date(e.createdAt),new Date(e.updatedAt),"closed"!==e.state?void 0:new Date(e.updatedAt),null==e.mergedAt?void 0:new Date(e.mergedAt),i.Q6.Unknown,void 0,function(e){if(null!=e.sourceProject)return{base:{owner:c(e.sourceProject.fullPath),branch:e.sourceBranch,exists:!0,url:e.sourceProject.webUrl,repo:e.sourceProject.fullPath,sha:e.diffRefs?.baseSha||""},head:{owner:c(e.project.fullPath),branch:e.targetBranch,exists:!0,url:e.project.webUrl,repo:e.project.fullPath,sha:e.diffRefs?.headSha||""},isCrossRepository:e.sourceProject.id!==e.project.id}}(e))}function c(e){return e.split("/").slice(0,-1).join("/")}},8841:(e,t,r)=>{r.r(t),r.d(t,{fromCommitFileStatus:()=>y,fromGitHubIssue:()=>f,fromGitHubIssueOrPullRequestState:()=>n,fromGitHubPullRequest:()=>m,fromGitHubPullRequestLite:()=>a,fromGitHubPullRequestMergeableState:()=>h,fromGitHubPullRequestReviewDecision:()=>l,fromGitHubPullRequestReviewState:()=>c,fromGitHubPullRequestStatusCheckRollupState:()=>g,toGitHubPullRequestMergeableState:()=>p,toGitHubPullRequestReviewDecision:()=>d,toGitHubPullRequestState:()=>u});var i=r(7523),s=r(3980),o=r(99);function a(e,t){return new o.B9(t,{id:e.author.login,name:e.author.login,avatarUrl:e.author.avatarUrl,url:e.author.url},String(e.number),e.id,e.title,e.permalink,{owner:e.repository.owner.login,repo:e.repository.name,accessLevel:v(e.repository.viewerPermission)},n(e.state),new Date(e.createdAt),new Date(e.updatedAt),null==e.closedAt?void 0:new Date(e.closedAt),null==e.mergedAt?void 0:new Date(e.mergedAt),void 0,void 0,{head:{exists:null!=e.headRepository,owner:e.headRepository?.owner.login,repo:e.headRepository?.name,sha:e.headRefOid,branch:e.headRefName,url:e.headRepository?.url},base:{exists:null!=e.repository,owner:e.repository?.owner.login,repo:e.repository?.name,sha:e.baseRefOid,branch:e.baseRefName,url:e.repository?.url},isCrossRepository:e.isCrossRepository},e.isDraft)}function n(e){return"MERGED"===e?"merged":"CLOSED"===e?"closed":"opened"}function u(e){return"merged"===e?"MERGED":"closed"===e?"CLOSED":"OPEN"}function l(e){switch(e){case"APPROVED":return o.dq.Approved;case"CHANGES_REQUESTED":return o.dq.ChangesRequested;case"REVIEW_REQUIRED":return o.dq.ReviewRequired}}function c(e){switch(e){case"APPROVED":return o.c7.Approved;case"CHANGES_REQUESTED":return o.c7.ChangesRequested;case"COMMENTED":return o.c7.Commented;case"DISMISSED":return o.c7.Dismissed;case"PENDING":return o.c7.Pending}}function d(e){switch(e){case o.dq.Approved:return"APPROVED";case o.dq.ChangesRequested:return"CHANGES_REQUESTED";case o.dq.ReviewRequired:return"REVIEW_REQUIRED"}}function h(e){switch(e){case"MERGEABLE":return o.Q6.Mergeable;case"CONFLICTING":return o.Q6.Conflicting;case"UNKNOWN":return o.Q6.Unknown}}function p(e){switch(e){case o.Q6.Mergeable:return"MERGEABLE";case o.Q6.Conflicting:return"CONFLICTING";case o.Q6.FailingChecks:case o.Q6.BlockedByPolicy:case o.Q6.Unknown:return"UNKNOWN"}}function g(e){switch(e){case"SUCCESS":case"EXPECTED":return o.gI.Success;case"FAILURE":case"ERROR":return o.gI.Failed;case"PENDING":return o.gI.Pending;default:return}}function m(e,t){return new o.B9(t,{id:e.author.login,name:e.author.login,avatarUrl:e.author.avatarUrl,url:e.author.url},String(e.number),e.id,e.title,e.permalink,{owner:e.repository.owner.login,repo:e.repository.name,accessLevel:v(e.repository.viewerPermission)},n(e.state),new Date(e.createdAt),new Date(e.updatedAt),null==e.closedAt?void 0:new Date(e.closedAt),null==e.mergedAt?void 0:new Date(e.mergedAt),h(e.mergeable),e.viewerCanUpdate,{head:{exists:null!=e.headRepository,owner:e.headRepository?.owner.login,repo:e.headRepository?.name,sha:e.headRefOid,branch:e.headRefName,url:e.headRepository?.url},base:{exists:null!=e.repository,owner:e.repository?.owner.login,repo:e.repository?.name,sha:e.baseRefOid,branch:e.baseRefName,url:e.repository?.url},isCrossRepository:e.isCrossRepository},e.isDraft,e.additions,e.deletions,e.totalCommentsCount,0,l(e.reviewDecision),e.reviewRequests.nodes.map(e=>null!=e.requestedReviewer?{isCodeOwner:e.asCodeOwner,reviewer:{id:e.requestedReviewer.login,name:e.requestedReviewer.login,avatarUrl:e.requestedReviewer.avatarUrl,url:e.requestedReviewer.url},state:o.c7.ReviewRequested}:void 0).filter(e=>!!e),e.latestReviews.nodes.map(e=>({reviewer:{id:e.author.login,name:e.author.login,avatarUrl:e.author.avatarUrl,url:e.author.url},state:c(e.state)})),e.assignees.nodes.map(e=>({id:e.login,name:e.login,avatarUrl:e.avatarUrl,url:e.url})),g(e.commits.nodes?.[0]?.commit.statusCheckRollup?.state))}function f(e,t){return new s.m2({id:t.id,name:t.name,domain:t.domain,icon:t.icon},String(e.number),e.id,e.title,e.url,new Date(e.createdAt),new Date(e.updatedAt),e.closed,n(e.state),{id:e.author.login,name:e.author.login,avatarUrl:e.author.avatarUrl,url:e.author.url},e.assignees.nodes.map(e=>({id:e.login,name:e.login,avatarUrl:e.avatarUrl,url:e.url})),{owner:e.repository.owner.login,repo:e.repository.name,accessLevel:v(e.repository.viewerPermission),url:e.repository.url},null==e.closedAt?void 0:new Date(e.closedAt),e.labels?.nodes==null?void 0:e.labels.nodes.map(e=>({color:e.color,name:e.name})),e.comments?.totalCount,e.reactions?.totalCount,e.body)}function v(e){switch(e){case"ADMIN":return s.LI.Admin;case"MAINTAIN":return s.LI.Maintain;case"WRITE":return s.LI.Write;case"TRIAGE":return s.LI.Triage;case"READ":return s.LI.Read;default:return s.LI.None}}function y(e){switch(e){case"added":return i.NO.Added;case"changed":case"modified":return i.NO.Modified;case"removed":return i.NO.Deleted;case"renamed":return i.NO.Renamed;case"copied":return i.NO.Copied}}},9580:(e,t,r)=>{r.r(t),r.d(t,{BitbucketServerIntegration:()=>BitbucketServerIntegration});var i=r(6202),s=r(4109),o=r(5817),a=r(3761);let n=a.Mt[s.RR.BitbucketServer],u=Object.freeze({id:n.id,scopes:n.scopes});let BitbucketServerIntegration=class BitbucketServerIntegration extends o.d{constructor(e,t,r,i,s){super(e,t,r,i),this._domain=s}authProvider=u;id=s.RR.BitbucketServer;key=`${this.id}:${this.domain}`;name="Bitbucket Data Center";get domain(){return this._domain}get apiBaseUrl(){let e=this._session?.protocol??"https:";return`${e}//${this.domain}/rest/api/1.0`}async mergeProviderPullRequest({accessToken:e},t,r){return(await this.getProvidersApi()).mergePullRequest(this.id,t,{accessToken:e,mergeMethod:r?.mergeMethod,baseUrl:this.apiBaseUrl})}async getProviderAccountForCommit({accessToken:e},t,r,i){return(await this.container.bitbucket)?.getServerAccountForCommit(this,e,t.owner,t.name,r,this.apiBaseUrl,{avatarSize:i?.avatarSize})}async getProviderAccountForEmail(e,t,r,i){return Promise.resolve(void 0)}async getProviderDefaultBranch(e,t){return Promise.resolve(void 0)}async getProviderLinkedIssueOrPullRequest({accessToken:e},t,{id:r},i){if("issue"!==i)return(await this.container.bitbucket)?.getServerPullRequestById(this,e,t.owner,t.name,r,this.apiBaseUrl)}async getProviderIssue(e,t,r){return Promise.resolve(void 0)}async getProviderPullRequestForBranch({accessToken:e},t,r,i){return(await this.container.bitbucket)?.getServerPullRequestForBranch(this,e,t.owner,t.name,r,this.apiBaseUrl)}async getProviderPullRequestForCommit({accessToken:e},t,r){return(await this.container.bitbucket)?.getServerPullRequestForCommit(this,e,t.owner,t.name,r,this.apiBaseUrl)}async getRepoInfo(e){return(await this.getProvidersApi()).getRepo(this.id,e.owner,e.name,void 0,{accessToken:this._session?.accessToken,baseUrl:this.apiBaseUrl})}async getProviderRepositoryMetadata(e,t,r){return Promise.resolve(void 0)}_accounts;async getProviderCurrentAccount({accessToken:e}){if(this._accounts??=new Map,null==this._accounts.get(e)){let t=await this.getProvidersApi(),r=await t.getCurrentUser(this.id,{accessToken:e,baseUrl:this.apiBaseUrl});this._accounts.set(e,r?{provider:this,id:r.id,name:r.name??void 0,email:r.email??void 0,avatarUrl:r.avatarUrl??void 0,username:r.username??void 0}:void 0)}return this._accounts.get(e)}async searchProviderMyPullRequests(e,t){if(null!=t)return;let r=await this.getProvidersApi();if(!r)return;let i=await r.getBitbucketServerPullRequestsForCurrentUser(this.apiBaseUrl,{accessToken:e.accessToken});return i?.map(e=>(0,a.QF)(e,this))}async searchProviderMyIssues(e,t){return Promise.resolve(void 0)}storagePrefix="bitbucket-server";async providerOnConnect(){if(null==this._session)return;let e=(0,i.Fx)(this._session.accessToken),t=this.container.storage.get(`${this.storagePrefix}:${e}:account`),r=t?.data?{...t.data,provider:this}:void 0;null==t&&null!=(r=await this.getProviderCurrentAccount(this._session))&&(await this.container.storage.deleteWithPrefix(this.storagePrefix),await this.container.storage.store(`${this.storagePrefix}:${e}:account`,{v:1,timestamp:Date.now(),data:{id:r.id,name:r.name,email:r.email,avatarUrl:r.avatarUrl,username:r.username}})),this._accounts??=new Map,this._accounts.set(this._session.accessToken,r)}providerOnDisconnect(){this._accounts=void 0}}},9792:(e,t,r)=>{r.r(t),r.d(t,{BitbucketApi:()=>BitbucketApi});var i=r(1398),s=r(6096),o=r(2097),a=r(8412),n=r(8439),u=r(6402),l=r(6434),c=r(3481),d=r(9135),h=r(3582),p=r(5291);let g=e=>({name:e.displayName,email:e.emailAddress,avatarUrl:e.avatarUrl??null,id:e.id.toString(),username:e.name,url:e.links.self[0].href}),m={[p.GitPullRequestReviewState.Approved]:0,[p.GitPullRequestReviewState.Commented]:1,[p.GitPullRequestReviewState.ReviewRequested]:2,[p.GitPullRequestReviewState.ChangesRequested]:3},f=e=>{let t={OPEN:p.GitPullRequestState.Open,MERGED:p.GitPullRequestState.Merged,DECLINED:p.GitPullRequestState.Closed},r={UNAPPROVED:p.GitPullRequestReviewState.ReviewRequested,NEEDS_WORK:p.GitPullRequestReviewState.ChangesRequested,APPROVED:p.GitPullRequestReviewState.Approved},i=e.reviewers.map(e=>({reviewer:g(e.user),state:r[e.status]})),s=e.toRef.repository.links.clone.find(e=>"ssh"===e.name)?.href??null,o=e.toRef.repository.links.clone.find(e=>"https"===e.name)?.href??null;o||(o=e.toRef.repository.links.clone.find(e=>"http"===e.name)?.href??null);let a=e.fromRef.repository.links.clone.find(e=>"ssh"===e.name)?.href??null,n=e.fromRef.repository.links.clone.find(e=>"https"===e.name)?.href??null;return n||(n=e.fromRef.repository.links.clone.find(e=>"http"===e.name)?.href??null),{id:e.id.toString(),number:e.id,title:e.title,url:e.links.self[0].href,state:t[e.state],isDraft:!1,createdDate:new Date(e.createdDate),updatedDate:new Date(e.updatedDate),closedDate:e.closedDate?new Date(e.closedDate):null,mergedDate:"MERGED"===e.state&&e.closedDate?new Date(e.closedDate):null,baseRef:{name:e.toRef.displayId,oid:e.toRef.latestCommit},headRef:{name:e.fromRef.displayId,oid:e.fromRef.latestCommit},commentCount:e.properties?.commentCount,upvoteCount:null,commitCount:null,fileCount:null,additions:null,deletions:null,author:g(e.author.user),assignees:null,reviews:i,reviewDecision:i&&0!==i.length?i.reduce((e,t)=>m[t.state]>m[e]?t.state:e,p.GitPullRequestReviewState.Approved):null,repository:{id:e.toRef.repository.id.toString(),name:e.toRef.repository.name,owner:{login:e.toRef.repository.project.key},remoteInfo:o&&s?{cloneUrlHTTPS:o,cloneUrlSSH:s}:null},headRepository:{id:e.fromRef.repository.id.toString(),name:e.fromRef.repository.name,owner:{login:e.fromRef.repository.project.key},remoteInfo:n&&a?{cloneUrlHTTPS:n,cloneUrlSSH:a}:null},headCommit:null,mergeableState:p.GitPullRequestMergeableState.Unknown,permissions:null,version:e.version}};var v=r(3761),y=r(3980),w=r(99);let b=/^(.*) <(.*)>$/;function R(e){switch(e){case"resolved":case"invalid":case"duplicate":case"wontfix":case"closed":return"closed";default:return"opened"}}function P(e){return{avatarUrl:e.links.avatar.href,name:e.display_name,url:e.links.html.href,id:e.uuid}}function $(e,t,r){return{reviewer:P(e.user),state:e.approved?w.c7.Approved:"changes_requested"===e.state?w.c7.ChangesRequested:null!=e.participated_on?w.c7.Commented:e.user.uuid===t?.uuid&&"DECLINED"===r?w.c7.Dismissed:w.c7.ReviewRequested}}function C(e){return{owner:e.full_name.split("/")[0],repo:e.name,id:e.uuid,accessLevel:y.LI.Write}}function A(e,t){return new y.m2(t,e.id.toString(),e.id.toString(),e.title,e.links.html.href,new Date(e.created_on),new Date(e.updated_on),"opened"!==R(e.state),R(e.state),P(e.reporter),e.assignee?[P(e.assignee)]:[],C(e.repository),void 0,void 0,void 0,e.votes,e.content.html,!e.repository?.project?void 0:{id:e.repository.project.uuid,name:e.repository.project.name,resourceId:e.repository.project.uuid,resourceName:e.repository.project.name})}function F(e,t){return new w.B9(t,P(e.author),e.id.toString(),e.id.toString(),e.title,e.links.html.href,C(e.destination.repository),function(e){switch(e){case"DECLINED":case"SUPERSEDED":return"closed";case"MERGED":return"merged";default:return"opened"}}(e.state),new Date(e.created_on),new Date(e.updated_on),e.closed_by?new Date(e.updated_on):void 0,"MERGED"===e.state?new Date(e.updated_on):void 0,w.Q6.Mergeable,void 0,{base:{branch:e.destination.branch.name,sha:e.destination.commit.hash,repo:e.destination.repository.name,owner:e.destination.repository.full_name.split("/")[0],exists:!0,url:e.destination.repository.links.html.href},head:{branch:e.source.branch.name,sha:e.source.commit.hash,repo:e.source.repository.name,owner:e.source.repository.full_name.split("/")[0],exists:!0,url:e.source.repository.links.html.href},isCrossRepository:e.source.repository.uuid!==e.destination.repository.uuid},void 0,void 0,void 0,void 0,void 0,function(e){if(!e.participants?.length&&e.reviewers?.length)return w.dq.ReviewRequired;if(!e.participants)return;let t=!1,r=!1,i=!1;for(let s of e.participants)null!=s.participated_on&&(t=!0),s.approved&&(i=!0),"changes_requested"===s.state&&(r=!0);return r?w.dq.ChangesRequested:i?w.dq.Approved:t?void 0:w.dq.ReviewRequired}(e),e.participants?.filter(e=>"REVIEWER"===e.role).map(t=>$(t,e.closed_by,e.state)).filter(e=>e.state===w.c7.ReviewRequested),e.participants?.filter(e=>null!=e.participated_on).map(t=>$(t,e.closed_by,e.state)),void 0,void 0,void 0)}var q=Object.defineProperty,S=Object.getOwnPropertyDescriptor,U=(e,t,r,i)=>{for(var s,o=i>1?void 0:i?S(t,r):t,a=e.length-1;a>=0;a--)(s=e[a])&&(o=(i?s(t,r,o):s(o))||o);return i&&o&&q(t,r,o),o};let BitbucketApi=class BitbucketApi{_disposable;constructor(e){this._disposable=u.H.onDidChangeAny(e=>{(u.H.changedCore(e,["http.proxy","http.proxyStrictSSL"])||u.H.changed(e,["outputLevel","proxy"]))&&this.resetCaches()})}dispose(){this._disposable.dispose()}_proxyAgent=null;get proxyAgent(){if(!o.HZ)return null===this._proxyAgent&&(this._proxyAgent=(0,s.cQ)()),this._proxyAgent}resetCaches(){this._proxyAgent=null}async getPullRequestForBranch(e,t,r,i,s,o){let a=(0,d.dQ)(),n=await this.request(e,t,o,`repositories/${r}/${i}/pullrequests?q=source.branch.name="${s}"&fields=%2Bvalues.reviewers,%2Bvalues.participants`,{method:"GET"},a);if(n?.values?.length)return F(n.values[0],e)}async getServerPullRequestForBranch(e,t,r,i,s,o){let a=(0,d.dQ)(),n=await this.request(e,t,o,`projects/${r}/repos/${i}/pull-requests?at=refs/heads/${s}&direction=OUTGOING&state=ALL`,{method:"GET"},a);if(!n?.values?.length)return;let u=f(n.values[0]);return(0,v.QF)(u,e)}async getUsersIssuesForRepo(e,t,r,i,s,o){let a=(0,d.dQ)(),n=encodeURIComponent(`assignee.uuid="${r}" OR reporter.uuid="${r}"`),u=await this.request(e,t,o,`repositories/${i}/${s}/issues?q=${n}`,{method:"GET"},a);if(u?.values?.length)return u.values.map(t=>A(t,e))}async getIssue(e,t,r,i,s,o){let a=(0,d.dQ)();try{let n=await this.request(e,t,o,`repositories/${r}/${i}/issues/${s}`,{method:"GET"},a);if(n)return A(n,e);return}catch(e){c.Vy.error(e,a);return}}async getIssueOrPullRequest(e,t,r,i,s,o,a){let n=(0,d.dQ)();if(a?.type===void 0||a?.type==="pullrequest")try{let a=await this.request(e,t,o,`repositories/${r}/${i}/pullrequests/${s}?fields=%2Bvalues.reviewers,%2Bvalues.participants`,{method:"GET"},n);if(a)return F(a,e)}catch(e){if(e.original?.status!==404)return void c.Vy.error(e,n)}if(a?.type===void 0||a?.type==="issue")try{let a=await this.request(e,t,o,`repositories/${r}/${i}/issues/${s}`,{method:"GET"},n);if(a)return{id:a.id.toString(),type:"issue",nodeId:a.id.toString(),provider:e,createdDate:new Date(a.created_on),updatedDate:new Date(a.updated_on),state:R(a.state),closed:"closed"===a.state,title:a.title,url:a.links.html.href}}catch(e){c.Vy.error(e,n)}}async getServerPullRequestById(e,t,r,i,s,o){let a=(0,d.dQ)();try{let n=await this.request(e,t,o,`projects/${r}/repos/${i}/pull-requests/${s}`,{method:"GET"},a);if(n){let t=f(n);return(0,v.QF)(t,e)}}catch(e){if(e.original?.status!==404)return void c.Vy.error(e,a)}}async getRepositoriesForWorkspace(e,t,r,i){let s=(0,d.dQ)();try{let o=await this.request(e,t,i.baseUrl,`repositories/${r}?role=contributor&fields=%2Bvalues.parent.workspace`,{method:"GET"},s);if(o)return o.values.map(t=>({provider:e,owner:t.workspace.slug,name:t.slug,isFork:!!t.parent,parent:t.parent?{owner:t.parent.workspace.slug,name:t.parent.slug}:void 0}));return}catch(e){c.Vy.error(e,s);return}}async getServerPullRequestForCommit(e,t,r,i,s,o,a,n){let u=(0,d.dQ)();try{let a=await this.request(e,t,o,`projects/${r}/repos/${i}/commits/${s}/pull-requests`,{method:"GET"},u,n),l=a?.values?.reduce((e,t)=>!e||t.updatedDate>e.updatedDate?t:e,void 0);if(!l)return;let c=f(l);return(0,v.QF)(c,e)}catch(e){c.Vy.error(e,u);return}}async getPullRequestForCommit(e,t,r,i,s,o,u,l){let h=(0,d.dQ)();try{let a=encodeURIComponent("+values.*,+values.destination.repository,+values.destination.branch.*,+values.destination.commit.*,+values.source.repository.*,+values.source.branch.*,+values.source.commit.*"),n=await this.request(e,t,o,`repositories/${r}/${i}/commit/${s}/pullrequests?fields=${a}`,{method:"GET"},h,l),u=n?.values?.reduce((e,t)=>!e||t.updated_on>e.updated_on?t:e,void 0);if(!u)return;return F(u,e)}catch(e){if(e.original instanceof a.QI){let t=await e.original.response.json();if(t?.error==="Invalid or unknown installation"){let e=`https://bitbucket.org/${r}/${i}/commits/${s}`;(0,n.YT)(e);return}}c.Vy.error(e,h);return}}async getAccountForCommit(e,t,r,i,s,o,a,n){let u=(0,d.dQ)();try{var l;let a,c=await this.request(e,t,o,`repositories/${r}/${i}/commit/${s}`,{method:"GET"},u,n);if(!c)return;let{name:d,email:h}=(a=(l=c.author.raw).match(b))?{name:a[1],email:a[2]}:{name:l,email:""},p={provider:e,id:c.author.user?.account_id,username:c.author.user?.nickname,name:c.author.user?.display_name||d,email:h,avatarUrl:c.author.user?.links?.avatar?.href};if(null!=p.id&&null!=p.username)return{...p,id:p.id};return{...p,id:void 0,username:void 0}}catch(e){c.Vy.error(e,u);return}}async getServerAccountForCommit(e,t,r,i,s,o,a,n){let u=(0,d.dQ)();try{let a=await this.request(e,t,o,`projects/${r}/repos/${i}/commits/${s}`,{method:"GET"},u,n);if(!a?.author)return;if(null!=a.author.id)return{provider:e,id:a.author.id.toString(),username:a.author.name,name:a.author.name,email:a.author.emailAddress,avatarUrl:a.author?.avatarUrl};return{provider:e,id:void 0,username:void 0,name:a.author.name,email:a.author.emailAddress,avatarUrl:void 0}}catch(e){c.Vy.error(e,u);return}}async request(e,t,r,o,n,u,l){let d,p=`${r}/${o}`;try{let r=(0,h.u)(`[BITBUCKET] ${n?.method??"GET"} ${p}`,{log:!1}),i=this.proxyAgent;try{let r;if(null!=l){if(l.isCancellationRequested)throw new a.AL;r=new AbortController,l.onCancellationRequested(()=>r.abort())}if((d=await (0,s.Ff)(e.getIgnoreSSLErrors(),()=>(0,s.hd)(p,{headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},agent:i,signal:r?.signal,...n}))).ok)return await d.json();throw new a.QI("Bitbucket",d)}finally{r?.stop()}}catch(r){throw r instanceof a.QI||"AbortError"===r.name?this.handleRequestError(e,t,r,u):c.Vy.isDebugging&&i.window.showErrorMessage(`Bitbucket request failed: ${r.message}`),r}}handleRequestError(e,t,r,s){if("AbortError"===r.name||!(r instanceof a.QI))throw new a.AL(r);switch(r.status){case 404:case 410:case 422:throw new a.LN(r);case 401:throw new a.v3("bitbucket",a.R.Unauthorized,r);case 403:throw new a.v3("bitbucket",a.R.Forbidden,r);case 500:c.Vy.error(r,s),null!=r.response&&(e?.trackRequestException(),(0,n.wW)(`${e?.name??"Bitbucket"} failed to respond and might be experiencing issues.${null==e||"bitbucket"===e.id?" Please visit the [Bitbucket status page](https://bitbucket.status.atlassian.com/) for more information.":""}`));return;case 502:c.Vy.error(r,s);break;default:if(r.status>=400&&r.status<500)throw new a.tk(r)}c.Vy.error(r,s),c.Vy.isDebugging&&i.window.showErrorMessage(`Bitbucket request failed: ${r.response?.errors?.[0]?.message??r.message}`)}};U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getPullRequestForBranch",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getServerPullRequestForBranch",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getUsersIssuesForRepo",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getIssue",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getIssueOrPullRequest",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getServerPullRequestById",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getRepositoriesForWorkspace",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getServerPullRequestForCommit",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getPullRequestForCommit",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getAccountForCommit",1),U([(0,l.Yz)({args:{0:e=>e.name,1:"<token>"}})],BitbucketApi.prototype,"getServerAccountForCommit",1)}};