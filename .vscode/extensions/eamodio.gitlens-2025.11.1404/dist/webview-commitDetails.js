exports.id=0,exports.ids=[0],exports.modules={2827:(e,t,i)=>{i.d(t,{CommitDetailsWebviewProvider:()=>CommitDetailsWebviewProvider});var s=i(8039),o=i(1398),n=i(546),a=i(2625),r=i(4109),l=i(5859),h=i(7551),c=i(6234),p=i(819),u=i(1522),m=i(689),d=i(6695),g=i(3182),f=i(9395),v=i(7186),w=i(3177),y=i(1576),C=i(3790);function b(e,t,i){return e===t||null!=e&&null!=t&&e.query===t.query&&(!i||e.queryFilters.files===t.queryFilters.files&&e.queryFilters.refs===t.queryFilters.refs&&e.queryFilters.type===t.queryFilters.type&&e.matchedFiles.length===t.matchedFiles.length&&e.matchedFiles.every((e,i)=>e.path===t.matchedFiles[i].path))}var R=i(5730),x=i(7483),S=i(9003),k=i(3761),F=i(4122),P=i(4641),_=i(6402),D=i(9827),T=i(5001),W=i(7606),q=i(6434),O=i(1335),I=i(3991),A=i(3481),H=i(9135);let MRU=class MRU{constructor(e=10,t){this.maxSize=e,this.comparator=t}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let t=null!=this.comparator?this.stack.findIndex(t=>this.comparator(e,t)):this.stack.indexOf(e);-1!==t?this.stack.splice(t,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(e),this._position=0}get(e){if(null!=e){if(e<0||e>=this.stack.length)return;return this.stack[e]}return this.stack.length>0?this.stack[0]:void 0}insert(e){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(e),this._position++}navigate(e){if(!(this.stack.length<=1)){if("back"===e){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}};var E=i(7820),U=i(9061),M=i(5754);function L(e){return null!=e&&(0,M.sc)(e)&&("gitlens.views.commitDetails"===e.webview||"gitlens.views.graphDetails"===e.webview)}function V(e){return null!=e&&null!=e&&L(e)&&"object"==typeof e.webviewItemValue&&"file"===e.webviewItemValue.type}function z(e,t){let{path:i,repoPath:s,sha:o}=t,n=e.git.getRepositoryService(s);return null==o||(0,C._k)(o)?n.getAbsoluteUri(i,s):n.getRevisionUri(o,i)}async function B(e,t){let{path:i,repoPath:s,sha:o,staged:n,stashNumber:a}=t,r=e.git.getRepositoryService(s);if(null!=a){let e=await r.stash?.getStash(),t=e?.stashes.get(o);if(null==t)return[];let s=await t.findFile(i);return null!=t&&null!=s?[t,s]:[]}if((0,C._k)(o)){let e=await r.commits.getCommit(g.SU);return e=await e?.getCommitForFile(i,n),e?.file!=null?[e,e.file]:[]}let l=z(e,t);if(null==l)return[];let h=await r.commits.getCommitForFile(l,o);return h?.file!=null?[h,h.file]:[]}var $=i(6952),N=Object.defineProperty,G=Object.getOwnPropertyDescriptor,Y=(e,t,i,s)=>{for(var o,n=s>1?void 0:s?G(t,i):t,a=e.length-1;a>=0;a--)(o=e[a])&&(n=(s?o(t,i,n):o(n))||n);return s&&n&&N(t,i,n),n};let{command:j,getCommands:K}=(0,W.VL)();let CommitDetailsWebviewProvider=class CommitDetailsWebviewProvider{constructor(e,t,i){this.container=e,this.host=t,this.options=i,this._context={mode:"commit",inReview:!1,navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commitState:{commit:void 0,searchContext:void 0},autolinksEnabled:_.H.get("views.commitDetails.autolinks.enabled"),experimentalComposerEnabled:_.H.get("ai.experimental.composer.enabled",void 0,!1),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0,orgSettings:this.getOrgSettings(),hasAccount:void 0,hasIntegrationsConnected:void 0},this._disposable=o.Disposable.from(_.H.onDidChangeAny(this.onAnyConfigurationChanged,this),(0,D.wt)(this.onContextChanged,this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),e.integrations.onDidChange(this.onIntegrationsChanged,this))}_context;_disposable;_pinned=!1;_focused=!1;_commitStack=new MRU(10,(e,t)=>e.ref===t.ref);get commit(){return this._context.commitState.commit}get searchContext(){return this._context.commitState.searchContext}dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}getTelemetryContext(){let e;if("wip"===this.mode){let t=this._context.wip?.repo;e={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":+(this._context.wip?.pullRequest!=null),"context.inReview":this._context.inReview,"context.codeSuggestions":this._context.wip?.codeSuggestions?.length??0,"context.repository.id":t?.idHash,"context.repository.scheme":t?.uri.scheme,"context.repository.closed":t?.closed,"context.repository.folder.scheme":t?.folder?.uri.scheme,"context.repository.provider.id":t?.provider.id}}else e={...this.host.getTelemetryContext(),"context.attachedTo":this.options.attachedTo,"context.mode":this.mode,"context.autolinks":+(null!=this._context.pullRequest)+(this._context.autolinkedIssues?.length??0),"context.pinned":this._context.pinned,"context.type":null==this.commit?void 0:(0,u.kk)(this.commit)?"stash":"commit","context.uncommitted":this.commit?.isUncommitted??!1};return e}_skipNextRefreshOnVisibilityChange=!1;_shouldRefreshPullRequestDetails=!1;async onShowing(e,t,...i){let[s]=i;return s?.type==="wip"?[await this.onShowingWip(s),this.getTelemetryContext()]:[await this.onShowingCommit(s,t),this.getTelemetryContext()]}get inReview(){return this._context.inReview}async onShowingWip(e,t){this._context.source=e.source;let i=null!=e.inReview&&this.inReview!==e.inReview;return"wip"!==this.mode||null!=e.repository&&this._context.wip?.repo!==e.repository?(i&&null!=e.inReview&&(this._context.inReview=e.inReview),await this.setMode("wip",e.repository),i&&!0===e.inReview&&this.trackOpenReviewMode(e.source)):i&&await this.setInReview(e.inReview,e.source),(!t?.preserveVisibility||!!this.host.visible)&&("launchpad"===e.source&&this.host.visible&&(this._shouldRefreshPullRequestDetails=!0,this.onRefresh()),!0)}async onShowingCommit(e,t){let i,s;if((0,U.c)(e)){let{commit:t}=e.state;t?.repoPath!=null&&t?.sha!=null&&(i=null!=t.stashNumber?{commit:(0,y.kA)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,y.kA)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else i=null!=e&&"object"==typeof e?e:void 0;if(null!=i&&(i.preserveFocus&&(null==t?t={preserveFocus:!0}:t.preserveFocus=!0),{commit:s,...i}=i),null!=s&&"wip"===this.mode&&i?.interaction!=="passive"&&await this.setMode("commit"),null==s&&!this._pinned){let e=this.getBestCommitOrStash();s=e.commit,null==i?i={searchContext:e.searchContext}:null==i.searchContext&&(i={...i,searchContext:e.searchContext})}return null==s||this.commit?.ref.startsWith(s.ref)&&b(i?.searchContext,this.searchContext,!1)||await this.updateCommitState(s,i?.searchContext,{pinned:!1}),(!i?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}async trackOpenReviewMode(e){if(this._context.wip?.pullRequest==null)return;let t=this._context.wip.pullRequest.provider.id,i=await this.container.git.visibility(this._context.wip.repo.path),s=this._context.wip.changes?.files.length??0;this.container.telemetry.sendEvent("openReviewMode",{provider:t,"repository.visibility":i,repoPrivacy:i,source:e??"inspect",filesChanged:s})}includeBootstrap(e){return e?Promise.resolve({webviewId:this.host.id,webviewInstanceId:this.host.instanceId,timestamp:Date.now()}):this.getState(this._context)}registerCommands(){let e=[(0,P.Ip)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))];for(let{command:t,handler:i}of K())e.push((0,P.Ip)((0,W.Wu)(t,this.host.type),i,this));return e}onFocusChanged(e){this._focused!==e&&(this._focused=e,e&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(e){switch(!0){case $.Lb.is(e):this.openFileOnRemote(e.params);break;case $.Yt.is(e):this.openFile(e.params);break;case $.Sh.is(e):this.openFileChangesWithWorking(e.params);break;case $.UB.is(e):this.openChanges(e.params);break;case $.xy.is(e):this.showFileActions(e.params);break;case $.k$.is(e):switch(e.params.action){case"graph":{let e;if(null==(e="wip"===this._context.mode?this._context.wip?.changes!=null?(0,y.kA)(g.SU,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this.commit?(0,f.rd)(this.commit):void 0))return;(0,P.RS)("graph"===this.options.attachedTo?"gitlens.showInCommitGraphView":"gitlens.showInCommitGraph",{ref:e});break}case"more":this.showCommitActions();break;case"scm":(0,P.S4)("workbench.view.scm");break;case"sha":null!=this.commit&&(e.params.alt?(0,P.RS)("gitlens.copyMessageToClipboard",{message:this.commit.message}):(0,u.kk)(this.commit)?o.env.clipboard.writeText(this.commit.stashName):(0,P.RS)("gitlens.copyShaToClipboard",{sha:this.commit.sha}))}break;case $.QY.is(e):this.showCommitPicker();break;case $.tu.is(e):this.showCommitSearch();break;case $.b6.is(e):this.switchMode(e.params);break;case $.T$.is(e):this.updatePinned(e.params.pin??!1,!0);break;case $.TC.is(e):this.navigateStack(e.params.direction);break;case $.Tu.is(e):this.updatePreferences(e.params);break;case $.fF.is(e):this.explainRequest($.fF,e);break;case $.Nb.is(e):this.generateRequest($.Nb,e);break;case $.L2.is(e):this.reachabilityRequest($.L2,e);break;case $.eg.is(e):this.stageFile(e.params);break;case $.Zr.is(e):this.unstageFile(e.params);break;case $.GC.is(e):this.createPatchFromWip(e.params);break;case $.qy.is(e):this.fetch();break;case $.D5.is(e):this.publish();break;case $.qf.is(e):this.push();break;case $.z_.is(e):this.pull();break;case $.Cv.is(e):this.switch();break;case $.zK.is(e):this.suggestChanges(e.params);break;case $.Iq.is(e):this.showCodeSuggestion(e.params.id);break;case $.jY.is(e):this.setInReview(e.params.inReview,"inspect-overview");break;case $.PR.is(e):this.openPullRequestChanges();break;case $.N9.is(e):this.openPullRequestComparison();break;case $.vL.is(e):this.openPullRequestOnRemote();break;case $.mK.is(e):this.showPullRequestDetails()}}getEncodedEntityid(e=this._context.wip?.pullRequest){if(null==e)return;let t=(0,F.Dz)(e);if(null!=t)return s.EntityIdentifierUtils.encode(t)}async trackCreateCodeSuggestion(e,t){if(this._context.wip?.pullRequest==null)return;let i=this._context.wip.pullRequest.provider.id,s=await this.container.git.visibility(this._context.wip.repo.path);this.container.telemetry.sendEvent("codeSuggestionCreated",{provider:i,"repository.visibility":s,repoPrivacy:s,draftId:e.id,draftPrivacy:e.visibility,filesChanged:t,source:"reviewMode"},{source:"inspect-overview",detail:{reviewMode:!0}})}async suggestChanges(e){if(!await (0,S.G5)(this.container,"Code Suggestions are a Preview feature and require an account.",{source:"code-suggest",detail:"create"})||!await (0,x.l)(this.container))return;let t=[],i=Object.entries(e.changesets),n=1===i.length,a=0;for(let[e,s]of i){if(!n&&!1===s.checked)continue;let e=this._context.wip.repo.id===s.repository.path?this._context.wip.repo:void 0;if(null==e)continue;let{checked:i}=s,o={to:g.SU,from:"HEAD"};"staged"===i&&(o={...o,to:g.id});let r=this.getEncodedEntityid();null!=r&&(s.files&&s.files.length>0&&("staged"===i?a+=s.files.filter(e=>!0===e.staged).length:a+=s.files.length),t.push({repository:e,revision:o,prEntityId:r}))}if(0!==t.length)try{let i=(0,F.Dz)(this._context.wip.pullRequest),n=s.EntityIdentifierUtils.encode(i),r={description:e.description,visibility:"provider_access",prEntityId:n},l=await this.container.drafts.createDraft("suggested_pr_change",e.title,t,r);(async function(){let e={title:"View Code Suggestions"},t={title:"Copy Link"},i=!1;for(;;){let s=await o.window.showInformationMessage(`Code Suggestion successfully created${i?"â€” link copied to the clipboard":""}`,e,t);if(s===t){o.env.clipboard.writeText(l.deepLinkUrl),i=!0;continue}s===e&&(0,R.X)({mode:"view",draft:l,source:"notification"});break}})(),this.setInReview(!1),this.trackCreateCodeSuggestion(l,a)}catch(e){o.window.showErrorMessage(`Unable to create draft: ${e.message}`)}}getRepoActionPath(){return"wip"===this._context.mode?this._context.wip?.repo.path:this.commit?.repoPath}fetch(){let e=this.getRepoActionPath();null!=e&&c.hd(e)}publish(){let e=this.getRepoActionPath();null!=e&&(0,P.wS)("git.publish",o.Uri.file(e))}push(){let e=this.getRepoActionPath();null!=e&&c.VC(e)}pull(){let e=this.getRepoActionPath();null!=e&&c.a$(e)}switch(){let e=this.getRepoActionPath();null!=e&&c.S_(e)}get pullRequestContext(){if("wip"===this.mode){if(this._context.wip?.pullRequest==null)return;return{repoPath:this._context.wip.repo.path,branch:this._context.wip.branch,pr:this._context.wip.pullRequest}}if(null!=this._context.pullRequest)return{repoPath:this.commit.repoPath,commit:this.commit,pr:this._context.pullRequest}}openPullRequestChanges(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,w.tI)(e,t.refs);return(0,h.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}openPullRequestComparison(){if(null==this.pullRequestContext)return;let{repoPath:e,pr:t}=this.pullRequestContext;if(null==t.refs)return;let i=(0,w.tI)(e,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async openPullRequestOnRemote(e){if(null==this.pullRequestContext)return;let{pr:{url:t}}=this.pullRequestContext;return(0,P.RS)("gitlens.openPullRequestOnRemote",{pr:{url:t},clipboard:e})}async showPullRequestDetails(){if(null==this.pullRequestContext)return;let{pr:e,repoPath:t,branch:i,commit:s}=this.pullRequestContext;if(null!=e)return this.container.views.pullRequest.showPullRequest(e,s??i??t)}onRefresh(e){if(!this._pinned)if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=e?o.Uri.parse(e):void 0))}else{let{commit:e,searchContext:t}=this.getBestCommitOrStash();this.updateCommitState(e,t,{immediate:!1})}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(e){if(this.ensureTrackers(),!e)return;let t=this._skipNextRefreshOnVisibilityChange;t&&(this._skipNextRefreshOnVisibilityChange=!1),t||this.onRefresh(),this.notifyDidChangeState(!0)}onAnyConfigurationChanged(e){(_.H.changed(e,["defaultDateFormat","defaultDateStyle","views.commitDetails.files","views.commitDetails.avatars","ai.enabled"])||_.H.changedCore(e,"workbench.tree.renderIndentGuides")||_.H.changedCore(e,"workbench.tree.indent"))&&(this._context.preferences=this.getPreferences(),this.notifyDidChangeState()),null!=this.commit&&_.H.changed(e,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&this.updateCommitState(this.commit,this.searchContext,{force:!0})}onSubscriptionChanged(e){this.updateCodeSuggestions(),this.updateHasAccount(e.current)}updateHasAccount(e){let t=null!=e.account;this._context.hasAccount!==t&&this.notifyDidChangeHasAccount(t)}async getHasAccount(e=!1){return(null==this._context.hasAccount||e)&&(this._context.hasAccount=(await this.container.subscription.getSubscription())?.account!=null),this._context.hasAccount}async onIntegrationsChanged(e){let t=this._context.hasIntegrationsConnected,i=await this.getHasIntegrationsConnected(!0);t!==i&&this.notifyDidChangeIntegrations(i)}async getHasIntegrationsConnected(e=!1){if(e||null==this._context.hasIntegrationsConnected){let e=await this.container.integrations.getConfigured();e.length?this._context.hasIntegrationsConnected=e.some(e=>(0,r.LT)(e.integrationId)):this._context.hasIntegrationsConnected=!1}return this._context.hasIntegrationsConnected}getPreferences(){return{pullRequestExpanded:this.container.storage.getWorkspace("views:commitDetails:pullRequestExpanded")??!0,avatars:_.H.get("views.commitDetails.avatars"),dateFormat:_.H.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",dateStyle:_.H.get("defaultDateStyle")??"relative",files:_.H.get("views.commitDetails.files"),indentGuides:_.H.getCore("workbench.tree.renderIndentGuides")??"onHover",indent:_.H.getCore("workbench.tree.indent"),aiEnabled:_.H.get("ai.enabled")}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&this.notifyDidChangeOrgSettings()}getOrgSettings(){return{ai:(0,D.SD)("gitlens:gk:organization:ai:enabled",!1),drafts:(0,D.SD)("gitlens:gk:organization:drafts:enabled",!1)}}onCommitSelected(e){if(null!=e.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===e.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==e.source)){if("graph"===this.options.attachedTo)return void(e.data.commit.ref===g.SU?"wip"!==this.mode?this.setMode("wip",this.container.git.getRepository(e.data.commit.repoPath)):e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath)):(this._pinned&&"passive"===e.data.interaction&&(this._commitStack.insert((0,f.rd)(e.data.commit)),this.updateNavigation()),"commit"!==this.mode&&this.setMode("commit",this.container.git.getRepository(e.data.commit.repoPath)),this._pinned&&"passive"===e.data.interaction||this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data)));if("wip"===this.mode){e.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(e.data.commit.repoPath));return}this._pinned&&"passive"===e.data.interaction?(this._commitStack.insert((0,f.rd)(e.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:e.data.preserveFocus},e.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if((this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible)&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:e}=this.container;this._lineTrackerDisposable=e.subscribe(this,e.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}createPatchFromWip(e){if(null==e.changes)return;let t={type:"wip",repository:{name:e.changes.repository.name,path:e.changes.repository.path,uri:e.changes.repository.uri},files:e.changes.files,revision:{to:g.SU,from:"HEAD"},checked:e.checked};(0,R.X)({mode:"create",create:{changes:[t]}})}showCodeSuggestion(e){let t=this._context.wip?.codeSuggestions?.find(t=>t.id===e);null!=t&&(0,R.X)({mode:"view",draft:t,source:"inspect"})}onActiveEditorLinesChanged(e){if(e.pending||null==e.editor||e.suspended)return;if("wip"===this.mode){let t=this.container.git.getBestRepositoryOrFirst(e.editor);this.updateWipState(t,!0);return}let t=e.selections?.[0]?.active,i=null!=t?this.container.lineTracker.getState(t)?.commit:void 0;this.updateCommitState(i,void 0)}_wipSubscription;get mode(){return this._context.mode}async setMode(e,t){this._context.mode=e,this.notifyDidChangeState(!0),"wip"===e&&await this.updateWipState(t??this.container.git.getBestRepositoryOrFirst()),this.updateTitle()}updateTitle(){if("commit"===this.mode)if(null==this.commit)this.host.title=this.host.originalTitle;else{let e="Commit Details";"stash"===this.commit.refType?e="Stash Details":this.commit.isUncommitted&&(e="Uncommitted Changes"),this.host.title=`${this.host.originalTitle}: ${e}`}else this.host.title=`${this.host.originalTitle}: Overview`}async explainRequest(e,t){let i;try{if(null!=this.commit&&(this.commit.isUncommitted||this.commit.isUncommittedStaged))await (0,P.RS)("gitlens.ai.explainWip",{repoPath:this.commit.repoPath,source:{source:"inspect",context:{type:"wip"}}});else{let e=(0,u.kk)(this.commit);await (0,P.RS)(e?"gitlens.ai.explainStash":"gitlens.ai.explainCommit",{repoPath:this.commit.repoPath,rev:this.commit.sha,source:{source:"inspect",context:{type:e?"stash":"commit"}}})}i={result:{summary:"",body:""}}}catch(e){i={error:{message:e.message}}}this.host.respond(e,t,i)}async generateRequest(e,t){let i,s=this._context.wip?.repo;if(!s)return void this.host.respond(e,t,{error:{message:"Unable to find changes"}});try{let e=await this.container.ai.generateCreateDraft(s,{source:"inspect",context:{type:"suggested_pr_change"}},{progress:{location:{viewId:this.host.id}}});if("cancelled"===e)throw Error("Operation was canceled");if(null==e)throw Error("Error retrieving content");i={title:e.parsed.summary,description:e.parsed.body}}catch(e){i={error:{message:e.message}}}this.host.respond(e,t,i)}async reachabilityRequest(e,t){let i=Date.now();try{let s=this.commit;if(null==s)return void this.host.respond(e,t,{error:{message:"Unable to find commit"},duration:Date.now()-i});let o=await this.container.git.getRepositoryService(s.repoPath).commits.getCommitReachability?.(s.sha,this._cancellationTokenSource?.token),n=Date.now()-i;this.container.telemetry.sendEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/reachability/loaded`,{"refs.count":o?.refs.length??0,duration:n}),this.host.respond(e,t,{refs:o?.refs??[],duration:n})}catch(n){let s=Date.now()-i,o=n instanceof Error?n.message:String(n);this.container.telemetry.sendEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/reachability/failed`,{duration:s,"failed.reason":n instanceof Error&&"CancellationError"===n.name?"timeout":"git-error","failed.error":o}),this.host.respond(e,t,{error:{message:"Failed trying to find branches or tags that contain this commit"},duration:s})}}navigateStack(e){let t=this._commitStack.navigate(e);null!=t&&this.updateCommitState(t,void 0,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(e){let t;null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=e.commitState.commit&&(t=await this.getDetailsModel(e.commitState.commit,e.formattedMessage));let i=e.wip;if(null==i&&this._repositorySubscription){null==this._cancellationTokenSource&&(this._cancellationTokenSource=new o.CancellationTokenSource);let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateWipState(this._repositorySubscription?.repo)},100)}return e.hasAccount??=await this.getHasAccount(),e.hasIntegrationsConnected??=await this.getHasIntegrationsConnected(),{...this.host.baseWebviewState,mode:e.mode,commit:t,navigationStack:e.navigationStack,pinned:e.pinned,preferences:e.preferences,autolinksEnabled:e.autolinksEnabled,experimentalComposerEnabled:e.experimentalComposerEnabled,autolinkedIssues:e.autolinkedIssues,pullRequest:e.pullRequest,wip:X(i),orgSettings:e.orgSettings,inReview:e.inReview,hasAccount:e.hasAccount,hasIntegrationsConnected:e.hasIntegrationsConnected,searchContext:e.commitState.searchContext}}async updateWipState(e,t=!1){let i;if(null!=this._wipSubscription){let{repo:i,subscription:s}=this._wipSubscription;if(e?.path!==i.path)s.dispose(),this._wipSubscription=void 0;else if(t)return}let s=this.inReview;if(null!=e){null==this._wipSubscription&&(this._wipSubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)});let t=await this.getWipChange(e);if(i={changes:t,repo:e,repositoryCount:this.container.git.openRepositoryCount},null!=t){let s=await this.getWipBranchDetails(e,t.branchName);null!=s&&(i.branch=s.branch,i.pullRequest=s.pullRequest,i.codeSuggestions=s.codeSuggestions)}if(i.pullRequest?.state!=="opened"&&(s=!1),this._shouldRefreshPullRequestDetails&&null!=i.pullRequest&&"launchpad"===this._context.source&&(this.container.views.pullRequest.showPullRequest(i.pullRequest,i.branch??e.path),this._shouldRefreshPullRequestDetails=!1),await this.host.notify($.u,{wip:X(i),inReview:s})){this._context.wip=i,this._context.inReview=s;return}}this._context.wip=i,this._context.inReview=s,this.notifyDidChangeState(!0)}async getWipBranchDetails(e,t){let i=await e.git.branches.getBranch(t);if(null==i)return;if("commit"===this.mode)return{branch:i,pullRequest:void 0,codeSuggestions:[]};let s=await i.getAssociatedPullRequest({expiryOverride:3e5}),o=[];if(null!=s&&(0,k.Ac)(s.provider)){let t=await this.getCodeSuggestions(s,e);t.length&&(o=t)}return{branch:i,pullRequest:s,codeSuggestions:o}}async canAccessDrafts(){return await this.getHasAccount()!==!1&&(0,D.SD)("gitlens:gk:organization:drafts:enabled",!1)}async getCodeSuggestions(e,t){if(!await this.canAccessDrafts()||!(0,k.Ac)(e.provider))return[];let i=await this.container.drafts.getCodeSuggestions(e,t);for(let e of i){if(null!=e.author.avatarUri||null==e.organizationId)continue;let t=e.author.email;if(null==t){let i=await this.container.organizations.getMemberById(e.author.id,e.organizationId);t=i?.email}null!=t&&(e.author.avatarUri=(0,a.m_)(t))}return i}async updateCodeSuggestions(){if("wip"!==this.mode||this._context.wip?.pullRequest==null)return;let e=this._context.wip,{pullRequest:t,repo:i}=e;if(e.codeSuggestions=(0,k.Ac)(t.provider)?await this.getCodeSuggestions(t,i):[],await this.host.notify($.u,{wip:X(e)})){this._context.wip=e;return}this._context.wip=e,this.notifyDidChangeState(!0)}_repositorySubscription;async updateCommitState(e,t,i){let s;if(!i?.force&&this.commit?.sha===e?.ref&&b(t,this.searchContext,!1))return;if((0,u.WM)(e))s=e;else if(null!=e)if("stash"===e.refType){let t=await this.container.git.getRepositoryService(e.repoPath).stash?.getStash();s=t?.stashes.get(e.ref)}else s=await this.container.git.getRepositoryService(e.repoPath).commits.getCommit(e.ref);let o=this._context.wip;if(null!=this._repositorySubscription){let{repo:e,subscription:t}=this._repositorySubscription;s?.repoPath!==e.path&&(t.dispose(),this._repositorySubscription=void 0,o=void 0)}if(null==this._repositorySubscription&&null!=s){let e=await this.container.git.getOrOpenRepository(s.repoPath);null!=e&&(this._repositorySubscription={repo:e,subscription:this.subscribeToRepositoryWip(e)},"wip"===this.mode?this.updateWipState(e):o=void 0)}this._context.commitState={commit:s,searchContext:t},this._context.autolinksEnabled=_.H.get("views.commitDetails.autolinks.enabled"),this._context.experimentalComposerEnabled=_.H.get("ai.experimental.composer.enabled",void 0,!1),this._context.formattedMessage=void 0,this._context.autolinkedIssues=void 0,this._context.pullRequest=void 0,this._context.wip=o,i?.pinned!=null&&this.updatePinned(i?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=s&&(i?.skipStack||this._commitStack.add((0,f.rd)(s)),this.updateNavigation()),this.notifyDidChangeCommit(i?.immediate??!0),this.updateTitle()}subscribeToRepositoryWip(e){return o.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(()=>this.onWipChanged(e)),e.onDidChange(t=>{t.changed(d.Z_.Index,d.Ti.Any)&&this.onWipChanged(e)}))}onWipChanged(e){this.updateWipState(e)}async getWipChange(e){let t=await this.container.git.getRepositoryService(e.path).status.getStatus();if(null==t)return;let i=[];for(let e of t.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};i.push(t),e.staged&&e.wip&&i.push({...t,staged:!1})}return{repository:{name:e.name,path:e.path,uri:e.uri.toString()},branchName:t.branch,files:i}}updatePinned(e,t){e!==this._context.pinned&&(this._pinned=e,this.ensureTrackers(),this._context.pinned=e,this.notifyDidChangeCommit(t))}updatePreferences(e){if(this._context.preferences?.pullRequestExpanded===e.pullRequestExpanded&&this._context.preferences?.files?.compact===e.files?.compact&&this._context.preferences?.files?.icon===e.files?.icon&&this._context.preferences?.files?.layout===e.files?.layout&&this._context.preferences?.files?.threshold===e.files?.threshold)return;let t={...this._context.preferences};null!=e.pullRequestExpanded&&this._context.preferences?.pullRequestExpanded!==e.pullRequestExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:pullRequestExpanded",e.pullRequestExpanded).catch(),t.pullRequestExpanded=e.pullRequestExpanded),null!=e.files&&(this._context.preferences?.files?.compact!==e.files?.compact&&_.H.updateEffective("views.commitDetails.files.compact",e.files?.compact),this._context.preferences?.files?.icon!==e.files?.icon&&_.H.updateEffective("views.commitDetails.files.icon",e.files?.icon),this._context.preferences?.files?.layout!==e.files?.layout&&_.H.updateEffective("views.commitDetails.files.layout",e.files?.layout),this._context.preferences?.files?.threshold!==e.files?.threshold&&_.H.updateEffective("views.commitDetails.files.threshold",e.files?.threshold),t.files=e.files),this._context.preferences=t,this.notifyDidChangeCommit()}_notifyDidChangeCommitDebounced=void 0;notifyDidChangeCommit(e=!1){e?this.notifyDidChangeState():(this._notifyDidChangeCommitDebounced??=(0,O.s)(this.notifyDidChangeState.bind(this),500),this._notifyDidChangeCommitDebounced())}notifyDidChangeOrgSettings(){this._context.orgSettings=this.getOrgSettings(),this.host.notify($.I0,{orgSettings:this._context.orgSettings})}notifyDidChangeHasAccount(e){this._context.hasAccount=e,this.host.notify($.A4,{hasAccount:e})}notifyDidChangeIntegrations(e){this._context.hasIntegrationsConnected=e,this.host.notify($.IK,{hasIntegrationsConnected:e})}updateNavigation(){let e=this._commitStack.get(this._commitStack.position-1)?.ref;null!=e&&(e=(0,C.pV)(e)),this._context.navigationStack={count:this._commitStack.count,position:this._commitStack.position,hint:e},this.notifyDidChangeCommit()}async setInReview(e,t){if(this.inReview!==e){if(await this.host.notify($.LX,{inReview:e})){this._context.inReview=e,e&&this.trackOpenReviewMode(t);return}this._context.inReview=e,this.notifyDidChangeState(!0),e&&this.trackOpenReviewMode(t)}}async notifyDidChangeState(e){let t=(0,H.dQ)();return this._notifyDidChangeCommitDebounced?.cancel(),o.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify($.tK,{state:await this.getState(this._context)})}catch(e){A.Vy.error(e,t)}})}getBestCommitOrStash(){let e,t;if(this._pinned)return{commit:void 0,searchContext:void 0};if("graph"!==this.options.attachedTo&&null!=o.window.activeTextEditor){let{lineTracker:t}=this.container,i=t.selections?.[0].active;null!=i&&(e=t.getState(i)?.commit)}if(null==e)if("graph"===this.options.attachedTo){let i=this.container.events.getCachedEventArgsBySource("commit:selected","gitlens.views.graph");e=i?.commit,t=i?.searchContext}else{let i=this.container.events.getCachedEventArgs("commit:selected");e=i?.commit,t=i?.searchContext}return{commit:e,searchContext:t}}async getDetailsModel(e,t){let[i,s,o]=await Promise.allSettled([!e.hasFullDetails()?e.ensureFullDetails({include:{uncommittedFiles:!0}}).then(()=>e):e,e.author.getAvatarUri(e,{size:32}),this.container.git.getRepositoryService(e.repoPath).remotes.getBestRemoteWithIntegration({includeDisconnected:!0})]);e=(0,E.Ro)(i,e);let a=(0,E.Ro)(s),r=(0,E.Ro)(o);t??=this.getFormattedMessage(e,r);let l=null!=e.message?await this.container.autolinks.getAutolinks(e.message,r):void 0;return{repoPath:e.repoPath,sha:e.sha,shortSha:e.shortSha,author:{...e.author,avatar:a?.toString(!0)},message:t,parents:e.parents,stashNumber:"stash"===e.refType?e.stashNumber:void 0,files:e.isUncommitted?e.anyFiles:e.fileset?.files,stats:e.stats,autolinks:null!=l?[...(0,I.Tj)(l.values(),n.U8)]:void 0,enriched:this.getEnrichedState(e,r)}}async getEnrichedState(e,t){let[i,s]=t?.provider!=null?await Promise.allSettled([_.H.get("views.commitDetails.autolinks.enabled")&&_.H.get("views.commitDetails.autolinks.enhanced")?(0,E.zu)(e.getEnrichedAutolinks(t)):void 0,_.H.get("views.commitDetails.pullRequests.enabled")?e.getAssociatedPullRequest(t):void 0]):[],o=(0,E.Ro)(i)?.value,n=(0,E.Ro)(s),a=null!=o?[...(0,I.x1)(o.values(),([e])=>{var t;return e?.value!=null?{type:(t=e.value).type,provider:{id:t.provider.id,name:t.provider.name,domain:t.provider.domain,icon:t.provider.icon},id:t.id,nodeId:t.nodeId,title:t.title,url:t.url,createdDate:t.createdDate,updatedDate:t.updatedDate,closedDate:t.closedDate,closed:t.closed,state:t.state}:void 0})]:[];return{formattedMessage:this.getFormattedMessage(e,t,o),associatedPullRequest:null!=n?(0,w.pf)(n):void 0,autolinkedIssues:a}}getFormattedMessage(e,t,i){let s=p.c.fromTemplate("${message}",e),o=s.indexOf(`
`);return(-1!==o&&(s=`${s.substring(0,o)}${$.iA}${s.substring(o+1)}`),_.H.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(s,"html",null!=t?[t]:void 0,i):s}async getFileCommitFromContextOrParams(e){return null==e?[]:L(e)?V(e)?B(this.container,e.webviewItemValue):[]:this.getFileCommitFromParams(e)}async getFileCommitFromParams(e){let t;if("wip"===this.mode){let e=this._context.wip?.changes?.repository.uri;if(null==e)return[];t=await this.container.git.getRepositoryService(o.Uri.parse(e)).commits.getCommit(g.SU)}else t=this.commit;return null!=(t=await t?.getCommitForFile(e.path,e.staged))?[t,t.file]:[]}showCommitPicker(){(0,l.b)({command:"log",state:{reference:"HEAD",repo:this.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,l.b)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this.commit||this.commit.isUncommitted||(0,h.G4)(this.commit)}async showFileActions(e){let[t,i]=await this.getFileCommitFromParams(e);null!=t&&(this.suspendLineTracker(),(0,h.G4)(t,i))}switchMode(e){let t;if(this.mode===e.mode)return;let i=this.mode;if("wip"===e.mode){let{repoPath:i}=e;if(null==i){if(null==(t=this.container.git.getBestRepositoryOrFirst()))return;i=t.path}else t=this.container.git.getRepository(i)}this.setMode(e.mode,t),this.container.telemetry.sendEvent(`${"graph"===this.options.attachedTo?"graphDetails":"commitDetails"}/mode/changed`,{...this.getTelemetryContext(),"mode.old":i,"mode.new":e.mode})}async openChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,h.eX)(i,t,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}),this.container.events.fire("file:selected",{uri:i.uri},{source:this.host.id}))}async openFileChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,h.DD)(i,t,{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}))}async openPreviousFileChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,h.DD)(i,{repoPath:t.repoPath,ref:t.unresolvedPreviousSha},{preserveFocus:!0,preview:!0,...this.getShowOptions(e)}),this.container.events.fire("file:selected",{uri:i.uri},{source:this.host.id}))}async openFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,h.Tq)(i,t,{preserveFocus:!0,preview:!0}))}async openFileOnRemote(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,h.gV)(i,t)}async stageFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&await this.container.git.getRepositoryService(t.repoPath).staging?.stageFile(i.uri)}async unstageFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&await this.container.git.getRepositoryService(t.repoPath).staging?.unstageFile(i.uri)}getShowOptions(e){return L(e)?void 0:e?.showOptions}async copy(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&o.env.clipboard.writeText(i.path)}async copyRelativePath(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let s=this.container.git.getRelativePath(i.uri,t.repoPath);o.env.clipboard.writeText(s)}async copyPatch(e){let t,[i,s]=await this.getFileCommitFromContextOrParams(e);if(null!=i){if(i.isUncommitted){let e=i.isUncommittedStaged?g.id:g.SU;t={repoPath:i.repoPath,to:e,title:e===g.id?"Staged Changes":"Uncommitted Changes",uris:[s.uri]}}else{null==i.message&&await i.ensureFullDetails();let{summary:e,body:o}=(0,v.TH)(i.message);t={repoPath:i.repoPath,to:i.ref,from:`${i.ref}^`,title:e,description:o,uris:[s.uri]}}(0,P.RS)("gitlens.copyPatchToClipboard",t)}}async openFileRevision(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),(0,h.vM)(i,t,{preserveFocus:!0,preview:!1}))}async openFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.openFileHistory",i.uri)}async quickOpenFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.quickOpenFileHistory",i.uri)}async visualizeFileHistory(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.visualizeHistory.file",i.uri)}async openFileHistoryInGraph(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.openFileHistoryInGraph",i.uri)}async restoreFile(e){if(!V(e))return;let{path:t,repoPath:i,sha:s}=e.webviewItemValue;null!=s&&s!==g.SU&&await this.container.git.getRepositoryService(i).ops?.checkout(s,{path:t})}async restorePreviousFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,h.VX)(i,t,!0)}selectFileForCompare(e){if(!V(e))return;let{repoPath:t,sha:i}=e.webviewItemValue,s=z(this.container,e.webviewItemValue);null!=s&&(0,D.o)("gitlens:views:canCompare:file",{ref:i??g.SU,repoPath:t,uri:s})}async compareFileWithSelected(e){let t=(0,D.SD)("gitlens:views:canCompare:file");if(null==t||!V(e))return;(0,D.o)("gitlens:views:canCompare:file",void 0);let{repoPath:i,sha:s}=e.webviewItemValue;if(t.repoPath!==i)return void this.selectFileForCompare(e);let o=z(this.container,e.webviewItemValue);null!=o&&await this.compareFileWith(t.repoPath,t.uri,t.ref,o,s??g.SU)}async compareFileWith(e,t,i,s,o){return s??=await this.container.git.getRepositoryService(e).getWorkingUri(t),(0,P.RS)("gitlens.diffWith",{repoPath:e,lhs:{sha:i,uri:t},rhs:{sha:o,uri:s??t}})}async applyChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,h.YF)(i,t)}async mergeChangesWithWorking(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let s=this.container.git.getRepositoryService(t.repoPath);if(null==s)return;let n=await s.getBestRevisionUri(i.path,t.ref);if(null==n)return;let a={uri:n,title:"Incoming",detail:` ${t.shortSha}`},[r,l]=await Promise.allSettled([s.refs.getMergeBase(t.ref,"HEAD"),s.getWorkingUri(i.uri)]),h=(0,E.Ro)(l);if(null==h)return void o.window.showWarningMessage("Unable to open the merge editor, no working file found");let c={uri:h,title:"Current",detail:" Working Tree"},p=await s.getBestRevisionUri(i.path,"HEAD");if(null!=p){let e=await s.branches.getBranch?.();c.uri=p,c.detail=` ${e?.name||"HEAD"}`}let u=(0,E.Ro)(r),m=null!=u?await s.getBestRevisionUri(i.path,u):void 0;return(0,T.g6)({base:m??n,input1:a,input2:c,output:h})}diffWithRevision(e){if(!V(e))return;let t=z(this.container,e.webviewItemValue);null!=t&&(0,P.RS)("gitlens.diffWithRevision",t)}diffWithRevisionFrom(e){if(!V(e))return;let t=z(this.container,e.webviewItemValue);null!=t&&(0,P.RS)("gitlens.diffWithRevisionFrom",t)}async externalDiff(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;let s=await t.getPreviousSha(),o=(0,C._k)(s)?"":s,n=t.isUncommitted?"":t.sha;(0,P.RS)("gitlens.externalDiff",{files:[{uri:i.uri,staged:t.isUncommittedStaged,ref1:o,ref2:n}]})}async highlightChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),await (0,h.Tq)(i,t,{preserveFocus:!0,preview:!0}),await this.container.fileAnnotations.toggle(o.window.activeTextEditor,"changes",{sha:t.ref},!0))}async highlightRevisionChanges(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(this.suspendLineTracker(),await (0,h.Tq)(i,t,{preserveFocus:!0,preview:!0}),await this.container.fileAnnotations.toggle(o.window.activeTextEditor,"changes",{sha:t.ref,only:!0},!0))}async copyDeepLinkToCommit(e){let[t]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.copyDeepLinkToCommit",{refOrRepoPath:t})}async copyDeepLinkToFile(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.copyDeepLinkToFile",{ref:t,filePath:i.path,repoPath:t.repoPath})}async copyDeepLinkToFileAtRevision(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.copyDeepLinkToFileAtRevision",{ref:t,filePath:i.path,repoPath:t.repoPath,chooseRef:!0})}async copyRemoteCommitUrl(e){let[t]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.openOnRemote",{repoPath:t.repoPath,resource:{type:m.J.Commit,sha:t.ref},clipboard:!0})}async shareAsCloudPatch(e){let[t]=await this.getFileCommitFromContextOrParams(e);if(null==t)return;null==t.message&&await t.ensureFullDetails();let{summary:i,body:s}=(0,v.TH)(t.message);(0,P.RS)("gitlens.createCloudPatch",{to:t.ref,repoPath:t.repoPath,title:i,description:s})}async copyRemoteFileUrlFrom(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.copyRemoteFileUrlFrom",{sha:t.ref,clipboard:!0,pickBranchOrTag:!0,range:!1})}async copyRemoteFileUrlWithoutRange(e){let[t,i]=await this.getFileCommitFromContextOrParams(e);null!=t&&(0,P.RS)("gitlens.copyRemoteFileUrlWithoutRange",{sha:t.ref,clipboard:!0,range:!1})}};function X(e){if(null!=e)return{changes:e.changes,repositoryCount:e.repositoryCount,branch:function(e){if(null!=e)return{name:e.name,repoPath:e.repoPath,upstream:e.upstream,tracking:{ahead:e.upstream?.state.ahead??0,behind:e.upstream?.state.behind??0}}}(e.branch),repo:{uri:e.repo.uri.toString(),name:e.repo.name,path:e.repo.path},pullRequest:null!=e.pullRequest?(0,w.pf)(e.pullRequest):void 0,codeSuggestions:e.codeSuggestions?.map(e=>({...e,changesets:void 0}))}}Y([(0,q.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getState",1),Y([(0,q.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"updateWipState",1),Y([(0,q.Yz)({args:!1})],CommitDetailsWebviewProvider.prototype,"getEnrichedState",1),Y([j("gitlens.views.openChanges:")],CommitDetailsWebviewProvider.prototype,"openChanges",1),Y([j("gitlens.views.openChangesWithWorking:")],CommitDetailsWebviewProvider.prototype,"openFileChangesWithWorking",1),Y([j("gitlens.views.openPreviousChangesWithWorking:")],CommitDetailsWebviewProvider.prototype,"openPreviousFileChangesWithWorking",1),Y([j("gitlens.views.openFile:")],CommitDetailsWebviewProvider.prototype,"openFile",1),Y([j("gitlens.openFileOnRemote:")],CommitDetailsWebviewProvider.prototype,"openFileOnRemote",1),Y([j("gitlens.views.stageFile:")],CommitDetailsWebviewProvider.prototype,"stageFile",1),Y([j("gitlens.views.unstageFile:")],CommitDetailsWebviewProvider.prototype,"unstageFile",1),Y([j("gitlens.views.copy:")],CommitDetailsWebviewProvider.prototype,"copy",1),Y([j("gitlens.copyRelativePathToClipboard:")],CommitDetailsWebviewProvider.prototype,"copyRelativePath",1),Y([j("gitlens.copyPatchToClipboard:")],CommitDetailsWebviewProvider.prototype,"copyPatch",1),Y([j("gitlens.views.openFileRevision:")],CommitDetailsWebviewProvider.prototype,"openFileRevision",1),Y([j("gitlens.openFileHistory:")],CommitDetailsWebviewProvider.prototype,"openFileHistory",1),Y([j("gitlens.quickOpenFileHistory:")],CommitDetailsWebviewProvider.prototype,"quickOpenFileHistory",1),Y([j("gitlens.visualizeHistory.file:")],CommitDetailsWebviewProvider.prototype,"visualizeFileHistory",1),Y([j("gitlens.openFileHistoryInGraph:")],CommitDetailsWebviewProvider.prototype,"openFileHistoryInGraph",1),Y([j("gitlens.restore.file:")],CommitDetailsWebviewProvider.prototype,"restoreFile",1),Y([j("gitlens.restorePrevious.file:")],CommitDetailsWebviewProvider.prototype,"restorePreviousFile",1),Y([j("gitlens.views.selectFileForCompare:")],CommitDetailsWebviewProvider.prototype,"selectFileForCompare",1),Y([j("gitlens.views.compareFileWithSelected:")],CommitDetailsWebviewProvider.prototype,"compareFileWithSelected",1),Y([j("gitlens.views.applyChanges:")],CommitDetailsWebviewProvider.prototype,"applyChanges",1),Y([j("gitlens.views.mergeChangesWithWorking:")],CommitDetailsWebviewProvider.prototype,"mergeChangesWithWorking",1),Y([j("gitlens.diffWithRevision:")],CommitDetailsWebviewProvider.prototype,"diffWithRevision",1),Y([j("gitlens.diffWithRevisionFrom:")],CommitDetailsWebviewProvider.prototype,"diffWithRevisionFrom",1),Y([j("gitlens.externalDiff:")],CommitDetailsWebviewProvider.prototype,"externalDiff",1),Y([j("gitlens.views.highlightChanges:")],CommitDetailsWebviewProvider.prototype,"highlightChanges",1),Y([j("gitlens.views.highlightRevisionChanges:")],CommitDetailsWebviewProvider.prototype,"highlightRevisionChanges",1),Y([j("gitlens.copyDeepLinkToCommit:")],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToCommit",1),Y([j("gitlens.copyDeepLinkToFile:")],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToFile",1),Y([j("gitlens.copyDeepLinkToFileAtRevision:")],CommitDetailsWebviewProvider.prototype,"copyDeepLinkToFileAtRevision",1),Y([j("gitlens.views.copyRemoteCommitUrl:")],CommitDetailsWebviewProvider.prototype,"copyRemoteCommitUrl",1),Y([j("gitlens.shareAsCloudPatch:")],CommitDetailsWebviewProvider.prototype,"shareAsCloudPatch",1),Y([j("gitlens.copyRemoteFileUrlFrom:")],CommitDetailsWebviewProvider.prototype,"copyRemoteFileUrlFrom",1),Y([j("gitlens.copyRemoteFileUrlWithoutRange:")],CommitDetailsWebviewProvider.prototype,"copyRemoteFileUrlWithoutRange",1)},7483:(e,t,i)=>{i.d(t,{l:()=>a});var s=i(1398),o=i(746),n=i(2948);async function a(e){if(e.storage.get("confirm:draft:storage",!1))return!0;for(;;){let t={title:"Continue"},i={title:"Cancel",isCloseAffordance:!0},a={title:"Learn More"},r={title:"Security"},l=await s.window.showInformationMessage("Cloud Patches are securely stored by GitKraken and can be accessed by anyone with the link and a GitKraken account.",{modal:!0},t,a,r,i);if(l===t)return e.storage.store("confirm:draft:storage",!0).catch(),!0;if(l===r){(0,n.CZ)(o.DS.security);continue}if(l===a){(0,n.CZ)(o.DS.cloudPatches);continue}return!1}}}};